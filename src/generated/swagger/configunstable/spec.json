{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "BaselineBehaviorOptionsErrorSampleOptions": {
      "properties": {
        "sample_rate": {
          "description": "Sample rate for traces with errors.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "BaselineBehaviorOptionsFastSampleOptions": {
      "properties": {
        "max_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled\naccording to the given sample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Sample rate for traces under the given duration.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "BaselineBehaviorOptionsLargeTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "For N = number of spans in the trace, if N \u003e= span_count_threshold, the trace is sampled according to the\ngiven sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "BaselineBehaviorOptionsSlowSampleOptions": {
      "properties": {
        "min_duration_seconds": {
          "description": "Duration in seconds over which traces are sampled\naccording to the given sample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "BaselineBehaviorOptionsSmallTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "For N = number of spans in the trace, if N \u003c= span_count_threshold, the trace is sampled according to the\ngiven sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "ChronoConfigCollectionsConfig": {
      "properties": {
        "group_teams": {
          "description": "Ordered map of prometheus group regexes to chronosphere team slug. This is used to\ndetermine which team will own the collection created for each prometheus group..",
          "items": {
            "$ref": "#/definitions/CollectionsConfigGroupTeam"
          },
          "type": "array"
        },
        "notification_policy_team_slug": {
          "description": "The team that will own the generated notification policy",
          "type": "string"
        }
      },
      "title": "Configuration for when ContainerType == COLLECTIONS or DEFAULT is collections",
      "type": "object"
    },
    "ChronoConfigSeverityMapping": {
      "properties": {
        "severity": {
          "type": "string"
        },
        "chronosphere_severity": {
          "$ref": "#/definitions/SeverityMappingSeverity"
        }
      },
      "type": "object"
    },
    "CollectionsConfigGroupTeam": {
      "properties": {
        "group_regex": {
          "type": "string"
        },
        "team_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "DatasetDatasetConfiguration": {
      "properties": {
        "type": {
          "$ref": "#/definitions/DatasetDatasetType"
        },
        "trace_dataset": {
          "$ref": "#/definitions/configunstableTraceDataset"
        },
        "log_dataset": {
          "$ref": "#/definitions/configunstableLogDataset"
        }
      },
      "type": "object"
    },
    "DatasetDatasetType": {
      "enum": [
        "TRACES",
        "LOGS"
      ],
      "type": "string"
    },
    "LogAllocationConfigAllocation": {
      "description": "Configuration for allocating resources to a dataset.",
      "properties": {
        "percent_of_license": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDatasetAllocation": {
      "properties": {
        "dataset_slug": {
          "description": "Slug of the dataset.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/LogAllocationConfigAllocation"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDefaultDataset": {
      "description": "Configuration for default dataset.",
      "properties": {
        "allocation": {
          "$ref": "#/definitions/LogAllocationConfigAllocation"
        }
      },
      "type": "object"
    },
    "NoopEntityNestedEnum": {
      "enum": [
        "ENABLED"
      ],
      "type": "string"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OtelMetricsIngestionResourceAttributes": {
      "properties": {
        "flatten_mode": {
          "$ref": "#/definitions/ResourceAttributesFlattenMode"
        },
        "filter_mode": {
          "$ref": "#/definitions/ResourceAttributesFilterMode"
        },
        "exclude_keys": {
          "description": "Do not copy any resource attribute whose key exactly matches one of the\nstrings in this list.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "generate_target_info": {
          "description": "Generate a target_info time series with labels derived from resource\nattributes. The filter_mode and exclude_keys settings apply in the same way as\nfor the \"flatten\" operation. The default is false.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy should apply.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "ResourceAttributesFilterMode": {
      "enum": [
        "APPEND_DEFAULT_EXCLUDE_KEYS",
        "CUSTOM_EXCLUDE_KEYS"
      ],
      "type": "string"
    },
    "ResourceAttributesFlattenMode": {
      "enum": [
        "MERGE",
        "OVERWRITE",
        "IGNORE"
      ],
      "type": "string"
    },
    "SavedTraceSearchBetweenTimeFilter": {
      "properties": {
        "min_time": {
          "description": "Start time of the search interval.",
          "format": "date-time",
          "type": "string"
        },
        "max_time": {
          "description": "End time of the search interval.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchCloseToTimeFilter": {
      "properties": {
        "time": {
          "description": "Time around which the search will performed.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchRelativeTimeFilter": {
      "properties": {
        "start_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the beginning of the search interval.",
          "format": "int32",
          "type": "integer"
        },
        "end_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the end of the search interval.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTimeFilter": {
      "properties": {
        "close_to": {
          "$ref": "#/definitions/SavedTraceSearchCloseToTimeFilter"
        },
        "between": {
          "$ref": "#/definitions/SavedTraceSearchBetweenTimeFilter"
        },
        "relative": {
          "$ref": "#/definitions/SavedTraceSearchRelativeTimeFilter"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTraceSearch": {
      "properties": {
        "criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "time": {
          "$ref": "#/definitions/SavedTraceSearchTimeFilter"
        }
      },
      "type": "object"
    },
    "SeverityMappingSeverity": {
      "enum": [
        "CRITICAL"
      ],
      "type": "string"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "SyncPrometheusChangeLog": {
      "properties": {
        "type": {
          "$ref": "#/definitions/SyncPrometheusChangeLogType"
        },
        "diff": {
          "description": "TODO: do we want to keep diff in the public API?",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SyncPrometheusChangeLogType": {
      "enum": [
        "CREATED_NOTIFIER",
        "UPDATED_NOTIFIER",
        "DELETED_NOTIFIER",
        "CREATED_BUCKET",
        "UPDATED_BUCKET",
        "DELETED_BUCKET",
        "CREATED_COLLECTION",
        "UPDATED_COLLECTION",
        "DELETED_COLLECTION",
        "CREATED_NOTIFICATION_POLICY",
        "UPDATED_NOTIFICATION_POLICY",
        "DELETED_NOTIFICATION_POLICY",
        "CREATED_MONITOR",
        "UPDATED_MONITOR",
        "DELETED_MONITOR",
        "CREATED_RECORDING_RULE",
        "UPDATED_RECORDING_RULE",
        "DELETED_RECORDING_RULE"
      ],
      "type": "string"
    },
    "SyncPrometheusChronoConfig": {
      "properties": {
        "use_collections": {
          "$ref": "#/definitions/SyncPrometheusContainerType"
        },
        "collections_config": {
          "$ref": "#/definitions/ChronoConfigCollectionsConfig"
        },
        "severity_mappings": {
          "items": {
            "$ref": "#/definitions/ChronoConfigSeverityMapping"
          },
          "type": "array"
        },
        "severity_label_name": {
          "description": "Customer-specific name of alert rule label used to determine severity.\nIf omitted, the Chronosphere default of \"severity\" is used.",
          "type": "string"
        },
        "assign_monitor_slugs": {
          "description": "TODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        },
        "monitor_signal_per_series": {
          "description": "If true, each monitor will not group alert notifications.",
          "type": "boolean"
        },
        "infer_monitor_signals": {
          "description": "Controls whether we try to infer monitor signals from the alertmanager route tree.",
          "type": "boolean"
        },
        "group_across_severities": {
          "description": "If true, we set the the group_across_severities flag on notification policies to\ntrue, so that warn and critical notifications are grouped together.\n\nTODO:  i don't think we export this on notification policies in the public API,\n       we may need to figure out a better solution here (do we need to expose\n       in both, or do we need to update the comment to stop referring to the\n       option on the policy?)",
          "type": "boolean"
        },
        "exists_op_supported": {
          "description": "If true, alert rule expressions that are not in the form of \"expr op number\" (e.g. \"sum(stuff) \u003e 5\")\nwill be executed as-is.\nWithout this set, expressions will be converted to binary expressions (e.g. \"x \u003e y\" as \"(x - y) \u003e 0\").\n\nTODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SyncPrometheusContainerType": {
      "enum": [
        "COLLECTIONS",
        "BUCKETS"
      ],
      "title": "TODO: confirm naming with InfoModel team",
      "type": "string"
    },
    "TraceBehaviorBaselineBehaviorOptions": {
      "properties": {
        "base_tail_sample_rate": {
          "description": "Sample rate for fully assembled traces that do not apply to the error, fast, slow, large, or small sampling options.\nIf they do apply to one or more of these options, the smallest sample rate is used.",
          "format": "double",
          "type": "number"
        },
        "base_head_sample_rate": {
          "description": "Sample rate for head sampling. This applies to all root spans that are enrolled in head sampling,\nbut do not have a specific rule defined for their service.",
          "format": "double",
          "type": "number"
        },
        "error_sample_options": {
          "$ref": "#/definitions/BaselineBehaviorOptionsErrorSampleOptions"
        },
        "fast_sample_options": {
          "$ref": "#/definitions/BaselineBehaviorOptionsFastSampleOptions"
        },
        "slow_sample_options": {
          "$ref": "#/definitions/BaselineBehaviorOptionsSlowSampleOptions"
        },
        "large_trace_sample_options": {
          "$ref": "#/definitions/BaselineBehaviorOptionsLargeTraceSampleOptions"
        },
        "small_trace_sample_options": {
          "$ref": "#/definitions/BaselineBehaviorOptionsSmallTraceSampleOptions"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigMainBehaviorAssignment": {
      "properties": {
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "Slug reference of a TraceDataset",
          "type": "string"
        },
        "behavior_slug": {
          "description": "Slug reference of a TraceBehavior",
          "type": "string"
        },
        "created_by": {
          "description": "Author/creator of the entry.",
          "type": "string"
        },
        "description": {
          "description": "Description of the entry.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigOverrideBehaviorAssignment": {
      "properties": {
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "Slug reference of a TraceDataset",
          "type": "string"
        },
        "behavior_slug": {
          "description": "Slug reference of a TraceBehavior",
          "type": "string"
        },
        "start_time": {
          "description": "Start and end time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "end_time": {
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "Author/creator of the entry.",
          "type": "string"
        },
        "description": {
          "description": "Description of the entry.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorTraceBehaviorType": {
      "description": " - TYPE_KEEP_ALL: Keep all traces.\n - TYPE_DROP_ALL: Drop all traces.\n - TYPE_BASELINE: Keep traces based on a default sample rate and additional sample rates for fast, slow, and error traces.",
      "enum": [
        "TYPE_KEEP_ALL",
        "TYPE_DROP_ALL",
        "TYPE_BASELINE"
      ],
      "type": "string"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range [0, 1]) when specific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the default sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range [0, 1] that defines the probability of sampling any trace.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "string"
        },
        "in_values": {
          "description": "Values the filter tests against when using IN or NOT_IN match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key (or name) of the span tag that is inspected by this filter.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableCreateDatasetRequest": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configunstableDataset"
        },
        "dry_run": {
          "description": "If true, the Dataset will not be created, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configunstableDataset"
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateRequest": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        },
        "dry_run": {
          "description": "If true, the LinkTemplate will not be created, and no response LinkTemplate will be returned. The response will return an error if the given LinkTemplate is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configunstableLogAllocationConfig"
        },
        "dry_run": {
          "description": "If true, the LogAllocationConfig will not be created, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configunstableLogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityRequest": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableCreateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configunstableOtelMetricsIngestion"
        },
        "dry_run": {
          "description": "If true, the OtelMetricsIngestion will not be created, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configunstableOtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchRequest": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceRequest": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        },
        "dry_run": {
          "description": "If true, the Service will not be created, and no response Service will be returned. The response will return an error if the given Service is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configunstableTraceBehaviorConfig"
        },
        "dry_run": {
          "description": "If true, the TraceBehaviorConfig will not be created, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configunstableTraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceBehaviorRequest": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configunstableTraceBehavior"
        },
        "dry_run": {
          "description": "If true, the TraceBehavior will not be created, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configunstableTraceBehavior"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableDashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Dashboard. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Dashboard. May be modified after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Required slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableDataset": {
      "properties": {
        "name": {
          "description": "Required name of the Dataset. May be modified after the Dataset is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the Dataset. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Dataset is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dataset was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dataset was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional longer-form description of the dataset.",
          "type": "string"
        },
        "configuration": {
          "$ref": "#/definitions/DatasetDatasetConfiguration"
        }
      },
      "type": "object"
    },
    "configunstableDefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Whether to override the default sample rate",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configunstableDeleteDashboardResponse": {
      "type": "object"
    },
    "configunstableDeleteDatasetResponse": {
      "type": "object"
    },
    "configunstableDeleteLinkTemplateResponse": {
      "type": "object"
    },
    "configunstableDeleteLogAllocationConfigResponse": {
      "type": "object"
    },
    "configunstableDeleteNoopEntityResponse": {
      "properties": {
        "not_hidden": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableDeleteOtelMetricsIngestionResponse": {
      "type": "object"
    },
    "configunstableDeleteSavedTraceSearchResponse": {
      "type": "object"
    },
    "configunstableDeleteServiceResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceBehaviorConfigResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceBehaviorResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configunstableLinkTemplate": {
      "properties": {
        "slug": {
          "description": "Unique slug identifying the LinkTemplate.",
          "type": "string"
        },
        "name": {
          "description": "Unique name of the LinkTemplate. Used as the link text.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LinkTemplate was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LinkTemplate was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "url_template": {
          "description": "URL template.",
          "type": "string"
        },
        "ui_component": {
          "description": "Link template is scoped to the specified string representing a UI component here.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configunstableDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListDatasetsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "datasets": {
          "items": {
            "$ref": "#/definitions/configunstableDataset"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListLinkTemplatesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "link_templates": {
          "items": {
            "$ref": "#/definitions/configunstableLinkTemplate"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListNoopEntitiesResponse": {
      "properties": {
        "noop_entities": {
          "items": {
            "$ref": "#/definitions/configunstableNoopEntity"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListSavedTraceSearchesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "saved_trace_searches": {
          "description": "Found saved trace searches.",
          "items": {
            "$ref": "#/definitions/configunstableSavedTraceSearch"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configunstableService"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListTraceBehaviorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_behaviors": {
          "items": {
            "$ref": "#/definitions/configunstableTraceBehavior"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableLogAllocationConfig": {
      "description": "LogAllocationConfig is a singleton configuration object that specifies the\nconfiguration for Log budget allocations.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogAllocationConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogAllocationConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_dataset": {
          "$ref": "#/definitions/LogAllocationConfigDefaultDataset"
        },
        "dataset_allocations": {
          "description": "Defines datasets and budget allocations. Datasets are evaluated in order.",
          "items": {
            "$ref": "#/definitions/LogAllocationConfigDatasetAllocation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableLogDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configunstableLogSearchFilter"
        }
      },
      "type": "object"
    },
    "configunstableLogSearchFilter": {
      "properties": {
        "query": {
          "description": "Matches logs which match this query.\nQuery may only include top level operations (no nested clauses).\nOnly one type of operator AND/OR is allowed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableNoopEntity": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the NoopEntity. If slug is not provided, one will be generated based of the name field. Cannot be modified after the NoopEntity is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the NoopEntity. May be modified after the NoopEntity is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NoopEntity was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NoopEntity was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "nested_enum": {
          "$ref": "#/definitions/NoopEntityNestedEnum"
        },
        "enum": {
          "$ref": "#/definitions/configunstableNoopEnum"
        }
      },
      "type": "object"
    },
    "configunstableNoopEnum": {
      "enum": [
        "ACTIVE"
      ],
      "type": "string"
    },
    "configunstableOtelMetricsIngestion": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource_attributes": {
          "$ref": "#/definitions/OtelMetricsIngestionResourceAttributes"
        }
      },
      "type": "object"
    },
    "configunstableReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableReadDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configunstableDataset"
        }
      },
      "type": "object"
    },
    "configunstableReadLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableReadLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configunstableLogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configunstableReadNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableReadOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configunstableOtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configunstableReadSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configunstableTraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configunstableTraceBehavior"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableSavedTraceSearch": {
      "properties": {
        "name": {
          "description": "Required name of the SavedTraceSearch. May be modified after the SavedTraceSearch is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the SavedTraceSearch. If slug is not provided, one will be generated based of the name field. Cannot be modified after the SavedTraceSearch is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the SavedTraceSearch was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SavedTraceSearch was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "search": {
          "$ref": "#/definitions/SavedTraceSearchTraceSearch"
        },
        "comparison": {
          "$ref": "#/definitions/SavedTraceSearchTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableService": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Service. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Service. May be modified after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "derived_name": {
          "description": "Required telemetry name of the service.",
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableSyncPrometheusRequest": {
      "properties": {
        "rules_yaml": {
          "type": "string"
        },
        "rules_yaml_gzip": {
          "format": "byte",
          "type": "string"
        },
        "alertmanager_yaml": {
          "type": "string"
        },
        "alertmanager_yaml_gzip": {
          "format": "byte",
          "type": "string"
        },
        "chrono_config": {
          "$ref": "#/definitions/SyncPrometheusChronoConfig"
        },
        "dry_run": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableSyncPrometheusResponse": {
      "properties": {
        "changes": {
          "items": {
            "$ref": "#/definitions/SyncPrometheusChangeLog"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableTraceBehavior": {
      "properties": {
        "name": {
          "description": "Required name of the TraceBehavior. May be modified after the TraceBehavior is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceBehavior. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceBehavior is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehavior was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehavior was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/TraceBehaviorTraceBehaviorType"
        },
        "baseline_behavior_options": {
          "$ref": "#/definitions/TraceBehaviorBaselineBehaviorOptions"
        }
      },
      "type": "object"
    },
    "configunstableTraceBehaviorConfig": {
      "description": "TraceBehaviorConfig is a singleton configuration object that specifies the\nconfiguration for trace behaviors.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "main_behavior_assignments": {
          "description": "List of Main Behavior Assignments. The datasets referenced here are the\ndatasets considered to be 'enrolled' in behaviors. The behaviors referenced\nhere are the active behaviors for the dataset when there is no override in\nplace. \n* There can only be one main behavior assignment per dataset.\n* There can only be one TraceBehavior referenced that has the type field\nset to TYPE_BASELINE.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigMainBehaviorAssignment"
          },
          "type": "array"
        },
        "override_behavior_assignments": {
          "description": "List of OverrideBehaviorAssignments. OverrideBehaviorAssignments are used to\nspecify the active behavior for a dataset over a specific time range.\n* There can only be one override assignment for each Dataset.\n* There can only be one TraceBehavior referenced that has the type field\nset to TYPE_BASELINE, and it must be the same as the one in the\nmain_behavior_assignments list.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "dataset_priorities": {
          "description": "List of dataset priorities. This list specifies the order in which datasets\nare considered when determining the behavior to follow for a trace. Dataset\npriorities are used to break ties when a trace matches more than one dataset\nwith an active behavior.\n* Each entry in this list must refer to the slug of an existing dataset.\n* The order of the list is the order in which the datasets are considered.\n* The list must contain all datasets referenced in either main_behavior_assignments\n  and override_behavior_assignments.\n* The list may contain datasets that are not referenced in either of the above.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableTraceDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        }
      },
      "type": "object"
    },
    "configunstableTraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the TraceJaegerRemoteSamplingStrategy. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the TraceJaegerRemoteSamplingStrategy. May be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This must match the slug and name fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configunstableTraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule, which summarizes what it's for",
          "type": "string"
        },
        "system_name": {
          "description": "Value used as the metric label value for metrics emitted relating to this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "When the rule was created (novel system_name)",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "When the rule was updated (existing system_name)",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableTraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. A list of rules, evaluated in order until a match is found,\nand the sample rate applied, or else the default sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configunstableTraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configunstableDefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configunstableUpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableUpdateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configunstableDataset"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configunstableLogAllocationConfig"
        },
        "create_if_missing": {
          "description": "If true, the LogAllocationConfig will be created if it does not already exist. If false, an error will be returned if the LogAllocationConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the LogAllocationConfig will not be created nor updated, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configunstableLogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configunstableUpdateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableUpdateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configunstableOtelMetricsIngestion"
        },
        "create_if_missing": {
          "description": "If true, the OtelMetricsIngestion will be created if it does not already exist. If false, an error will be returned if the OtelMetricsIngestion does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the OtelMetricsIngestion will not be created nor updated, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configunstableOtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configunstableUpdateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableUpdateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configunstableTraceBehaviorConfig"
        },
        "create_if_missing": {
          "description": "If true, the TraceBehaviorConfig will be created if it does not already exist. If false, an error will be returned if the TraceBehaviorConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceBehaviorConfig will not be created nor updated, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configunstableTraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configunstableTraceBehavior"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If true, the TraceTailSamplingRules will be created if it does not already exist. If false, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created nor updated, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Each SpanFilter object represents all conditions that need to be true on\nthe same span for the span to be considered matching the SpanFilter. If\n`span_count` is used, the number of spans within the trace that match the\nSpanFilter needs to be within [min, max]. Multiple SpanFilters can be used,\nand each can be satisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\n\u003cb\u003eWARNING: This API is unstable and is meant for experimentation only. Do not\nuse this API in production. The endpoints and schemas referenced in this\ndocumentation will be changed or removed without notice and without any\nbackwards compatibility guarantee. Note that even though this API is unstable,\nit is still connected to production data, so use with caution.\u003c/b\u003e",
    "title": "Config Unstable API",
    "version": "UNSTABLE"
  },
  "paths": {
    "/api/unstable/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Dashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the Dashboard does not already exist.",
                  "type": "boolean"
                },
                "dashboard": {
                  "$ref": "#/definitions/configunstableDashboard"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/datasets": {
      "get": {
        "operationId": "ListDatasets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dataset with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dataset with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Custom filtering option: list filtered down to a specific telemetry type.",
            "enum": [
              "TRACES",
              "LOGS"
            ],
            "in": "query",
            "name": "type",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListDatasetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "post": {
        "operationId": "CreateDataset",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateDatasetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dataset.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/unstable/config/datasets/{slug}": {
      "delete": {
        "operationId": "DeleteDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dataset because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "get": {
        "operationId": "ReadDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadDatasetResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "put": {
        "operationId": "UpdateDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Dataset will be created if it does not already exist, identified by slug. If false, an error will be returned if the Dataset does not already exist.",
                  "type": "boolean"
                },
                "dataset": {
                  "$ref": "#/definitions/configunstableDataset"
                },
                "dry_run": {
                  "description": "If true, the Dataset will not be created nor updated, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dataset.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/unstable/config/link-templates": {
      "get": {
        "operationId": "ListLinkTemplates",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LinkTemplate with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LinkTemplate with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by ui_component, where any LinkTemplate with a matching ui_component in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "ui_components",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListLinkTemplatesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "post": {
        "operationId": "CreateLinkTemplate",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot create the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/link-templates/{slug}": {
      "delete": {
        "operationId": "DeleteLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LinkTemplate because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "get": {
        "operationId": "ReadLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadLinkTemplateResponse"
            }
          },
          "404": {
            "description": "Cannot read the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "put": {
        "operationId": "UpdateLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the LinkTemplate will be created if it does not already exist, identified by slug. If false, an error will be returned if the LinkTemplate does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the LinkTemplate will not be created nor updated, and no response LinkTemplate will be returned. The response will return an error if the given LinkTemplate is invalid.",
                  "type": "boolean"
                },
                "link_template": {
                  "$ref": "#/definitions/configunstableLinkTemplate"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot update the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/log-allocation-config": {
      "delete": {
        "operationId": "DeleteLogAllocationConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogAllocationConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogAllocationConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadLogAllocationConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogAllocationConfig because there is a conflict with an existing LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      }
    },
    "/api/unstable/config/noop-entities": {
      "post": {
        "operationId": "CreateNoopEntity",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot create the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/noop-entities/{slug}": {
      "delete": {
        "operationId": "DeleteNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NoopEntity because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "get": {
        "operationId": "ReadNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadNoopEntityResponse"
            }
          },
          "404": {
            "description": "Cannot read the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "put": {
        "operationId": "UpdateNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the NoopEntity will be created if it does not already exist, identified by slug. If false, an error will be returned if the NoopEntity does not already exist.",
                  "type": "boolean"
                },
                "noop_entity": {
                  "$ref": "#/definitions/configunstableNoopEntity"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot update the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/otel-metrics-ingestion": {
      "delete": {
        "operationId": "DeleteOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the OtelMetricsIngestion because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the OtelMetricsIngestion because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "get": {
        "operationId": "ReadOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadOtelMetricsIngestionResponse"
            }
          },
          "404": {
            "description": "Cannot read the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "post": {
        "operationId": "CreateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot create the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the OtelMetricsIngestion because there is a conflict with an existing OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "put": {
        "operationId": "UpdateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot update the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches": {
      "get": {
        "operationId": "ListSavedTraceSearches",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SavedTraceSearch with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SavedTraceSearch with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional filter: creator email address.",
            "in": "query",
            "name": "created_by",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListSavedTraceSearchesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "post": {
        "description": "***\nSaved Trace Searches\n***",
        "operationId": "CreateSavedTraceSearch",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot create the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches/{slug}": {
      "delete": {
        "operationId": "DeleteSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SavedTraceSearch because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "get": {
        "operationId": "ReadSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadSavedTraceSearchResponse"
            }
          },
          "404": {
            "description": "Cannot read the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "put": {
        "operationId": "UpdateSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the SavedTraceSearch will be created if it does not already exist, identified by slug. If false, an error will be returned if the SavedTraceSearch does not already exist.",
                  "type": "boolean"
                },
                "saved_trace_search": {
                  "$ref": "#/definitions/configunstableSavedTraceSearch"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot update the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Service with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Service with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get services that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "post": {
        "operationId": "CreateService",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Service.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot create the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/services/{slug}": {
      "delete": {
        "operationId": "DeleteService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteServiceResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Service because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "put": {
        "operationId": "UpdateService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Service will be created if it does not already exist, identified by slug. If false, an error will be returned if the Service does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Service will not be created nor updated, and no response Service will be returned. The response will return an error if the given Service is invalid.",
                  "type": "boolean"
                },
                "service": {
                  "$ref": "#/definitions/configunstableService"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Service.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot update the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/sync-prometheus": {
      "post": {
        "description": "***\nSync Prometheus Configuration\n***",
        "operationId": "SyncPrometheus",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "SyncPrometheus"
        ]
      }
    },
    "/api/unstable/config/trace-behavior-config": {
      "delete": {
        "operationId": "DeleteTraceBehaviorConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehaviorConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehaviorConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehaviorConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceBehaviorConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehaviorConfig because there is a conflict with an existing TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      }
    },
    "/api/unstable/config/trace-behaviors": {
      "get": {
        "operationId": "ListTraceBehaviors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceBehavior with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceBehavior with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListTraceBehaviorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehavior",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceBehaviorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/unstable/config/trace-behaviors/{slug}": {
      "delete": {
        "operationId": "DeleteTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehavior because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceBehaviorResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the TraceBehavior will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceBehavior does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the TraceBehavior will not be created nor updated, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
                  "type": "boolean"
                },
                "trace_behavior": {
                  "$ref": "#/definitions/configunstableTraceBehavior"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created nor updated, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
                  "type": "boolean"
                },
                "trace_jaeger_remote_sampling_strategy": {
                  "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigUnstable"
    }
  ]
}