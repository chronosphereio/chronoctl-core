{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "AzureMetricsIntegrationAzurePrincipal": {
      "properties": {
        "tenant_id": {
          "description": "Specifies the ID of the Azure tenant that hosts the managed identity principal.",
          "type": "string"
        },
        "client_id": {
          "description": "Specifies the OAuth2 client ID of the managed identity principal.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureResourceType": {
      "properties": {
        "name": {
          "description": "Name of the resource type.",
          "type": "string"
        },
        "metric_names": {
          "description": "List of metric names to be targeted (these apply to this resource type; use empty for all metrics).",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureScrapeConfig": {
      "properties": {
        "subscription_ids": {
          "description": "Subscriptions to be targeted for this integration (use empty for all subscriptions).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "locations": {
          "description": "Locations to be ingested for this integration (these apply to all subscriptions; use empty for all locations).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "resource_types": {
          "description": "Metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/AzureMetricsIntegrationAzureResourceType"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "BehaviorAction": {
      "enum": [
        "ALERT_WARN",
        "ALERT_CRITICAL",
        "DROP"
      ],
      "type": "string"
    },
    "BehaviorInstantRateThreshold": {
      "properties": {
        "fixed_value_per_sec": {
          "description": "fixed_value_per_sec is the required rate threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "BehaviorThresholdType": {
      "enum": [
        "VOLUME",
        "INSTANT_RATE"
      ],
      "type": "string"
    },
    "BehaviorVolumeThreshold": {
      "properties": {
        "time_period": {
          "$ref": "#/definitions/VolumeThresholdTimePeriod"
        },
        "fixed_value": {
          "description": "fixed_value is the required volume threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ChronoConfigCollectionsConfig": {
      "properties": {
        "group_teams": {
          "description": "Ordered map of prometheus group regexes to chronosphere team slug. This is used to\ndetermine which team will own the collection created for each prometheus group..",
          "items": {
            "$ref": "#/definitions/CollectionsConfigGroupTeam"
          },
          "type": "array"
        },
        "notification_policy_team_slug": {
          "description": "The team that will own the generated notification policy",
          "type": "string"
        }
      },
      "title": "Configuration for when ContainerType == COLLECTIONS or DEFAULT is collections",
      "type": "object"
    },
    "ChronoConfigSeverityMapping": {
      "properties": {
        "severity": {
          "type": "string"
        },
        "chronosphere_severity": {
          "$ref": "#/definitions/SeverityMappingSeverity"
        }
      },
      "type": "object"
    },
    "CollectionsConfigGroupTeam": {
      "properties": {
        "group_regex": {
          "type": "string"
        },
        "team_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateAzureMetricsIntegrationBody": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configunstableAzureMetricsIntegration"
        },
        "create_if_missing": {
          "description": "If `true`, the AzureMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the AzureMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the AzureMetricsIntegration isn't created or updated, and no response AzureMetricsIntegration will be returned. The response will return an error if the given AzureMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateConsumptionBudgetBody": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configunstableConsumptionBudget"
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionBudget will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the ConsumptionBudget does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the ConsumptionBudget isn't created or updated, and no response ConsumptionBudget will be returned. The response will return an error if the given ConsumptionBudget is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateDashboardBody": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the Dashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateLinkTemplateBody": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        },
        "create_if_missing": {
          "description": "If `true`, the LinkTemplate will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LinkTemplate does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LinkTemplate isn't created or updated, and no response LinkTemplate will be returned. The response will return an error if the given LinkTemplate is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateNoopEntityBody": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        },
        "create_if_missing": {
          "description": "If `true`, the NoopEntity will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the NoopEntity does not already exist.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateObjectDiscoveryRuleBody": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        },
        "create_if_missing": {
          "description": "If `true`, the ObjectDiscoveryRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the ObjectDiscoveryRule does not already exist.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateSavedTraceSearchBody": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        },
        "create_if_missing": {
          "description": "If `true`, the SavedTraceSearch will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the SavedTraceSearch does not already exist.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateServiceBody": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        },
        "create_if_missing": {
          "description": "If `true`, the Service will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Service does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Service isn't created or updated, and no response Service will be returned. The response will return an error if the given Service is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy isn't created or updated, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetBehavior": {
      "properties": {
        "action": {
          "$ref": "#/definitions/BehaviorAction"
        },
        "threshold_type": {
          "$ref": "#/definitions/BehaviorThresholdType"
        },
        "instant_rate_threshold": {
          "$ref": "#/definitions/BehaviorInstantRateThreshold"
        },
        "volume_threshold": {
          "$ref": "#/definitions/BehaviorVolumeThreshold"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetPriority": {
      "properties": {
        "dataset_filters": {
          "description": "dataset_filters define what datasets match the priority.  The filters are\nAND'd together; a request must match every filter in order to match the\npriority.",
          "items": {
            "$ref": "#/definitions/configunstableDatasetFilter"
          },
          "type": "array"
        },
        "priority": {
          "description": "priority is the required priority of the dataset, where priority=1 is\nthe highest priority, and priority=10 is the lowest priority.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetResource": {
      "enum": [
        "LOG_PERSISTED_BYTES"
      ],
      "type": "string"
    },
    "ConsumptionConfigPartition": {
      "properties": {
        "name": {
          "description": "name is the name of the partition. Must be unique within the parent\npartition.",
          "type": "string"
        },
        "dataset_filters": {
          "description": "dataset_filters define what datasets match the partition. The filters are\nAND'd together; a request must match every filter in order to match the\npartition. Must not be empty.",
          "items": {
            "$ref": "#/definitions/configunstableDatasetFilter"
          },
          "type": "array"
        },
        "partitions": {
          "description": "partitions are the optional child partitions of this partition. If set,\nrequests which match the current partition will be allocated to the\nfirst child partition that matches. Requests that don't match any child\npartition fall back to an omnipresent default child partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DatasetFilterDataset": {
      "properties": {
        "dataset_slug": {
          "description": "dataset_slug is the slug of the dataset to match.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DatasetFilterOperator": {
      "enum": [
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "LogControlRuleDrop": {
      "description": "Drop is the configuration for a drop logs action.",
      "type": "object"
    },
    "LogControlRuleDropField": {
      "description": "DropField is the configuration for a drop field action.",
      "properties": {
        "field_regex": {
          "description": "Regular expression to match the field(s) to drop.",
          "type": "string"
        },
        "parent_path": {
          "description": "Fully specified path to the the field(s) to drop.\nIf empty, the field(s) to drop are at the root level of the log.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogControlRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogControlRuleSample": {
      "description": "Sample is the configuration for the sample logs action.",
      "properties": {
        "rate": {
          "description": "Percentage of matching logs to keep. Must be in the range [0, 1].",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "NoopEntityNestedEnum": {
      "enum": [
        "ENABLED"
      ],
      "type": "string"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "ObjectDiscoveryRuleMetricRule": {
      "properties": {
        "expr": {
          "type": "string"
        },
        "objectLabels": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "objectMappingLabel": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy should apply.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchBetweenTimeFilter": {
      "properties": {
        "min_time": {
          "description": "Start time of the search interval.",
          "format": "date-time",
          "type": "string"
        },
        "max_time": {
          "description": "End time of the search interval.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchCloseToTimeFilter": {
      "properties": {
        "time": {
          "description": "Time around which the search will performed.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchRelativeTimeFilter": {
      "properties": {
        "start_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the beginning of the search interval.",
          "format": "int32",
          "type": "integer"
        },
        "end_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the end of the search interval.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTimeFilter": {
      "properties": {
        "close_to": {
          "$ref": "#/definitions/SavedTraceSearchCloseToTimeFilter"
        },
        "between": {
          "$ref": "#/definitions/SavedTraceSearchBetweenTimeFilter"
        },
        "relative": {
          "$ref": "#/definitions/SavedTraceSearchRelativeTimeFilter"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTraceSearch": {
      "properties": {
        "criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "time": {
          "$ref": "#/definitions/SavedTraceSearchTimeFilter"
        }
      },
      "type": "object"
    },
    "SeverityMappingSeverity": {
      "enum": [
        "CRITICAL"
      ],
      "type": "string"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "SyncPrometheusChangeLog": {
      "properties": {
        "type": {
          "$ref": "#/definitions/SyncPrometheusChangeLogType"
        },
        "diff": {
          "description": "TODO: do we want to keep diff in the public API?",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SyncPrometheusChangeLogType": {
      "enum": [
        "CREATED_NOTIFIER",
        "UPDATED_NOTIFIER",
        "DELETED_NOTIFIER",
        "CREATED_BUCKET",
        "UPDATED_BUCKET",
        "DELETED_BUCKET",
        "CREATED_COLLECTION",
        "UPDATED_COLLECTION",
        "DELETED_COLLECTION",
        "CREATED_NOTIFICATION_POLICY",
        "UPDATED_NOTIFICATION_POLICY",
        "DELETED_NOTIFICATION_POLICY",
        "CREATED_MONITOR",
        "UPDATED_MONITOR",
        "DELETED_MONITOR",
        "CREATED_RECORDING_RULE",
        "UPDATED_RECORDING_RULE",
        "DELETED_RECORDING_RULE"
      ],
      "type": "string"
    },
    "SyncPrometheusChronoConfig": {
      "properties": {
        "use_collections": {
          "$ref": "#/definitions/SyncPrometheusContainerType"
        },
        "collections_config": {
          "$ref": "#/definitions/ChronoConfigCollectionsConfig"
        },
        "severity_mappings": {
          "items": {
            "$ref": "#/definitions/ChronoConfigSeverityMapping"
          },
          "type": "array"
        },
        "severity_label_name": {
          "description": "Customer-specific name of alert rule label used to determine severity.\nIf omitted, the Chronosphere default of \"severity\" is used.",
          "type": "string"
        },
        "assign_monitor_slugs": {
          "description": "TODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        },
        "monitor_signal_per_series": {
          "description": "If true, each monitor will not group alert notifications.",
          "type": "boolean"
        },
        "infer_monitor_signals": {
          "description": "Controls whether we try to infer monitor signals from the alertmanager route tree.",
          "type": "boolean"
        },
        "group_across_severities": {
          "description": "If true, we set the the group_across_severities flag on notification policies to\ntrue, so that warn and critical notifications are grouped together.\n\nTODO:  i don't think we export this on notification policies in the public API,\n       we may need to figure out a better solution here (do we need to expose\n       in both, or do we need to update the comment to stop referring to the\n       option on the policy?)",
          "type": "boolean"
        },
        "exists_op_supported": {
          "description": "If true, alert rule expressions that are not in the form of \"expr op number\" (e.g. \"sum(stuff) \u003e 5\")\nwill be executed as-is.\nWithout this set, expressions will be converted to binary expressions (e.g. \"x \u003e y\" as \"(x - y) \u003e 0\").\n\nTODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SyncPrometheusContainerType": {
      "enum": [
        "COLLECTIONS",
        "BUCKETS"
      ],
      "title": "TODO: confirm naming with InfoModel team",
      "type": "string"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range [0, 1]) when specific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the default sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range [0, 1] that defines the probability of sampling any trace.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate span.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        },
        "is_root_span": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "string"
        },
        "in_values": {
          "description": "Values the filter tests against when using `IN` or `NOT_IN` match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key or name of the span tag that this filter inspects.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "TraceTopTagConfigTraceTopTag": {
      "properties": {
        "tag_name": {
          "description": "Tag name that uniquely identifies a tag.",
          "type": "string"
        },
        "description": {
          "description": "Human readable description of the tag.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "VolumeThresholdTimePeriod": {
      "enum": [
        "DAILY",
        "WEEKLY",
        "MONTHLY"
      ],
      "type": "string"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableAzureMetricsIntegration": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the AzureMetricsIntegration. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the AzureMetricsIntegration. You can modify this value after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "principal": {
          "$ref": "#/definitions/AzureMetricsIntegrationAzurePrincipal"
        },
        "scrape_configs": {
          "description": "Specifies the scrape configs for this integration.",
          "items": {
            "$ref": "#/definitions/AzureMetricsIntegrationAzureScrapeConfig"
          },
          "type": "array"
        },
        "count_metrics_enabled": {
          "description": "Enables Azure count metrics for the configured resources.",
          "type": "boolean"
        },
        "usage_metrics_enabled": {
          "description": "Enables collection of azure usage metrics under this principal (Microsoft.Compute, Microsoft.Network, Microsoft.Storage).",
          "type": "boolean"
        },
        "propagate_tags": {
          "description": "Specifies whether Azure resource, group, and subscription tags should be propagated as metric labels.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableConsumptionBudget": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the ConsumptionBudget. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the ConsumptionBudget is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the ConsumptionBudget. You can modify this value after the ConsumptionBudget is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ConsumptionBudget was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionBudget was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource": {
          "$ref": "#/definitions/ConsumptionBudgetResource"
        },
        "partition_name_path": {
          "description": "partition_name_path is the required path of the budget's partition, in the\nformat `[\"global\", \"\u003cname1\u003e\", \"\u003cname2\u003e\", ...]`, where name1 is a top-level\npartition, and name2 is a child partition of name1, etc.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "priorities": {
          "description": "priorities are optional budget priorities. Priorites define in what\norder should requests be dropped when necessary (i.e. lowest priority\ndropped first, highest priority dropped last). If a request does not\nmatch any priority dataset, then it defaults to the lowest priority.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetPriority"
          },
          "type": "array"
        },
        "behaviors": {
          "description": "behaviors are optional budget behaviors for automated limiting and\nalerting.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetBehavior"
          },
          "type": "array"
        },
        "default_priority": {
          "description": "default_priority is an optional default priority for requests which do not\nmatch any priority in the priorities list. If not set, then the lowest\npriority (10) is used as the default.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "configunstableConsumptionConfig": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ConsumptionConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "partitions": {
          "description": "partitions define non-overlapping groupings of telemetry. Partitions are\ndefined in order of precedence, where incoming requests are allocated to\nthe first partition that matches. Requests that don't match any\npartition fall back to an omnipresent default partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableCreateAzureMetricsIntegrationRequest": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configunstableAzureMetricsIntegration"
        },
        "dry_run": {
          "description": "If `true`, the AzureMetricsIntegration isn't created, and no response AzureMetricsIntegration will be returned. The response will return an error if the given AzureMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configunstableAzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configunstableCreateConsumptionBudgetRequest": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configunstableConsumptionBudget"
        },
        "dry_run": {
          "description": "If `true`, the ConsumptionBudget isn't created, and no response ConsumptionBudget will be returned. The response will return an error if the given ConsumptionBudget is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configunstableConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configunstableCreateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configunstableConsumptionConfig"
        },
        "dry_run": {
          "description": "If `true`, the ConsumptionConfig isn't created, and no response ConsumptionConfig will be returned. The response will return an error if the given ConsumptionConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configunstableConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateRequest": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        },
        "dry_run": {
          "description": "If `true`, the LinkTemplate isn't created, and no response LinkTemplate will be returned. The response will return an error if the given LinkTemplate is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogControlConfigRequest": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configunstableLogControlConfig"
        },
        "dry_run": {
          "description": "If `true`, the LogControlConfig isn't created, and no response LogControlConfig will be returned. The response will return an error if the given LogControlConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configunstableLogControlConfig"
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityRequest": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableCreateObjectDiscoveryRuleRequest": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableCreateObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchRequest": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceRequest": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        },
        "dry_run": {
          "description": "If `true`, the Service isn't created, and no response Service will be returned. The response will return an error if the given Service is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy isn't created, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If `true`, the TraceTailSamplingRules isn't created, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTopTagConfigRequest": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        },
        "dry_run": {
          "description": "If `true`, the TraceTopTagConfig isn't created, and no response TraceTopTagConfig will be returned. The response will return an error if the given TraceTopTagConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configunstableDashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Dashboard. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Dashboard. You can modify this value after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Required slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableDatasetFilter": {
      "properties": {
        "operator": {
          "$ref": "#/definitions/DatasetFilterOperator"
        },
        "datasets": {
          "description": "datasets are the datasets to match.",
          "items": {
            "$ref": "#/definitions/DatasetFilterDataset"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableDefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Whether to override the default sample rate",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configunstableDeleteAzureMetricsIntegrationResponse": {
      "type": "object"
    },
    "configunstableDeleteConsumptionBudgetResponse": {
      "type": "object"
    },
    "configunstableDeleteConsumptionConfigResponse": {
      "type": "object"
    },
    "configunstableDeleteDashboardResponse": {
      "type": "object"
    },
    "configunstableDeleteLinkTemplateResponse": {
      "type": "object"
    },
    "configunstableDeleteLogControlConfigResponse": {
      "type": "object"
    },
    "configunstableDeleteNoopEntityResponse": {
      "properties": {
        "not_hidden": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableDeleteObjectDiscoveryRuleResponse": {
      "type": "object"
    },
    "configunstableDeleteSavedTraceSearchResponse": {
      "type": "object"
    },
    "configunstableDeleteServiceResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceTopTagConfigResponse": {
      "type": "object"
    },
    "configunstableLinkTemplate": {
      "properties": {
        "slug": {
          "description": "Unique slug identifying the LinkTemplate.",
          "type": "string"
        },
        "name": {
          "description": "Unique name of the LinkTemplate. Used as the link text.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LinkTemplate was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LinkTemplate was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "url_template": {
          "description": "URL template.",
          "type": "string"
        },
        "ui_component": {
          "description": "Link template is scoped to the specified string representing a UI component here.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableListAzureMetricsIntegrationsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "azure_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configunstableAzureMetricsIntegration"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListConsumptionBudgetsResponse": {
      "properties": {
        "consumption_budgets": {
          "items": {
            "$ref": "#/definitions/configunstableConsumptionBudget"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configunstableDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListLinkTemplatesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "link_templates": {
          "items": {
            "$ref": "#/definitions/configunstableLinkTemplate"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListNoopEntitiesResponse": {
      "properties": {
        "noop_entities": {
          "items": {
            "$ref": "#/definitions/configunstableNoopEntity"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListObjectDiscoveryRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "object_discovery_rules": {
          "items": {
            "$ref": "#/definitions/configunstableObjectDiscoveryRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListSavedTraceSearchesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "saved_trace_searches": {
          "description": "Found saved trace searches.",
          "items": {
            "$ref": "#/definitions/configunstableSavedTraceSearch"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configunstableService"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableLogControlConfig": {
      "description": "LogControlConfig is a singleton configuration object that specifies the\nconfiguration for log control.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogControlConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogControlConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Control Rules are the ordered list of control rules.",
          "items": {
            "$ref": "#/definitions/configunstableLogControlRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableLogControlRule": {
      "description": "LogControlRule is the configuration for a log control rule.",
      "properties": {
        "name": {
          "description": "Name is the name of the control rule.",
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/LogControlRuleMode"
        },
        "filter": {
          "description": "LogQL query to select logs. Only matching logs will have control action applied.",
          "type": "string"
        },
        "drop": {
          "$ref": "#/definitions/LogControlRuleDrop"
        },
        "sample": {
          "$ref": "#/definitions/LogControlRuleSample"
        },
        "drop_field": {
          "$ref": "#/definitions/LogControlRuleDropField"
        }
      },
      "type": "object"
    },
    "configunstableNoopEntity": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the NoopEntity. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the NoopEntity is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the NoopEntity. You can modify this value after the NoopEntity is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NoopEntity was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NoopEntity was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "nested_enum": {
          "$ref": "#/definitions/NoopEntityNestedEnum"
        },
        "enum": {
          "$ref": "#/definitions/configunstableNoopEnum"
        }
      },
      "type": "object"
    },
    "configunstableNoopEnum": {
      "enum": [
        "ACTIVE"
      ],
      "type": "string"
    },
    "configunstableObjectDiscoveryRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the ObjectDiscoveryRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the ObjectDiscoveryRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the ObjectDiscoveryRule. You can modify this value after the ObjectDiscoveryRule is created.",
          "type": "string"
        },
        "metric": {
          "$ref": "#/definitions/ObjectDiscoveryRuleMetricRule"
        }
      },
      "type": "object"
    },
    "configunstableReadAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configunstableAzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configunstableReadConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configunstableConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configunstableReadConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configunstableConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configunstableReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableReadLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableReadLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configunstableLogControlConfig"
        }
      },
      "type": "object"
    },
    "configunstableReadNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableReadObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableReadSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configunstableSavedTraceSearch": {
      "properties": {
        "name": {
          "description": "Name of the SavedTraceSearch. You can modify this value after the SavedTraceSearch is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the SavedTraceSearch. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the SavedTraceSearch is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the SavedTraceSearch was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SavedTraceSearch was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "search": {
          "$ref": "#/definitions/SavedTraceSearchTraceSearch"
        },
        "comparison": {
          "$ref": "#/definitions/SavedTraceSearchTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableService": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Service. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Service. You can modify this value after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "derived_name": {
          "description": "Required telemetry name of the service.",
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableSyncPrometheusRequest": {
      "properties": {
        "rules_yaml": {
          "type": "string"
        },
        "rules_yaml_gzip": {
          "format": "byte",
          "type": "string"
        },
        "alertmanager_yaml": {
          "type": "string"
        },
        "alertmanager_yaml_gzip": {
          "format": "byte",
          "type": "string"
        },
        "chrono_config": {
          "$ref": "#/definitions/SyncPrometheusChronoConfig"
        },
        "dry_run": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableSyncPrometheusResponse": {
      "properties": {
        "changes": {
          "items": {
            "$ref": "#/definitions/SyncPrometheusChangeLog"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableTraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the TraceJaegerRemoteSamplingStrategy. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the TraceJaegerRemoteSamplingStrategy. You can modify this value after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This must match the slug and name fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configunstableTraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule, which summarizes what it's for",
          "type": "string"
        },
        "system_name": {
          "description": "Value used as the metric label value for metrics emitted relating to this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "When the rule was created (novel system_name)",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "When the rule was updated (existing system_name)",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableTraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. A list of rules, evaluated in order until a match is found,\nand the sample rate applied, or else the default sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configunstableTraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configunstableDefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configunstableTraceTopTagConfig": {
      "description": "TraceTopTagConfig is a singleton configuration object that specifies the\nconfiguration for top tracing tags.",
      "properties": {
        "id": {
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceTopTagConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceTopTagConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "source_client": {
          "type": "string"
        },
        "top_tags": {
          "description": "The list of \"top\" tags. Must be unique by tag_name.",
          "items": {
            "$ref": "#/definitions/TraceTopTagConfigTraceTopTag"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableUpdateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configunstableAzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configunstableUpdateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configunstableConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configunstableUpdateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configunstableConsumptionConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionConfig will be created if it does not already exist. If `false`, an error will be returned if the ConsumptionConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the ConsumptionConfig isn't created or updated, and no response ConsumptionConfig will be returned. The response will return an error if the given ConsumptionConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configunstableConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configunstableUpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLogControlConfigRequest": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configunstableLogControlConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogControlConfig will be created if it does not already exist. If `false`, an error will be returned if the LogControlConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LogControlConfig isn't created or updated, and no response LogControlConfig will be returned. The response will return an error if the given LogControlConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configunstableLogControlConfig"
        }
      },
      "type": "object"
    },
    "configunstableUpdateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableUpdateObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableUpdateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableUpdateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceTailSamplingRules will be created if it does not already exist. If `false`, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceTailSamplingRules isn't created or updated, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTopTagConfigRequest": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceTopTagConfig will be created if it does not already exist. If `false`, an error will be returned if the TraceTopTagConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceTopTagConfig isn't created or updated, and no response TraceTopTagConfig will be returned. The response will return an error if the given TraceTopTagConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Specifies the span conditions to match on. All conditions must be true in a\nsingle span for the span to be considered a match. If `span_count` is specified,\nthe number of spans within the trace that match span conditions must be within\n`[min, max]`. You can specify multiple span conditions, and each can be\nsatisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\n\u003cb\u003eWARNING: This API is unstable and is meant for experimentation only. Do not\nuse this API in production. The endpoints and schemas referenced in this\ndocumentation will be changed or removed without notice and without any\nbackwards compatibility guarantee. Note that even though this API is unstable,\nit is still connected to production data, so use with caution.\u003c/b\u003e",
    "title": "Config Unstable API",
    "version": "UNSTABLE"
  },
  "paths": {
    "/api/unstable/config/azure-metrics-integrations": {
      "get": {
        "operationId": "ListAzureMetricsIntegrations",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any AzureMetricsIntegration with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any AzureMetricsIntegration with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListAzureMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateAzureMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/unstable/config/azure-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the AzureMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadAzureMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateAzureMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/unstable/config/consumption-budgets": {
      "get": {
        "operationId": "ListConsumptionBudgets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ConsumptionBudget with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ConsumptionBudget with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListConsumptionBudgetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionBudget",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateConsumptionBudgetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/unstable/config/consumption-budgets/{slug}": {
      "delete": {
        "operationId": "DeleteConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionBudget because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadConsumptionBudgetResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateConsumptionBudgetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/unstable/config/consumption-config": {
      "delete": {
        "operationId": "DeleteConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadConsumptionConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionConfig because there is a conflict with an existing ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      }
    },
    "/api/unstable/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/link-templates": {
      "get": {
        "operationId": "ListLinkTemplates",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LinkTemplate with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LinkTemplate with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by ui_component, where any LinkTemplate with a matching ui_component in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "ui_components",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListLinkTemplatesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "post": {
        "operationId": "CreateLinkTemplate",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot create the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/link-templates/{slug}": {
      "delete": {
        "operationId": "DeleteLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LinkTemplate because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "get": {
        "operationId": "ReadLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadLinkTemplateResponse"
            }
          },
          "404": {
            "description": "Cannot read the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "put": {
        "operationId": "UpdateLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateLinkTemplateBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot update the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/log-control-config": {
      "delete": {
        "operationId": "DeleteLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogControlConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogControlConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadLogControlConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogControlConfig because there is a conflict with an existing LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      }
    },
    "/api/unstable/config/noop-entities": {
      "post": {
        "operationId": "CreateNoopEntity",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot create the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/noop-entities/{slug}": {
      "delete": {
        "operationId": "DeleteNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NoopEntity because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "get": {
        "operationId": "ReadNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadNoopEntityResponse"
            }
          },
          "404": {
            "description": "Cannot read the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "put": {
        "operationId": "UpdateNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateNoopEntityBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot update the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/object-discovery-rules": {
      "get": {
        "operationId": "ListObjectDiscoveryRule",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListObjectDiscoveryRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "post": {
        "operationId": "CreateObjectDiscoveryRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateObjectDiscoveryRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the ObjectDiscoveryRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ObjectDiscoveryRule because there is a conflict with an existing ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      }
    },
    "/api/unstable/config/object-discovery-rules/{slug}": {
      "delete": {
        "operationId": "DeleteObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ObjectDiscoveryRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "get": {
        "operationId": "ReadObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadObjectDiscoveryRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "put": {
        "operationId": "UpdateObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateObjectDiscoveryRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the ObjectDiscoveryRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the ObjectDiscoveryRule because there is a conflict with an existing ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches": {
      "get": {
        "operationId": "ListSavedTraceSearches",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SavedTraceSearch with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SavedTraceSearch with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional filter: creator email address.",
            "in": "query",
            "name": "created_by",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListSavedTraceSearchesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "post": {
        "description": "***\nSaved Trace Searches\n***",
        "operationId": "CreateSavedTraceSearch",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot create the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches/{slug}": {
      "delete": {
        "operationId": "DeleteSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SavedTraceSearch because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "get": {
        "operationId": "ReadSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadSavedTraceSearchResponse"
            }
          },
          "404": {
            "description": "Cannot read the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "put": {
        "operationId": "UpdateSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateSavedTraceSearchBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot update the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Service with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Service with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get services that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "post": {
        "operationId": "CreateService",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Service.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot create the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/services/{slug}": {
      "delete": {
        "operationId": "DeleteService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteServiceResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Service because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "put": {
        "operationId": "UpdateService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateServiceBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Service.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot update the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/sync-prometheus": {
      "post": {
        "description": "***\nSync Prometheus Configuration\n***",
        "operationId": "SyncPrometheus",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "SyncPrometheus"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    },
    "/api/unstable/config/trace-top-tag-config": {
      "delete": {
        "operationId": "DeleteTraceTopTagConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTopTagConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTopTagConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceTopTagConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceTopTagConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTopTagConfig because TraceTopTagConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceTopTagConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTopTagConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTopTagConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTopTagConfig because there is a conflict with an existing TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTopTagConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTopTagConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTopTagConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTopTagConfig because TraceTopTagConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigUnstable"
    }
  ]
}