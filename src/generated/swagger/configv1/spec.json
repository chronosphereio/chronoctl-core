{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "AllocationFixedValue": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "value": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThreshold": {
      "properties": {
        "percent_of_pool_allocation": {
          "description": "Threshold expressed as a percent of the license allocated to a pool.\nA value of `100` represents a threshold that is the pool's full allocation.\nValues over `100` indicate thresholds that exceed the pool's allocation.\nFor example, a value of `50` represents a threshold that is half the pool's\nallocation and a value of `200` represents a threshold that is double the\npool's allocation.",
          "format": "double",
          "type": "number"
        },
        "fixed_value": {
          "description": "Threshold expressed as a fixed value of the license.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThresholds": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "all_priorities": {
          "$ref": "#/definitions/AllocationThreshold"
        },
        "default_and_low_priority": {
          "$ref": "#/definitions/AllocationThreshold"
        },
        "low_priority": {
          "$ref": "#/definitions/AllocationThreshold"
        }
      },
      "title": "Thresholds define strict quota limits for each metrics license.\n**This feature is part of pre-release functionality and is subject to change.**",
      "type": "object"
    },
    "ConditionOp": {
      "enum": [
        "GEQ",
        "GT",
        "LEQ",
        "LT",
        "EQ",
        "NEQ",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "ConfigV1UpdateBucketBody": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "create_if_missing": {
          "description": "If true, the Bucket will be created if it does not already exist, identified by slug. If false, an error will be returned if the Bucket does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Bucket will not be created nor updated, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateClassicDashboardBody": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If true, the GrafanaDashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created nor updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateCollectionBody": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "create_if_missing": {
          "description": "If true, the Collection will be created if it does not already exist, identified by slug. If false, an error will be returned if the Collection does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Collection will not be created nor updated, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDashboardBody": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "create_if_missing": {
          "description": "If true, the Dashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Dashboard will not be created nor updated, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDatasetBody": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "create_if_missing": {
          "description": "If true, the Dataset will be created if it does not already exist, identified by slug. If false, an error will be returned if the Dataset does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Dataset will not be created nor updated, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedLabelBody": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "create_if_missing": {
          "description": "If true, the DerivedLabel will be created if it does not already exist, identified by slug. If false, an error will be returned if the DerivedLabel does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the DerivedLabel will not be created nor updated, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedMetricBody": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "create_if_missing": {
          "description": "If true, the DerivedMetric will be created if it does not already exist, identified by slug. If false, an error will be returned if the DerivedMetric does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the DerivedMetric will not be created nor updated, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDropRuleBody": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "create_if_missing": {
          "description": "If true, the DropRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the DropRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the DropRule will not be created nor updated, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGcpMetricsIntegrationBody": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "create_if_missing": {
          "description": "If true, the GcpMetricsIntegration will be created if it does not already exist, identified by slug. If false, an error will be returned if the GcpMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the GcpMetricsIntegration will not be created nor updated, and no response GcpMetricsIntegration will be returned. The response will return an error if the given GcpMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGrafanaDashboardBody": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If true, the GrafanaDashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created nor updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleActionBody": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "create_if_missing": {
          "description": "If true, the LogScaleAction will be created if it does not already exist, identified by slug. If false, an error will be returned if the LogScaleAction does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the LogScaleAction will not be created nor updated, and no response LogScaleAction will be returned. The response will return an error if the given LogScaleAction is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleAlertBody": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "create_if_missing": {
          "description": "If true, the LogScaleAlert will be created if it does not already exist, identified by slug. If false, an error will be returned if the LogScaleAlert does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the LogScaleAlert will not be created nor updated, and no response LogScaleAlert will be returned. The response will return an error if the given LogScaleAlert is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMappingRuleBody": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "create_if_missing": {
          "description": "If true, the MappingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the MappingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the MappingRule will not be created nor updated, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMonitorBody": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "create_if_missing": {
          "description": "If true, the Monitor will be created if it does not already exist, identified by slug. If false, an error will be returned if the Monitor does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Monitor will not be created nor updated, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMutingRuleBody": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "create_if_missing": {
          "description": "If true, the MutingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the MutingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the MutingRule will not be created nor updated, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotificationPolicyBody": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "create_if_missing": {
          "description": "If true, the NotificationPolicy will be created if it does not already exist, identified by slug. If false, an error will be returned if the NotificationPolicy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the NotificationPolicy will not be created nor updated, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotifierBody": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "create_if_missing": {
          "description": "If true, the Notifier will be created if it does not already exist, identified by slug. If false, an error will be returned if the Notifier does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Notifier will not be created nor updated, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRecordingRuleBody": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "create_if_missing": {
          "description": "If true, the RecordingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the RecordingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the RecordingRule will not be created nor updated, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRollupRuleBody": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "create_if_missing": {
          "description": "If true, the RollupRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the RollupRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the RollupRule will not be created nor updated, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTeamBody": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "create_if_missing": {
          "description": "If true, the Team will be created if it does not already exist, identified by slug. If false, an error will be returned if the Team does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the Team will not be created nor updated, and no response Team will be returned. The response will return an error if the given Team is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceBehaviorBody": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "create_if_missing": {
          "description": "If true, the TraceBehavior will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceBehavior does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceBehavior will not be created nor updated, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "create_if_missing": {
          "description": "If true, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created nor updated, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceMetricsRuleBody": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "create_if_missing": {
          "description": "If true, the TraceMetricsRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceMetricsRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceMetricsRule will not be created nor updated, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConstructedLabelValueDefinition": {
      "properties": {
        "value": {
          "type": "string"
        },
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DatasetDatasetConfiguration": {
      "properties": {
        "type": {
          "$ref": "#/definitions/DatasetDatasetType"
        },
        "trace_dataset": {
          "$ref": "#/definitions/configv1TraceDataset"
        },
        "log_dataset": {
          "$ref": "#/definitions/configv1LogDataset"
        }
      },
      "type": "object"
    },
    "DatasetDatasetType": {
      "enum": [
        "TRACES",
        "LOGS"
      ],
      "type": "string"
    },
    "DerivedLabelMetricLabel": {
      "properties": {
        "constructed_label": {
          "$ref": "#/definitions/MetricLabelConstructedLabel"
        },
        "mapping_label": {
          "$ref": "#/definitions/MetricLabelMappingLabel"
        }
      },
      "type": "object"
    },
    "DerivedMetricQuery": {
      "properties": {
        "prometheus_expr": {
          "description": "Required PromQL expression which the derived metric executes. Should\ninclude all configured variables.",
          "example": "cpu_usage{$service, $instance} / sum(cpu_usage{$service})",
          "type": "string"
        },
        "variables": {
          "description": "Optional variables which may be used in the derived metric as label\nselectors.",
          "items": {
            "$ref": "#/definitions/DerivedMetricVariable"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelector": {
      "properties": {
        "labels": {
          "description": "Labels which must match in the derived metric usage for the selector to\nmatch.",
          "items": {
            "$ref": "#/definitions/configv1DerivedMetricLabelMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelectorQuery": {
      "properties": {
        "selector": {
          "$ref": "#/definitions/DerivedMetricSelector"
        },
        "query": {
          "$ref": "#/definitions/DerivedMetricQuery"
        }
      },
      "type": "object"
    },
    "DerivedMetricVariable": {
      "properties": {
        "name": {
          "description": "Required name of the variable.",
          "example": "service",
          "type": "string"
        },
        "default_prometheus_selector": {
          "description": "Required PromQL label selector which must match the given variable name.\nIf the variable is not specified in the derived metric usage, then this\ndefault selector is used.",
          "example": "service=~\".*\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DropRuleConditionalRateBasedDrop": {
      "description": "No longer supported and cannot be used.\nDefines behavior for conditional drop policies.",
      "properties": {
        "enabled": {
          "description": "Enables rate-based metric dropping.",
          "type": "boolean"
        },
        "rate_limit_threshold": {
          "description": "Percentage of the licensed limit reached in order to activate the drop\nrule, between 0 and 100.",
          "format": "double",
          "type": "number"
        },
        "activated_drop_duration_secs": {
          "description": "Once activated, activated_drop_duration_secs defines how long the drop\nrule stays activated before rechecking against the rate_limit_threshold.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DropRuleValueBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables value-based metric dropping.",
          "type": "boolean"
        },
        "target_drop_value": {
          "description": "The target datapoint value at which to drop metrics.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "GcpMetricsIntegrationMetricGroup": {
      "properties": {
        "project_id": {
          "description": "Project ID that has access to the metric data.",
          "type": "string"
        },
        "prefixes": {
          "description": "List of Gcp metric prefixes to ingest.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "GraphiteLabelPolicyReplace": {
      "properties": {
        "name": {
          "description": "Required name of the label whose value should be replaced. Only\n`__gX__` labels are allowed (aka positional Graphite labels).",
          "example": "__g1__",
          "type": "string"
        },
        "new_value": {
          "description": "Required new value of the replaced label.",
          "example": "ALL_HOSTS",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByGroupByKey": {
      "description": "GroupByKey describes a key to group by.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GroupByKeyGroupByKeyType"
        },
        "named_key": {
          "description": "For named KeyTypes (e.g. span tags), the name of the key to group by.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByKeyGroupByKeyType": {
      "description": " - SERVICE: Group by service.\n - OPERATION: Group by operation.\n - TAG: Group by span tag.",
      "enum": [
        "SERVICE",
        "OPERATION",
        "TAG"
      ],
      "type": "string"
    },
    "HTTPConfigBasicAuth": {
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "HTTPConfigTLSConfig": {
      "properties": {
        "insecure_skip_verify": {
          "description": "Disables validation of the server certificate.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ListMutingRulesRequestState": {
      "enum": [
        "PENDING",
        "ACTIVE",
        "EXPIRED"
      ],
      "type": "string"
    },
    "LogAllocationConfigDatasetAllocation": {
      "properties": {
        "dataset_slug": {
          "description": "Slug of the dataset.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDefaultDataset": {
      "description": "Configuration for default dataset.",
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigHighLowPriorities": {
      "description": "HighLowPriorities defines explicit high and low priority match criteria to define which logs\nshould be dropped first (low) and dropped last (high). Anything not matched by either set of rules\nis considered default priority and thus dropped after low but before high.",
      "properties": {
        "high_priority_filters": {
          "description": "A list of search filters defining which logs are considered high priority in this dataset.\nThe filters are ORed together so only one given filter needs to match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "A list of search filters defining which logs are considered low priority in this dataset.\nThe filters are ORed together so only one given filter needs to match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogScaleActionActionType": {
      "enum": [
        "EMAIL",
        "HUMIO_REPO",
        "OPS_GENIE",
        "PAGER_DUTY",
        "SLACK",
        "SLACK_POST_MESSAGE",
        "VICTOR_OPS",
        "WEBHOOK",
        "UPLOAD_FILE"
      ],
      "type": "string"
    },
    "LogScaleActionEmailAction": {
      "properties": {
        "recipients": {
          "description": "List of email addresses to send an email to.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject_template": {
          "description": "Subject of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "body_template": {
          "description": "Body of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "attach_csv": {
          "description": "Whether the result set should be attached as a CSV file.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionHumioRepoAction": {
      "properties": {
        "ingest_token": {
          "description": "Ingest token for the repository that the action should ingest into.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionOpsGenieAction": {
      "properties": {
        "api_url": {
          "description": "OpsGenie webhook URL to send the request to.",
          "type": "string"
        },
        "ops_genie_key": {
          "description": "Key to authenticate with OpsGenie.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionPagerDutyAction": {
      "properties": {
        "severity": {
          "$ref": "#/definitions/PagerDutyActionSeverity"
        },
        "routing_key": {
          "description": "Routing key to authenticate with PagerDuty.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackAction": {
      "properties": {
        "url": {
          "description": "Slack webhook URL to send the request to.",
          "type": "string"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackPostMessageAction": {
      "properties": {
        "api_token": {
          "description": "API token to authenticate with Slack.",
          "type": "string"
        },
        "channels": {
          "description": "List of Slack channels to message.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionUploadFileAction": {
      "properties": {
        "file_name": {
          "description": "File name for the uploaded file.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionVictorOpsAction": {
      "properties": {
        "message_type": {
          "description": "Type of the VictorOps message to make.",
          "type": "string"
        },
        "notify_url": {
          "description": "VictorOps webhook URL to send the request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionWebhookAction": {
      "properties": {
        "method": {
          "$ref": "#/definitions/WebhookActionHTTPMethod"
        },
        "url": {
          "description": "URL to send the HTTP or HTTPS request to.",
          "type": "string"
        },
        "headers": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers of the HTTP or HTTPS request.",
          "type": "object"
        },
        "body_template": {
          "description": "Body of the HTTP or HTTPS request. Can be templated with values from the query result.",
          "type": "string"
        },
        "ignore_ssl": {
          "description": "Flag indicating whether SSL should be ignored for the request.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleAlertAlertType": {
      "enum": [
        "STANDARD",
        "FILTER"
      ],
      "type": "string"
    },
    "MappingLabelNameMapping": {
      "properties": {
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "source_label": {
          "description": "The actual label ingested on the time series",
          "type": "string"
        },
        "value_mappings": {
          "description": "These value mappings apply to just the name mapping they belong to.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MappingLabelValueMapping": {
      "properties": {
        "source_value_globs": {
          "description": "Defines the source label values that should be mapped into the given target_value.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_value": {
          "description": "The value that source_value_globs are mapped into.\nFor example, given this mapping:\n```yaml\nvalue_mappings:\n - source_value_globs:\n     - Cat\n     - CAT\n   target_value: cat\n```\nThis indicates that the target value `cat` maps to the source label's values `Cat` and `CAT`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingRuleAggregationPolicy": {
      "properties": {
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1MappingRuleStoragePolicy"
        },
        "interval": {
          "description": "Interval between aggregated data points, equivalent to the resolution\nfield in storage policy. If set, then the storage_policy field can't be\nset.",
          "type": "string"
        },
        "drop_timestamp": {
          "description": "Deprecated: This field is no longer supported.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MetricLabelConstructedLabel": {
      "properties": {
        "value_definitions": {
          "items": {
            "$ref": "#/definitions/ConstructedLabelValueDefinition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabel": {
      "properties": {
        "name_mappings": {
          "items": {
            "$ref": "#/definitions/MappingLabelNameMapping"
          },
          "type": "array"
        },
        "value_mappings": {
          "description": "These value mappings apply to the whole mapping label.\nIf there's no name_mappings, these value mappings apply to the label that exists on the metric.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricsRestrictionPermission": {
      "enum": [
        "READ",
        "WRITE",
        "READ_WRITE"
      ],
      "type": "string"
    },
    "MonitorCondition": {
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "The value to compare to the metric value using the op operation.",
          "format": "double",
          "type": "number"
        },
        "sustain_secs": {
          "description": "Time op operation must evaluate to true for the condition to evaluate to true.",
          "format": "int32",
          "type": "integer"
        },
        "resolve_sustain_secs": {
          "description": "Time op operation must evaluate as false for an active alert, before that alert resolves.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "MonitorSchedule": {
      "properties": {
        "timezone": {
          "description": "The timezone of the time ranges.",
          "type": "string"
        },
        "weekly_schedule": {
          "$ref": "#/definitions/ScheduleWeeklySchedule"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditions": {
      "description": "Conditions evaluated against each queried series to determine the severity of each series.",
      "properties": {
        "defaults": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        },
        "overrides": {
          "description": "Optional list of overrides to use for series having matching labels.\nEach override defines labels that potentially match a series' labels.\nIf one or more overrides match a series, the severity conditions of the first matching\noverride are used instead of the defaults.\n\nCannot be used if graphite_query is set.",
          "items": {
            "$ref": "#/definitions/MonitorSeriesConditionsOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditionsOverride": {
      "properties": {
        "label_matchers": {
          "description": "Set of matchers on a series' labels.\nIf all labels match then the conditions defined in this override are used.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "severity_conditions": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        }
      },
      "type": "object"
    },
    "MonitorSignalGrouping": {
      "description": "SignalGrouping defines how the set of series from the query are split into signals.",
      "properties": {
        "label_names": {
          "description": "Set of labels names used to split series into signals.\nEach unique combination of labels will result in its own signal.\nFor example, if label_names is [\"service\", \"code\"] then all series including labels {service=\"foo\",code=\"404\"}\nwill be grouped together in the same signal.\n\nCannot be used if graphite_query is set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "signal_per_series": {
          "description": "If this is true, each series will have its own signal.\nIf this is true then label_names cannot be set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutes": {
      "properties": {
        "defaults": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        },
        "overrides": {
          "description": "Optional list of overrides to use for alerts having matching labels.\nEach override defines labels that potentially match an alert's labels.\nIf one or more overrides match an alert, the notifiers of the first matching\noverride are used instead of the defaults.",
          "items": {
            "$ref": "#/definitions/NotificationPolicyRoutesOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesGroupBy": {
      "properties": {
        "label_names": {
          "description": "Set of label names used to group alerts.\nFor example, if label_names is [\"service\", \"code\"] then all alerts including labels {service=\"foo\",code=\"404\"}\nwill be grouped together.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesOverride": {
      "properties": {
        "alert_label_matchers": {
          "description": "Set of matchers on an alert's labels.\nIf all labels match then the override notifiers apply.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "notifiers": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        }
      },
      "type": "object"
    },
    "NotifierEmailConfig": {
      "properties": {
        "to": {
          "description": "Required email address to send notifications to.",
          "type": "string"
        },
        "html": {
          "description": "Optional HTML body of the email.",
          "type": "string"
        },
        "text": {
          "description": "Optional text body of the email.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierHTTPConfig": {
      "properties": {
        "basic_auth": {
          "$ref": "#/definitions/HTTPConfigBasicAuth"
        },
        "bearer_token": {
          "description": "Bearer token authentication. Cannot be set if basic_auth is set.",
          "type": "string"
        },
        "proxy_url": {
          "description": "Optional proxy URL.\nDEPRECATED: Custom proxies are unsupported.",
          "type": "string"
        },
        "tls_config": {
          "$ref": "#/definitions/HTTPConfigTLSConfig"
        }
      },
      "type": "object"
    },
    "NotifierOpsGenieConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required OpsGenie API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required OpsGenie API URL to send requests to, e.g.\n\"https://api.opsgenie.com/\".",
          "type": "string"
        },
        "message": {
          "description": "Alert text.",
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "source": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of arbitrary key/value pairs that provide further detail about the\nalert.",
          "type": "object"
        },
        "responders": {
          "description": "List of responders responsible for notifications.",
          "items": {
            "$ref": "#/definitions/OpsGenieConfigResponder"
          },
          "type": "array"
        },
        "tags": {
          "description": "Comma separated list of tags attached to the notifications.",
          "type": "string"
        },
        "note": {
          "description": "Additional alert note.",
          "type": "string"
        },
        "priority": {
          "description": "Priority level of alert. Possible values are P1, P2, P3, P4, and P5.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierPagerdutyConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "The Pagerduty URL to send API requests to.",
          "type": "string"
        },
        "client": {
          "description": "Client identification of the notification sender.",
          "type": "string"
        },
        "client_url": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "description": {
          "description": "Description of the incident.",
          "type": "string"
        },
        "severity": {
          "description": "Severity of the incident.\nValid values are 'critical', 'error', 'warning', 'info', or blank",
          "type": "string"
        },
        "class": {
          "description": "The class/type of the event.",
          "type": "string"
        },
        "component": {
          "description": "The part or component of the affected system which is broken.",
          "type": "string"
        },
        "group": {
          "description": "A cluster or grouping of services.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set of arbitrary key/value pairs which provide further detail about the\nincident.",
          "type": "object"
        },
        "images": {
          "description": "Images to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigImage"
          },
          "type": "array"
        },
        "links": {
          "description": "Links to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigLink"
          },
          "type": "array"
        },
        "service_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Prometheus\"). Cannot be set if routing_key is set.",
          "type": "string"
        },
        "routing_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Events API v2\"). Cannot be set if service_key is set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_url": {
          "description": "Required Slack webhook API URL.",
          "type": "string"
        },
        "channel": {
          "description": "The channel to send notifications to.",
          "type": "string"
        },
        "username": {
          "description": "The user to send notifications to.",
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "title_link": {
          "type": "string"
        },
        "pretext": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "footer": {
          "type": "string"
        },
        "fallback": {
          "type": "string"
        },
        "callback_id": {
          "type": "string"
        },
        "icon_emoji": {
          "type": "string"
        },
        "icon_url": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "thumb_url": {
          "type": "string"
        },
        "short_fields": {
          "type": "boolean"
        },
        "link_names": {
          "type": "boolean"
        },
        "mrkdwn_in": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "items": {
            "$ref": "#/definitions/SlackConfigField"
          },
          "type": "array"
        },
        "actions": {
          "items": {
            "$ref": "#/definitions/NotifierSlackConfigAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfigAction": {
      "properties": {
        "type": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "style": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "confirm_field": {
          "$ref": "#/definitions/SlackConfigConfirmationField"
        }
      },
      "type": "object"
    },
    "NotifierVictorOpsConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required VictorOps API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required VictorOps API URL.",
          "type": "string"
        },
        "routing_key": {
          "description": "Required VictorOps routing key.",
          "type": "string"
        },
        "message_type": {
          "description": "Describes the behavior of the alert (CRITICAL, WARNING, INFO).",
          "type": "string"
        },
        "entity_display_name": {
          "description": "Summary of the alerted problem.",
          "type": "string"
        },
        "state_message": {
          "description": "Long explanation of the alerted problem.",
          "type": "string"
        },
        "monitoring_tool": {
          "description": "The monitoring tool the state message is from.",
          "type": "string"
        },
        "custom_fields": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "NotifierWebhookConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "Required webhook URL (will be called as a POST request).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OpsGenieConfigResponder": {
      "properties": {
        "id": {
          "description": "ID of the responder. Cannot be set if name or username are set.",
          "type": "string"
        },
        "name": {
          "description": "Name of the responder. Cannot be set if id or username are set.",
          "type": "string"
        },
        "username": {
          "description": "Username of the responder. Cannot be set if id or name are set.",
          "type": "string"
        },
        "responder_type": {
          "$ref": "#/definitions/ResponderResponderType"
        }
      },
      "type": "object"
    },
    "OtelMetricsIngestionResourceAttributes": {
      "properties": {
        "flatten_mode": {
          "$ref": "#/definitions/ResourceAttributesFlattenMode"
        },
        "filter_mode": {
          "$ref": "#/definitions/ResourceAttributesFilterMode"
        },
        "exclude_keys": {
          "description": "Do not copy any resource attribute whose key exactly matches one of the\nstrings in this list.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "generate_target_info": {
          "description": "Generate a target_info time series with labels derived from resource\nattributes. The filter_mode and exclude_keys settings apply in the same way as\nfor the \"flatten\" operation. The default is false.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PagerDutyActionSeverity": {
      "enum": [
        "CRITICAL",
        "ERROR",
        "WARNING",
        "INFO"
      ],
      "type": "string"
    },
    "PagerdutyConfigImage": {
      "properties": {
        "src": {
          "type": "string"
        },
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigLink": {
      "properties": {
        "href": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy should apply.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "ResourceAttributesFilterMode": {
      "enum": [
        "APPEND_DEFAULT_EXCLUDE_KEYS",
        "CUSTOM_EXCLUDE_KEYS"
      ],
      "type": "string"
    },
    "ResourceAttributesFlattenMode": {
      "enum": [
        "MERGE",
        "OVERWRITE",
        "IGNORE"
      ],
      "type": "string"
    },
    "ResourceChange": {
      "properties": {
        "resource": {
          "$ref": "#/definitions/configv1ResourceType"
        },
        "slug": {
          "type": "string"
        },
        "action": {
          "$ref": "#/definitions/ResourceChangeAction"
        }
      },
      "type": "object"
    },
    "ResourceChangeAction": {
      "enum": [
        "CREATED",
        "UPDATED",
        "DELETED",
        "NOOP"
      ],
      "type": "string"
    },
    "ResourcePoolsDefaultPool": {
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Currently, only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResourcePoolsLicense": {
      "enum": [
        "PERSISTED_WRITES_STANDARD",
        "PERSISTED_WRITES_HISTOGRAM",
        "PERSISTED_CARDINALITY_STANDARD",
        "PERSISTED_CARDINALITY_HISTOGRAM",
        "MATCHED_WRITES_STANDARD",
        "MATCHED_WRITES_HISTOGRAM"
      ],
      "type": "string"
    },
    "ResourcePoolsPool": {
      "properties": {
        "name": {
          "description": "Required name of the pool. Must be unique.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "filters": {
          "description": "Required filters which define which metrics map to this pool, where any\nmetric which matches at least one filter will map to the pool.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        }
      },
      "type": "object"
    },
    "ResourcePoolsPriorities": {
      "properties": {
        "high_priority_filters": {
          "description": "Required filters which define which metrics are high priority, where any\nmetric which matches at least one filter is considered high priority.\nHigh priority metrics are dropped last when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "Required filters which define which metrics are low priority, where any\nmetric which matches at least one filter is considered low priority. Low\npriority metrics are dropped first when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResponderResponderType": {
      "enum": [
        "TEAM",
        "USER",
        "ESCALATION",
        "SCHEDULE"
      ],
      "type": "string"
    },
    "RollupRuleGraphiteLabelPolicy": {
      "properties": {
        "replace": {
          "description": "Required list of labels to replace. Useful for discarding\nhigh-cardinality values while still preserving the original positions of\nthe Graphite metric.",
          "items": {
            "$ref": "#/definitions/GraphiteLabelPolicyReplace"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RollupRuleLabelReplace": {
      "description": "Must keep this around for backwards compatibility because terraform will\nstill send this key w/ a null value.",
      "type": "object"
    },
    "RollupRuleMetricType": {
      "description": " - CUMULATIVE_COUNTER: Alias of COUNTER.\n - DELTA_COUNTER: Alias of DELTA.",
      "enum": [
        "COUNTER",
        "GAUGE",
        "DELTA",
        "DISTRIBUTION",
        "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
        "MEASUREMENT",
        "CUMULATIVE_COUNTER",
        "DELTA_COUNTER",
        "DELTA_EXPONENTIAL_HISTOGRAM"
      ],
      "type": "string"
    },
    "RoutesNotifierList": {
      "properties": {
        "notifier_slugs": {
          "description": "Slugs of notifiers that will receive the alerts.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "repeat_interval_secs": {
          "description": "Frequency at which to resend alerts.",
          "format": "int32",
          "type": "integer"
        },
        "group_by": {
          "$ref": "#/definitions/NotificationPolicyRoutesGroupBy"
        }
      },
      "type": "object"
    },
    "RoutesSeverityNotifiers": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/RoutesNotifierList"
        },
        "critical": {
          "$ref": "#/definitions/RoutesNotifierList"
        }
      },
      "type": "object"
    },
    "ScheduleDayActive": {
      "enum": [
        "ALL_DAY",
        "ONLY_DURING_RANGES",
        "NEVER"
      ],
      "type": "string"
    },
    "ScheduleDayTimeRange": {
      "properties": {
        "start_hh_mm": {
          "description": "Start time in the in format \"\u003chour\u003e:\u003cminute\u003e\", e.g. \"15:30\".",
          "type": "string"
        },
        "end_hh_mm": {
          "description": "End time in the in format \"\u003chour\u003e:\u003cminute\u003e\", e.g. \"15:30\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScheduleScheduleDay": {
      "properties": {
        "active": {
          "$ref": "#/definitions/ScheduleDayActive"
        },
        "ranges": {
          "description": "The time ranges that the monitor is active on this day. Required if\nactive is set to ONLY_DURING_RANGES, else must be empty.",
          "items": {
            "$ref": "#/definitions/ScheduleDayTimeRange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ScheduleWeeklySchedule": {
      "properties": {
        "monday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "tuesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "wednesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "thursday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "friday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "saturday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "sunday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        }
      },
      "type": "object"
    },
    "SeriesConditionsConditions": {
      "properties": {
        "conditions": {
          "description": "List of conditions to evaluate against a series.\nOnly one condition -- not all -- needs to match in order to assign a severity to a signal.",
          "items": {
            "$ref": "#/definitions/MonitorCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SeriesConditionsSeverityConditions": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        },
        "critical": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        }
      },
      "type": "object"
    },
    "ServiceAccountMetricsRestriction": {
      "properties": {
        "permission": {
          "$ref": "#/definitions/MetricsRestrictionPermission"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels which further restricts the service account to only read\nor write metrics with the given label names and values.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SlackConfigConfirmationField": {
      "properties": {
        "text": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "ok_text": {
          "type": "string"
        },
        "dismiss_text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SlackConfigField": {
      "properties": {
        "title": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "short": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "TraceBehaviorConfigMainBehaviorAssignment": {
      "properties": {
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a TraceDataset",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a TraceBehavior",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the entry.",
          "type": "string"
        },
        "description": {
          "description": "A description of the entry.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigOverrideBehaviorAssignment": {
      "properties": {
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a TraceDataset",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a TraceBehavior",
          "type": "string"
        },
        "start_time": {
          "description": "The starting time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "end_time": {
          "description": "The ending time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the entry.",
          "type": "string"
        },
        "description": {
          "description": "A description of the entry.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorErrorSampleOptions": {
      "properties": {
        "sample_rate": {
          "description": "Sample rate for traces with errors.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Whether or not to use these options.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorFastSampleOptions": {
      "properties": {
        "max_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled\naccording to the given sample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Sample rate for traces under the given duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Whether or not to use these options.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorLargeTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "For N = number of spans in the trace, if N \u003e= span_count_threshold, the trace is sampled according to the\ngiven sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Sample rate.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Whether or not to use these options.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSamplingType": {
      "description": " - LOW_VALUE: Match indicates a low value trace. With multiple low value matches sample at the lowest rate.\n - HIGH_VALUE: Match indicates a high value trace. With multiple high value matches sample at the highest rate.",
      "enum": [
        "LOW_VALUE",
        "HIGH_VALUE"
      ],
      "type": "string"
    },
    "TraceBehaviorSlowSampleOptions": {
      "properties": {
        "min_duration_seconds": {
          "description": "Duration in seconds over which traces are sampled\naccording to the given sample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Sample rate.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Whether or not to use these options.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSmallTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "For N = number of spans in the trace, if N \u003c= span_count_threshold, the trace is sampled according to the\ngiven sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Sample rate.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Whether or not to use these options.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range [0, 1]) when specific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the default sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range [0, 1] that defines the probability of sampling any trace.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        },
        "is_root_span": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "string"
        },
        "in_values": {
          "description": "Values the filter tests against when using IN or NOT_IN match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key (or name) of the span tag that is inspected by this filter.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "WebhookActionHTTPMethod": {
      "enum": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "HEAD",
        "OPTIONS"
      ],
      "type": "string"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1AggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX",
        "MEAN",
        "MEDIAN",
        "COUNT",
        "SUM",
        "SUMSQ",
        "STDEV",
        "P10",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "P90",
        "P95",
        "P99",
        "P999",
        "P9999",
        "P25",
        "P75",
        "COUNT_SAMPLES",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "configv1Bucket": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Bucket. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Bucket is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Bucket. May be modified after the Bucket is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Bucket was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Bucket was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional description of the bucket.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels marking the bucket.",
          "type": "object"
        },
        "team_slug": {
          "description": "Optional slug of the team the bucket belongs to.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this bucket.\nThis is optional if the bucket does not contain monitors or all of its monitors explicitly reference a policy.\nThis policy takes precedence over a bucket-owned notification policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Collection": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Collection. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Collection is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Collection. May be modified after the Collection is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Collection was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Collection was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReference": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1CollectionReferenceType"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReferenceType": {
      "description": "Type values must match entitiespb.Collection.CollectionType.",
      "enum": [
        "SIMPLE",
        "SERVICE"
      ],
      "type": "string"
    },
    "configv1CreateBucketRequest": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "dry_run": {
          "description": "If true, the Bucket will not be created, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardRequest": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionRequest": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "dry_run": {
          "description": "If true, the Collection will not be created, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "dry_run": {
          "description": "If true, the Dashboard will not be created, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetRequest": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "dry_run": {
          "description": "If true, the Dataset will not be created, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelRequest": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "dry_run": {
          "description": "If true, the DerivedLabel will not be created, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricRequest": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "dry_run": {
          "description": "If true, the DerivedMetric will not be created, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleRequest": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "dry_run": {
          "description": "If true, the DropRule will not be created, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationRequest": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "dry_run": {
          "description": "If true, the GcpMetricsIntegration will not be created, and no response GcpMetricsIntegration will be returned. The response will return an error if the given GcpMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardRequest": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "dry_run": {
          "description": "If true, the LogAllocationConfig will not be created, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionRequest": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "dry_run": {
          "description": "If true, the LogScaleAction will not be created, and no response LogScaleAction will be returned. The response will return an error if the given LogScaleAction is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertRequest": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "dry_run": {
          "description": "If true, the LogScaleAlert will not be created, and no response LogScaleAlert will be returned. The response will return an error if the given LogScaleAlert is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleRequest": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "dry_run": {
          "description": "If true, the MappingRule will not be created, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorRequest": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "dry_run": {
          "description": "If true, the Monitor will not be created, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleRequest": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "dry_run": {
          "description": "If true, the MutingRule will not be created, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyRequest": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "dry_run": {
          "description": "If true, the NotificationPolicy will not be created, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierRequest": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "dry_run": {
          "description": "If true, the Notifier will not be created, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "dry_run": {
          "description": "If true, the OtelMetricsIngestion will not be created, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleRequest": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "dry_run": {
          "description": "If true, the RecordingRule will not be created, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "dry_run": {
          "description": "If true, the ResourcePools will not be created, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleRequest": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "dry_run": {
          "description": "If true, the RollupRule will not be created, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountRequest": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        },
        "dry_run": {
          "description": "If true, the ServiceAccount will not be created, and no response ServiceAccount will be returned. The response will return an error if the given ServiceAccount is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamRequest": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "dry_run": {
          "description": "If true, the Team will not be created, and no response Team will be returned. The response will return an error if the given Team is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "dry_run": {
          "description": "If true, the TraceBehaviorConfig will not be created, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorRequest": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "dry_run": {
          "description": "If true, the TraceBehavior will not be created, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleRequest": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "dry_run": {
          "description": "If true, the TraceMetricsRule will not be created, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1Dashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Dashboard. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Dashboard. May be modified after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Optional slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the dashboard.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1Dataset": {
      "properties": {
        "name": {
          "description": "Required name of the Dataset. May be modified after the Dataset is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the Dataset. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Dataset is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dataset was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dataset was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional longer-form description of the dataset.",
          "type": "string"
        },
        "configuration": {
          "$ref": "#/definitions/DatasetDatasetConfiguration"
        }
      },
      "type": "object"
    },
    "configv1DefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Whether to override the default sample rate",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1DeleteBucketResponse": {
      "properties": {
        "changes": {
          "description": "Changes contains what resources are deleted. The bucket being deleted will\nalways be included. When force_delete is used, the changelog will include\nall resources that reference the bucket that were deleted.",
          "items": {
            "$ref": "#/definitions/ResourceChange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DeleteClassicDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteCollectionResponse": {
      "type": "object"
    },
    "configv1DeleteDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteDatasetResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedLabelResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedMetricResponse": {
      "type": "object"
    },
    "configv1DeleteDropRuleResponse": {
      "type": "object"
    },
    "configv1DeleteGcpMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteGrafanaDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteLogAllocationConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleActionResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleAlertResponse": {
      "type": "object"
    },
    "configv1DeleteMappingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteMonitorResponse": {
      "type": "object"
    },
    "configv1DeleteMutingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteNotificationPolicyResponse": {
      "type": "object"
    },
    "configv1DeleteNotifierResponse": {
      "type": "object"
    },
    "configv1DeleteOtelMetricsIngestionResponse": {
      "type": "object"
    },
    "configv1DeleteRecordingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteResourcePoolsResponse": {
      "type": "object"
    },
    "configv1DeleteRollupRuleResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAccountResponse": {
      "type": "object"
    },
    "configv1DeleteTeamResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorConfigResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorResponse": {
      "type": "object"
    },
    "configv1DeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configv1DeleteTraceMetricsRuleResponse": {
      "type": "object"
    },
    "configv1DeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configv1DerivedLabel": {
      "properties": {
        "name": {
          "description": "Required name of the DerivedLabel. May be modified after the DerivedLabel is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedLabel. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DerivedLabel is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedLabel was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedLabel was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_name": {
          "description": "Name of the derived label. It needs to be unique across the system.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived label.",
          "type": "string"
        },
        "metric_label": {
          "$ref": "#/definitions/DerivedLabelMetricLabel"
        },
        "existing_label_policy": {
          "$ref": "#/definitions/configv1DerivedLabelLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1DerivedLabelLabelPolicy": {
      "enum": [
        "KEEP",
        "OVERRIDE"
      ],
      "type": "string"
    },
    "configv1DerivedMetric": {
      "properties": {
        "name": {
          "description": "Required name of the DerivedMetric. May be modified after the DerivedMetric is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedMetric. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DerivedMetric is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedMetric was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedMetric was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "Required metric name of the derived metric, which must be unique across the system.",
          "example": "cpu_usage:instance",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived metric.",
          "type": "string"
        },
        "queries": {
          "description": "Required queries that the derived metric can map to.",
          "items": {
            "$ref": "#/definitions/DerivedMetricSelectorQuery"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1DerivedMetricLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcherMatcherType": {
      "enum": [
        "EXACT"
      ],
      "type": "string"
    },
    "configv1DropRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the DropRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DropRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the DropRule. May be modified after the DropRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DropRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DropRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/configv1DropRuleMode"
        },
        "filters": {
          "description": "Series that match this filter are dropped.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "conditional_rate_based_drop": {
          "$ref": "#/definitions/DropRuleConditionalRateBasedDrop"
        },
        "value_based_drop": {
          "$ref": "#/definitions/DropRuleValueBasedDrop"
        },
        "drop_nan_value": {
          "description": "Drops datapoints if datapoint values are NaN.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1DropRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "configv1GcpMetricsIntegration": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the GcpMetricsIntegration. If slug is not provided, one will be generated based of the name field. Cannot be modified after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the GcpMetricsIntegration. May be modified after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_account": {
          "$ref": "#/definitions/configv1GcpMetricsIntegrationServiceAccount"
        },
        "metric_groups": {
          "description": "Metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/GcpMetricsIntegrationMetricGroup"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1GcpMetricsIntegrationServiceAccount": {
      "properties": {
        "client_email": {
          "description": "Email address of the service account to impersonate.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1GrafanaDashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the GrafanaDashboard. If slug is not provided, one will be generated based of the name field. Cannot be modified after the GrafanaDashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the GrafanaDashboard. May be modified after the GrafanaDashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GrafanaDashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GrafanaDashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the dashboard belongs to. Required if collection_slug\nis not set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the dashboard belongs to. Required if bucket_slug\nis not set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the Grafana dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelFilter": {
      "properties": {
        "name": {
          "description": "Name of the label to match.",
          "example": "job",
          "type": "string"
        },
        "value_glob": {
          "description": "Glob value of the label to match.",
          "example": "myservice*",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1LabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX"
      ],
      "type": "string"
    },
    "configv1ListBucketsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "buckets": {
          "items": {
            "$ref": "#/definitions/configv1Bucket"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListClassicDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "classic_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListCollectionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "collections": {
          "items": {
            "$ref": "#/definitions/configv1Collection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configv1Dashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDatasetsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "datasets": {
          "items": {
            "$ref": "#/definitions/configv1Dataset"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedLabelsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_labels": {
          "items": {
            "$ref": "#/definitions/configv1DerivedLabel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedMetricsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_metrics": {
          "items": {
            "$ref": "#/definitions/configv1DerivedMetric"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDropRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "drop_rules": {
          "items": {
            "$ref": "#/definitions/configv1DropRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGcpMetricsIntegrationsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "gcp_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1GcpMetricsIntegration"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGrafanaDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "grafana_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleActionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_actions": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleAlertsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_alerts": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAlert"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMappingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "mapping_rules": {
          "items": {
            "$ref": "#/definitions/configv1MappingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMonitorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "monitors": {
          "items": {
            "$ref": "#/definitions/configv1Monitor"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMutingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "muting_rules": {
          "items": {
            "$ref": "#/definitions/configv1MutingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotificationPoliciesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notification_policies": {
          "items": {
            "$ref": "#/definitions/configv1NotificationPolicy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotifiersResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notifiers": {
          "items": {
            "$ref": "#/definitions/configv1Notifier"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRecordingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "recording_rules": {
          "items": {
            "$ref": "#/definitions/configv1RecordingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRollupRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "rollup_rules": {
          "items": {
            "$ref": "#/definitions/configv1RollupRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAccountsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_accounts": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTeamsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "teams": {
          "items": {
            "$ref": "#/definitions/configv1Team"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceBehaviorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_behaviors": {
          "items": {
            "$ref": "#/definitions/configv1TraceBehavior"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceMetricsRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_metrics_rules": {
          "description": "Found trace metrics rules.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfig": {
      "description": "LogAllocationConfig is a singleton configuration object that specifies the\nconfiguration for Log budget allocations.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogAllocationConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogAllocationConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_dataset": {
          "$ref": "#/definitions/LogAllocationConfigDefaultDataset"
        },
        "dataset_allocations": {
          "description": "Defines datasets and budget allocations. Datasets are evaluated in order.",
          "items": {
            "$ref": "#/definitions/LogAllocationConfigDatasetAllocation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfigAllocation": {
      "description": "Configuration for allocating resources to a dataset.",
      "properties": {
        "percent_of_license": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1LogDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1LogSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAction": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the LogScaleAction. If slug is not provided, one will be generated based of the name field. Cannot be modified after the LogScaleAction is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of the LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of an action.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAction was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAction was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "action_type": {
          "$ref": "#/definitions/LogScaleActionActionType"
        },
        "email_action": {
          "$ref": "#/definitions/LogScaleActionEmailAction"
        },
        "humio_action": {
          "$ref": "#/definitions/LogScaleActionHumioRepoAction"
        },
        "ops_genie_action": {
          "$ref": "#/definitions/LogScaleActionOpsGenieAction"
        },
        "pager_duty_action": {
          "$ref": "#/definitions/LogScaleActionPagerDutyAction"
        },
        "slack_action": {
          "$ref": "#/definitions/LogScaleActionSlackAction"
        },
        "slack_post_message_action": {
          "$ref": "#/definitions/LogScaleActionSlackPostMessageAction"
        },
        "victor_ops_action": {
          "$ref": "#/definitions/LogScaleActionVictorOpsAction"
        },
        "webhook_action": {
          "$ref": "#/definitions/LogScaleActionWebhookAction"
        },
        "upload_file_action": {
          "$ref": "#/definitions/LogScaleActionUploadFileAction"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAlert": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the LogScaleAlert. If slug is not provided, one will be generated based of the name field. Cannot be modified after the LogScaleAlert is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of the alert.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAlert was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAlert was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "disabled": {
          "description": "Flag indicating whether the alert is disabled.",
          "type": "boolean"
        },
        "log_scale_query": {
          "description": "LogScale query to execute.",
          "example": "level = ERROR | severity \u003e 3 | count(as=numErrors) | numErrors \u003e 500",
          "type": "string"
        },
        "time_window_secs": {
          "description": "Lookback window used for an alert's evaluation.\nIf this is set to 86400 seconds (24 hours), only the events from the last 24 hours will be considered when the alert query is run.",
          "example": "3600",
          "format": "int32",
          "type": "integer"
        },
        "throttle_secs": {
          "description": "Throttle time in seconds. The alert is triggered at most once per throttle period.",
          "format": "int32",
          "type": "integer"
        },
        "throttle_field": {
          "description": "Field to throttle on. Optional.",
          "type": "string"
        },
        "log_scale_action_slugs": {
          "description": "Slugs of LogScale actions that will receive the alerts. When the value is empty\nthis alert won't trigger. Optional.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tags": {
          "description": "Tags attached to the alert.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "run_as_user": {
          "description": "Email of the user that the alert runs on behalf of. Required.",
          "type": "string"
        },
        "alert_type": {
          "$ref": "#/definitions/LogScaleAlertAlertType"
        }
      },
      "type": "object"
    },
    "configv1LogSearchFilter": {
      "properties": {
        "query": {
          "description": "Matches logs which match this query.\nQuery may only include top level operations (no nested clauses).\nOnly one type of operator AND/OR is allowed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MappingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MappingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the MappingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the MappingRule. May be modified after the MappingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MappingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MappingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Required slug of the bucket the MappingRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Required filters that determine to which metrics to apply the rule.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "aggregation_policy": {
          "$ref": "#/definitions/MappingRuleAggregationPolicy"
        },
        "drop": {
          "description": "Whether to drop the given set of metrics. If set, then the aggregation\npolicy can't be set.",
          "type": "boolean"
        },
        "mode": {
          "$ref": "#/definitions/configv1MappingRuleMode"
        }
      },
      "type": "object"
    },
    "configv1MappingRuleMode": {
      "description": " - ENABLED: ENABLED rules are applied. Rules default to ENABLED.\n - PREVIEW: PREVIEW rules are not applied, but shaping impact stats\nfor them rule are recorded.",
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1MappingRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Monitor": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Monitor. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Monitor is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Monitor. May be modified after the Monitor is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Monitor was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Monitor was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the monitor belongs to. Required if collection_slug is\nnot set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the monitor belongs to. Required if bucket_slug is\nnot set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are visible in notifications generated by this monitor,\nand can be used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this monitor.\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "series_conditions": {
          "$ref": "#/definitions/MonitorSeriesConditions"
        },
        "notification_policy_slug": {
          "description": "Optional notification policy used to route alerts generated by the monitor.\nIf omitted, the notification policy is inherited from the monitor's bucket.",
          "type": "string"
        },
        "interval_secs": {
          "description": "Optional setting for configuring how often alerts are evaluated.\nIf this is not set, it will default to 60s.",
          "format": "int32",
          "type": "integer"
        },
        "prometheus_query": {
          "description": "PromQL query. If set, no other queries can be set.",
          "example": "up{job=\"prometheus\"} == 0",
          "type": "string"
        },
        "graphite_query": {
          "description": "Graphite query. If set, no other queries can be set.",
          "example": "sumSeries(stats.timers.*.mean_90)",
          "type": "string"
        },
        "schedule": {
          "$ref": "#/definitions/MonitorSchedule"
        },
        "logging_query": {
          "description": "Logging query. If set, no other queries can be set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MutingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the MutingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the MutingRule. May be modified after the MutingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MutingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MutingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_matchers": {
          "description": "Specify which series are silenced by the muting rule. Alerting series must\nmatch all muting rule matchers to be silenced.\nThis value cannot be updated. Updates must specify the original value.",
          "items": {
            "$ref": "#/definitions/configv1MutingRuleLabelMatcher"
          },
          "type": "array"
        },
        "starts_at": {
          "description": "Timestamp of when the muting rule becomes active.\nThis value cannot be updated. Updates must specify the original value.",
          "format": "date-time",
          "type": "string"
        },
        "ends_at": {
          "description": "Timestamp of when the muting rule stops being active.",
          "format": "date-time",
          "type": "string"
        },
        "comment": {
          "description": "Optional comment that explains why the muting rule was created.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1MutingRuleLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX",
        "NOT_EXACT",
        "NOT_REGEXP"
      ],
      "type": "string"
    },
    "configv1NotificationPolicy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the NotificationPolicy. If slug is not provided, one will be generated based of the name field. Cannot be modified after the NotificationPolicy is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the NotificationPolicy. May be modified after the NotificationPolicy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NotificationPolicy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NotificationPolicy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the notification policy belongs to. Required if\nteam_slug is not set.",
          "type": "string"
        },
        "team_slug": {
          "description": "Slug of the team the notification policy belongs to. Required if\nbucket_slug is not set.",
          "type": "string"
        },
        "routes": {
          "$ref": "#/definitions/NotificationPolicyRoutes"
        }
      },
      "type": "object"
    },
    "configv1Notifier": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Notifier. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Notifier is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Notifier. May be modified after the Notifier is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Notifier was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Notifier was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "skip_resolved": {
          "description": "If true, do not notify on resolved alerts. Cannot set if discard is set.",
          "type": "boolean"
        },
        "webhook": {
          "$ref": "#/definitions/NotifierWebhookConfig"
        },
        "slack": {
          "$ref": "#/definitions/NotifierSlackConfig"
        },
        "pagerduty": {
          "$ref": "#/definitions/NotifierPagerdutyConfig"
        },
        "email": {
          "$ref": "#/definitions/NotifierEmailConfig"
        },
        "ops_genie": {
          "$ref": "#/definitions/NotifierOpsGenieConfig"
        },
        "victor_ops": {
          "$ref": "#/definitions/NotifierVictorOpsConfig"
        },
        "discard": {
          "description": "If set, enables the \"discard\" integration which simply discards all\nnotifications. Cannot set if another integration is set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1OtelMetricsIngestion": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource_attributes": {
          "$ref": "#/definitions/OtelMetricsIngestionResourceAttributes"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1ReadClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1ReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1ReadDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1ReadGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1ReadMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1ReadMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1ReadNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1ReadOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1ReadRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1ReadRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configv1Service"
        }
      },
      "type": "object"
    },
    "configv1ReadTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1RecordingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RecordingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the RecordingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the RecordingRule. May be modified after the RecordingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RecordingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RecordingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Optional slug of the bucket the RecordingRule belongs to.",
          "type": "string"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RecordingRuleLabelPolicy"
        },
        "interval_secs": {
          "description": "Optional interval for evaluating the recording rule.",
          "format": "int32",
          "type": "integer"
        },
        "metric_name": {
          "description": "The name of the time series to use for output, which must be a valid\nmetric name.",
          "type": "string"
        },
        "prometheus_expr": {
          "description": "The PromQL expression to evaluate at the time of each evaluation cycle.\nThe result is recorded as a new time series with its metric name\ndefined by the metric_name (or name) field.",
          "type": "string"
        },
        "execution_group": {
          "description": "Optional execution_group in which this rule is to be evaluated.\nAt least one of bucket_slug and execution_group must be set. If both are set, then they are expected to match.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1RecordingRuleLabelPolicy": {
      "properties": {
        "add": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to add or overwrite before storing the result.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1ResourcePools": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ResourcePools was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ResourcePools was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_pool": {
          "$ref": "#/definitions/ResourcePoolsDefaultPool"
        },
        "pools": {
          "description": "Optional pools. Cannot set more than 20 pools.",
          "items": {
            "$ref": "#/definitions/ResourcePoolsPool"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourcePoolsAllocation": {
      "properties": {
        "percent_of_license": {
          "description": "Percent of the license to allocate to this pool. Must be between 0\nand 100 inclusive. The percent_of_license values across all pools\n(excluding the default pool) must be \u003c= 100. default_pool need not specify\nan allocation, and implicitly receives any remaining allocation. If default_pool does\nexplicitly specify an allocation, the sum of percent_of_license across all pools\n(including the default pool) must exactly equal 100.",
          "format": "double",
          "type": "number"
        },
        "fixed_values": {
          "description": "Fixed values optionally override `percent_of_license` allocations for specified licenses.\nWhen defining fixed values for a license, all pools must have an explicit fixed value\nspecification for that given license. The default pool receives all remaining quota left\nwithin the license, after subtracting the sum of fixed values across pools for that license.",
          "items": {
            "$ref": "#/definitions/AllocationFixedValue"
          },
          "type": "array"
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Currently, only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourceType": {
      "enum": [
        "BUCKET",
        "DASHBOARD",
        "GRAFANA_DASHBOARD",
        "MONITOR",
        "NOTIFICATION_POLICY",
        "RECORDING_RULE",
        "MAPPING_RULE",
        "ROLLUP_RULE"
      ],
      "type": "string"
    },
    "configv1RollupRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RollupRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the RollupRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the RollupRule. May be modified after the RollupRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RollupRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RollupRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Required slug of the bucket the RollupRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Filters incoming metrics by label. If multiple label filters are specified, an\nincoming metric must match every label filter to match the rule. Label values\nsupport glob patterns, including matching multiple patterns with an `OR`, such\nas `service:{svc1,svc2}`. These special filters are available for matching\nmetrics by non-label request metadata:\n * `__metric_type__`: Matches the incoming metric's [Observability Platform\n   metric\n   type](https://docs.chronosphere.io/control/shaping/types#observability-platform-types).\n   This is the recommended method for filtering on metric type. Valid values:\n   `cumulative_counter`, `cumulative_exponential_histogram`, `delta_counter`,\n   `delta_exponential_histogram`, `gauge`, `measurement`.\n * `__metric_source__`: Matches the incoming metric's [source\n   format](https://docs.chronosphere.io/control/shaping/types#supported-formats).\n   Valid values: `carbon`, `chrono_gcp`, `dogstatsd`, `open_metrics`,\n   `open_telemetry`, `prometheus`, `signalfx`, `statsd`, `wavefront`.\n * `__m3_prom_type__`: When ingesting with Prometheus, matches the incoming\n   metric's [Prometheus metric\n   type](https://docs.chronosphere.io/control/shaping/types#prometheus). Valid\n   values: `counter`, `gauge`, `histogram`, `gauge_histogram`, `summary`,\n   `info`, `state_set`, `quantile`.\n * `__otel_type__`: When ingesting with OpenTelemetry, matches on the incoming\n   metric's [OpenTelemetry metric type](https://docs.chronosphere.io/control/shaping/types#opentelemetry).\n   Valid values: `sum`, `monotonic_sum`, `gauge`, `histogram`, `exp_histogram`,\n   `summary`.\nFor example, the following filter matches any cumulative counter metric with a\n`service=gateway` label whose metric name starts with `http_requests_`:\n```\n__metric_type__:cumulative_counter service:gateway __name__:http_requests_*\n```",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "metric_name": {
          "description": "This field is optional for Graphite rollup rules.",
          "type": "string"
        },
        "metric_type": {
          "$ref": "#/definitions/RollupRuleMetricType"
        },
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1RollupRuleStoragePolicy"
        },
        "interval": {
          "description": "The distance in time between aggregated data points. Intervals are based on your\n[retention policy](https://docs.chronosphere.io/administer/licensing#retention-policies).\nUse this optional field to set a custom interval.\nThis field was known as `storage_policies` in version\n0.286.0-2023-01-06-release.1 and earlier.",
          "type": "string"
        },
        "expansive_match": {
          "description": "A series matches and aggregates only if each label defined by filters and\n`label_policy.keep` or `graphite_label_policy.replace` (respectively) exist in\nthe series. Setting `expansive_match=true` removes this restriction. Default:\n`expansive_match=false`.\n\nIf `false`, a series matches and aggregates only if each label defined by the\nprovided `filters` and the `label_policy.keep` or\n`graphite_label_policy.replace` settings exist in the series.",
          "type": "boolean"
        },
        "add_metric_type_label": {
          "description": "Defines whether to add a `__rollup_type__` label in the new metric.",
          "type": "boolean"
        },
        "drop_raw": {
          "description": "Defines whether to automatically generate drop rules for this rollup rule.\nSet to `true` to remove raw metrics that match this rollup rule. Default: `false`.",
          "type": "boolean"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RollupRuleLabelPolicy"
        },
        "label_replace": {
          "$ref": "#/definitions/RollupRuleLabelReplace"
        },
        "mode": {
          "$ref": "#/definitions/configv1RollupRuleMode"
        },
        "graphite_label_policy": {
          "$ref": "#/definitions/RollupRuleGraphiteLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleLabelPolicy": {
      "description": "TODO: consolidate w/ RecordingRule.LabelPolicy once both of these\n entities implement the same label semantics.",
      "properties": {
        "keep": {
          "description": "Labels that should be retained in the output metric. If set, then the\ndiscard field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "discard": {
          "description": "Labels that should be discarded in the output metric. If set, then the\nkeep field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleMode": {
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "title": "- PREVIEW: TODO: DISABLED = 2;",
      "type": "string"
    },
    "configv1RollupRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Service": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Service. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Service. May be modified after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ServiceAccount": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the ServiceAccount. If slug is not provided, one will be generated based of the name field. Cannot be modified after the ServiceAccount is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the ServiceAccount. May be modified after the ServiceAccount is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ServiceAccount was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ServiceAccount was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "token": {
          "description": "token is the generated API token of the service account. Cannot be set by\nclients.\n\ntoken is only set once by the server in the CreateServiceAccount response.\nReadServiceAccount will always return an empty token. Therefore, when\ncreating a service account, clients are responsible for securely storing\nthe response token on their end, as they will not be able to read it\nagain.",
          "readOnly": true,
          "type": "string"
        },
        "email": {
          "description": "email is the generated email address of the service account. Cannot be set\nby clients.",
          "readOnly": true,
          "type": "string"
        },
        "unrestricted": {
          "description": "If set, grants the service account access to all Chronosphere APIs\n(including resource configuration and metric data) within the access\ncontrols defined by the service account's team membership.\n\nExactly one of unrestricted or metrics_restriction must be set.",
          "type": "boolean"
        },
        "metrics_restriction": {
          "$ref": "#/definitions/ServiceAccountMetricsRestriction"
        }
      },
      "type": "object"
    },
    "configv1Team": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Team. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Team is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Team. May be modified after the Team is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Team was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Team was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "user_emails": {
          "description": "Unordered set of emails whose users are members of this team.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "description": {
          "description": "Optional short description of the team.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceBehavior": {
      "properties": {
        "name": {
          "description": "Required name of the TraceBehavior. May be modified after the TraceBehavior is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceBehavior. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceBehavior is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehavior was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehavior was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "base_tail_sample_rate": {
          "description": "Sample rate for fully assembled traces that do not apply to the error, fast, slow, large, or small sampling options.",
          "format": "double",
          "type": "number"
        },
        "base_head_sample_rate": {
          "description": "Sample rate for head sampling. This applies to all root spans that are enrolled in head sampling,\nbut do not have a specific rule defined for their service.",
          "format": "double",
          "type": "number"
        },
        "error_sample_options": {
          "$ref": "#/definitions/TraceBehaviorErrorSampleOptions"
        },
        "fast_sample_options": {
          "$ref": "#/definitions/TraceBehaviorFastSampleOptions"
        },
        "slow_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSlowSampleOptions"
        },
        "large_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorLargeTraceSampleOptions"
        },
        "small_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSmallTraceSampleOptions"
        }
      },
      "type": "object"
    },
    "configv1TraceBehaviorConfig": {
      "description": "TraceBehaviorConfig is a singleton configuration object that specifies the\nconfiguration for trace behaviors.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "main_behavior_assignments": {
          "description": "List of assignments for the main behavior. The referenced datasets are datasets \nto be enrolled in behaviors. The referenced behaviors are the active behaviors\nfor the dataset when there is no override in place. \n* Only one main behavior can be assigned to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigMainBehaviorAssignment"
          },
          "type": "array"
        },
        "override_behavior_assignments": {
          "description": "List of assignments for the override behavior. OverrideBehaviorAssignments are used to\nspecify the active behavior for a dataset over a specific time range.\n* Only one override behavior can be assigned to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "dataset_priorities": {
          "description": "List of dataset priorities. This list specifies the order in which datasets\nare considered when determining the behavior to follow for a trace. Dataset\npriorities are used to break ties when a trace matches more than one dataset\nwith an active behavior.\n* Each entry in this list must refer to the slug of an existing dataset.\n* The order of the list is the order in which the datasets are considered.\n* The list must contain all datasets referenced in either main_behavior_assignments\n  and override_behavior_assignments.\n* The list may contain datasets that are not referenced in either of the above.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "baseline_behavior_slug": {
          "description": "The baseline behavior to use for behavior assignments and base head sampling rates.",
          "type": "string"
        },
        "preview_behavior_assignments": {
          "description": "List of assignments for the preview behavior. The\nreferenced behaviors are in preview mode for the assigned dataset.\nYou can assign only one preview behavior to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1TraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the TraceJaegerRemoteSamplingStrategy. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the TraceJaegerRemoteSamplingStrategy. May be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This must match the slug and name fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRule": {
      "properties": {
        "name": {
          "description": "Required name of the TraceMetricsRule. May be modified after the TraceMetricsRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceMetricsRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceMetricsRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceMetricsRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceMetricsRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "The name of the generated trace metrics.",
          "type": "string"
        },
        "metric_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to apply to the generated trace metrics.",
          "type": "object"
        },
        "histogram_buckets_secs": {
          "description": "Histogram bucket values, in seconds, for generated duration metrics.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "trace_filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "group_by": {
          "description": "Add labels to the resultant metrics based on these specified GroupBy messages.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRuleGroupBy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRuleGroupBy": {
      "description": "GroupBy contains fields required to group the resultant metrics of a TraceMetricsRule by a specific key.",
      "properties": {
        "label": {
          "description": "The label to use in the resultant metrics.",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/GroupByGroupByKey"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Each SpanFilter object represents all conditions that need to be true on\nthe same span for the span to be considered matching the SpanFilter. If\n`span_count` is used, the number of spans within the trace that match the\nSpanFilter needs to be within [min, max]. Multiple SpanFilters can be used,\nand each can be satisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule, which summarizes what it's for",
          "type": "string"
        },
        "system_name": {
          "description": "Value used as the metric label value for metrics emitted relating to this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "When the rule was created (novel system_name)",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "When the rule was updated (existing system_name)",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. A list of rules, evaluated in order until a match is found,\nand the sample rate applied, or else the default sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configv1TraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configv1DefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configv1UpdateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1UpdateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1UpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1UpdateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1UpdateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "create_if_missing": {
          "description": "If true, the LogAllocationConfig will be created if it does not already exist. If false, an error will be returned if the LogAllocationConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the LogAllocationConfig will not be created nor updated, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1UpdateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1UpdateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "create_if_missing": {
          "description": "If true, the OtelMetricsIngestion will be created if it does not already exist. If false, an error will be returned if the OtelMetricsIngestion does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the OtelMetricsIngestion will not be created nor updated, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1UpdateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "create_if_missing": {
          "description": "If true, the ResourcePools will be created if it does not already exist. If false, an error will be returned if the ResourcePools does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the ResourcePools will not be created nor updated, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1UpdateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "create_if_missing": {
          "description": "If true, the TraceBehaviorConfig will be created if it does not already exist. If false, an error will be returned if the TraceBehaviorConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceBehaviorConfig will not be created nor updated, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If true, the TraceTailSamplingRules will be created if it does not already exist. If false, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created nor updated, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\nThe Config API provides standard HTTP/JSON REST endpoints for creating, reading,\nupdating, deleting, and listing configurable Chronosphere resources.\n\nUse this link to download the raw Swagger specification:\n\u003ca href=\"/api/v1/config/swagger.json\"\u003e/api/v1/config/swagger.json\u003c/a\u003e\n",
    "title": "Config V1 API",
    "version": "v1"
  },
  "paths": {
    "/api/v1/config/buckets": {
      "get": {
        "operationId": "ListBuckets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Bucket with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Bucket with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListBucketsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "post": {
        "operationId": "CreateBucket",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot create the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/buckets/{slug}": {
      "delete": {
        "operationId": "DeleteBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "description": "force_delete indicates deletion of the bucket and all resources that reference the bucket.\nThis includes monitors, dashboards, notification policies, recording rules, and alerts.",
            "in": "query",
            "name": "force_delete",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteBucketResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Bucket because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "get": {
        "operationId": "ReadBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadBucketResponse"
            }
          },
          "404": {
            "description": "Cannot read the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "put": {
        "operationId": "UpdateBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateBucketBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot update the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/classic-dashboards": {
      "get": {
        "operationId": "ListClassicDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ClassicDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any ClassicDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any ClassicDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ClassicDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListClassicDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "post": {
        "operationId": "CreateClassicDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/classic-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "get": {
        "operationId": "ReadClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadClassicDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateClassicDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/collections": {
      "get": {
        "operationId": "ListCollections",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Collection with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Collection with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Collection with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get collections that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListCollectionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "post": {
        "operationId": "CreateCollection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Collection.",
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot create the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/collections/{slug}": {
      "delete": {
        "operationId": "DeleteCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Collection because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "get": {
        "operationId": "ReadCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadCollectionResponse"
            }
          },
          "404": {
            "description": "Cannot read the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "put": {
        "operationId": "UpdateCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateCollectionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Collection.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot update the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/datasets": {
      "get": {
        "operationId": "ListDatasets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dataset with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dataset with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Custom filtering option: list filtered down to a specific telemetry type.",
            "enum": [
              "TRACES",
              "LOGS"
            ],
            "in": "query",
            "name": "type",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDatasetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "post": {
        "operationId": "CreateDataset",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/datasets/{slug}": {
      "delete": {
        "operationId": "DeleteDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dataset because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "get": {
        "operationId": "ReadDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDatasetResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "put": {
        "operationId": "UpdateDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDatasetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/derived-labels": {
      "get": {
        "operationId": "ListDerivedLabels",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedLabel with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedLabel with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedLabelsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "post": {
        "operationId": "CreateDerivedLabel",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-labels/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedLabel because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "get": {
        "operationId": "ReadDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedLabelResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedLabelBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-metrics": {
      "get": {
        "operationId": "ListDerivedMetrics",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedMetric with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedMetric with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedMetricsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "post": {
        "operationId": "CreateDerivedMetric",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/derived-metrics/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedMetric because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "get": {
        "operationId": "ReadDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedMetricResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedMetricBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/drop-rules": {
      "get": {
        "operationId": "ListDropRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DropRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DropRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDropRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "post": {
        "operationId": "CreateDropRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/drop-rules/{slug}": {
      "delete": {
        "operationId": "DeleteDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DropRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "get": {
        "operationId": "ReadDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDropRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "put": {
        "operationId": "UpdateDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDropRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations": {
      "get": {
        "operationId": "ListGcpMetricsIntegrations",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GcpMetricsIntegration with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GcpMetricsIntegration with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGcpMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GcpMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGcpMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGcpMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards": {
      "get": {
        "operationId": "ListGrafanaDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GrafanaDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any GrafanaDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any GrafanaDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GrafanaDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGrafanaDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "post": {
        "operationId": "CreateGrafanaDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "get": {
        "operationId": "ReadGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGrafanaDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGrafanaDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/log-allocation-config": {
      "delete": {
        "operationId": "DeleteLogAllocationConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogAllocationConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogAllocationConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogAllocationConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogAllocationConfig because there is a conflict with an existing LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      }
    },
    "/api/v1/config/log-scale-actions": {
      "get": {
        "operationId": "ListLogScaleActions",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAction with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAction with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleActionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAction",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-actions/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAction because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleActionResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleActionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts": {
      "get": {
        "operationId": "ListLogScaleAlerts",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAlert with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAlert with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleAlertsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAlert",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAlert because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleAlertResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleAlertBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/mapping-rules": {
      "get": {
        "operationId": "ListMappingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MappingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any MappingRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MappingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMappingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "post": {
        "operationId": "CreateMappingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/mapping-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MappingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "get": {
        "operationId": "ReadMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMappingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMappingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/monitors": {
      "get": {
        "operationId": "ListMonitors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Monitor with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any Monitor with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Monitor with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Monitor with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter returned monitors by the teams that own the collections that they belong to.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMonitorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "CreateMonitor",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot create the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/monitors/{slug}": {
      "delete": {
        "operationId": "DeleteMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Monitor because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "get": {
        "operationId": "ReadMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMonitorResponse"
            }
          },
          "404": {
            "description": "Cannot read the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "operationId": "UpdateMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMonitorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot update the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/muting-rules": {
      "get": {
        "operationId": "ListMutingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MutingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MutingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Lists muting rules filtered by the states.\nIf empty, all muting rules are included.",
            "in": "query",
            "items": {
              "enum": [
                "PENDING",
                "ACTIVE",
                "EXPIRED"
              ],
              "type": "string"
            },
            "name": "states",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMutingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "post": {
        "operationId": "CreateMutingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/muting-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MutingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "get": {
        "operationId": "ReadMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMutingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMutingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/notification-policies": {
      "get": {
        "operationId": "ListNotificationPolicies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any NotificationPolicy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any NotificationPolicy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any NotificationPolicy with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any NotificationPolicy with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotificationPoliciesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "post": {
        "operationId": "CreateNotificationPolicy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot create the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notification-policies/{slug}": {
      "delete": {
        "operationId": "DeleteNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NotificationPolicy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "get": {
        "operationId": "ReadNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotificationPolicyResponse"
            }
          },
          "404": {
            "description": "Cannot read the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "put": {
        "operationId": "UpdateNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotificationPolicyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot update the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notifiers": {
      "get": {
        "operationId": "ListNotifiers",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Notifier with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Notifier with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotifiersResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "post": {
        "operationId": "CreateNotifier",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot create the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/notifiers/{slug}": {
      "delete": {
        "operationId": "DeleteNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Notifier because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "get": {
        "operationId": "ReadNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotifierResponse"
            }
          },
          "404": {
            "description": "Cannot read the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "put": {
        "operationId": "UpdateNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotifierBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot update the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/otel-metrics-ingestion": {
      "delete": {
        "operationId": "DeleteOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the OtelMetricsIngestion because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the OtelMetricsIngestion because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "get": {
        "operationId": "ReadOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadOtelMetricsIngestionResponse"
            }
          },
          "404": {
            "description": "Cannot read the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "post": {
        "operationId": "CreateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot create the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the OtelMetricsIngestion because there is a conflict with an existing OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "put": {
        "operationId": "UpdateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot update the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      }
    },
    "/api/v1/config/recording-rules": {
      "get": {
        "operationId": "ListRecordingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RecordingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RecordingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The execution_groups filter cannot be used when a bucket_slug filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The bucket_slugs filter cannot be used when an execution_group filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "execution_groups",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRecordingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "post": {
        "operationId": "CreateRecordingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/recording-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RecordingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "get": {
        "operationId": "ReadRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRecordingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "put": {
        "operationId": "UpdateRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRecordingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/resource-pools": {
      "delete": {
        "operationId": "DeleteResourcePools",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ResourcePools because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ResourcePools because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "get": {
        "operationId": "ReadResourcePools",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadResourcePoolsResponse"
            }
          },
          "404": {
            "description": "Cannot read the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "post": {
        "description": "ResourcePools CRUD (subset for singleton objects)",
        "operationId": "CreateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot create the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ResourcePools because there is a conflict with an existing ResourcePools.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "put": {
        "operationId": "UpdateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot update the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      }
    },
    "/api/v1/config/rollup-rules": {
      "get": {
        "operationId": "ListRollupRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RollupRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RollupRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any RollupRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRollupRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "post": {
        "operationId": "CreateRollupRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/rollup-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RollupRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "get": {
        "operationId": "ReadRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRollupRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "put": {
        "operationId": "UpdateRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRollupRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/service-accounts": {
      "get": {
        "operationId": "ListServiceAccounts",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ServiceAccount with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ServiceAccount with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAccountsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "post": {
        "operationId": "CreateServiceAccount",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot create the ServiceAccount because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ServiceAccount because there is a conflict with an existing ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-accounts/{slug}": {
      "delete": {
        "operationId": "DeleteServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ServiceAccount because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "get": {
        "operationId": "ReadServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAccountResponse"
            }
          },
          "404": {
            "description": "Cannot read the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/services/{slug}": {
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/teams": {
      "get": {
        "operationId": "ListTeams",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Team with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Team with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTeamsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "post": {
        "operationId": "CreateTeam",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Team.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot create the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/teams/{slug}": {
      "delete": {
        "operationId": "DeleteTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTeamResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Team because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "get": {
        "operationId": "ReadTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTeamResponse"
            }
          },
          "404": {
            "description": "Cannot read the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "put": {
        "operationId": "UpdateTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTeamBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Team.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot update the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/trace-behavior-config": {
      "delete": {
        "operationId": "DeleteTraceBehaviorConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehaviorConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehaviorConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehaviorConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehaviorConfig because there is a conflict with an existing TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      }
    },
    "/api/v1/config/trace-behaviors": {
      "get": {
        "operationId": "ListTraceBehaviors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceBehavior with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceBehavior with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceBehaviorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehavior",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-behaviors/{slug}": {
      "delete": {
        "operationId": "DeleteTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehavior because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceBehaviorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules": {
      "get": {
        "operationId": "ListTraceMetricsRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceMetricsRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceMetricsRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get trace metric rules by name.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "metric_names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceMetricsRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "post": {
        "description": "***\nTrace Metrics Rules\n***",
        "operationId": "CreateTraceMetricsRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules/{slug}": {
      "delete": {
        "operationId": "DeleteTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceMetricsRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "get": {
        "operationId": "ReadTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceMetricsRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "put": {
        "operationId": "UpdateTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceMetricsRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigV1"
    }
  ]
}