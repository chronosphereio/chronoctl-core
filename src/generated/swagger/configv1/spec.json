{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "AllocationFixedValue": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "value": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThreshold": {
      "properties": {
        "percent_of_pool_allocation": {
          "description": "Threshold expressed as a percent of the license allocated to a pool.\nA value of `100` represents a threshold that is the pool's full allocation.\nValues over `100` indicate thresholds that exceed the pool's allocation.\nFor example, a value of `50` represents a threshold that is half the pool's\nallocation and a value of `200` represents a threshold that is double the\npool's allocation.",
          "format": "double",
          "type": "number"
        },
        "fixed_value": {
          "description": "Threshold expressed as a fixed value of the license.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThresholds": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "all_priorities": {
          "$ref": "#/definitions/AllocationThreshold"
        },
        "default_and_low_priority": {
          "$ref": "#/definitions/AllocationThreshold"
        },
        "low_priority": {
          "$ref": "#/definitions/AllocationThreshold"
        }
      },
      "title": "Thresholds define strict quota limits for each metrics license.\n**This feature is part of pre-release functionality and is subject to change.**",
      "type": "object"
    },
    "ConditionOp": {
      "enum": [
        "GEQ",
        "GT",
        "LEQ",
        "LT",
        "EQ",
        "NEQ",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "ConfigV1UpdateBucketBody": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "create_if_missing": {
          "description": "If `true`, the Bucket will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Bucket does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Bucket isn't created or updated, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateClassicDashboardBody": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the GrafanaDashboard isn't created or updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateCollectionBody": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "create_if_missing": {
          "description": "If `true`, the Collection will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Collection does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Collection isn't created or updated, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDashboardBody": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the Dashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Dashboard isn't created or updated, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDatasetBody": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "create_if_missing": {
          "description": "If `true`, the Dataset will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dataset does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Dataset isn't created or updated, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedLabelBody": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "create_if_missing": {
          "description": "If `true`, the DerivedLabel will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedLabel does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the DerivedLabel isn't created or updated, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedMetricBody": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "create_if_missing": {
          "description": "If `true`, the DerivedMetric will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedMetric does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the DerivedMetric isn't created or updated, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDropRuleBody": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "create_if_missing": {
          "description": "If `true`, the DropRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DropRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the DropRule isn't created or updated, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGcpMetricsIntegrationBody": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "create_if_missing": {
          "description": "If `true`, the GcpMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GcpMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the GcpMetricsIntegration isn't created or updated, and no response GcpMetricsIntegration will be returned. The response will return an error if the given GcpMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGrafanaDashboardBody": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the GrafanaDashboard isn't created or updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleActionBody": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "create_if_missing": {
          "description": "If `true`, the LogScaleAction will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAction does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LogScaleAction isn't created or updated, and no response LogScaleAction will be returned. The response will return an error if the given LogScaleAction is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleAlertBody": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "create_if_missing": {
          "description": "If `true`, the LogScaleAlert will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAlert does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LogScaleAlert isn't created or updated, and no response LogScaleAlert will be returned. The response will return an error if the given LogScaleAlert is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMappingRuleBody": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the MappingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MappingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the MappingRule isn't created or updated, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMonitorBody": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "create_if_missing": {
          "description": "If `true`, the Monitor will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Monitor does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Monitor isn't created or updated, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMutingRuleBody": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the MutingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MutingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the MutingRule isn't created or updated, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotificationPolicyBody": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "create_if_missing": {
          "description": "If `true`, the NotificationPolicy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the NotificationPolicy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the NotificationPolicy isn't created or updated, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotifierBody": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "create_if_missing": {
          "description": "If `true`, the Notifier will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Notifier does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Notifier isn't created or updated, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRecordingRuleBody": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the RecordingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RecordingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the RecordingRule isn't created or updated, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRollupRuleBody": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "create_if_missing": {
          "description": "If `true`, the RollupRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RollupRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the RollupRule isn't created or updated, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateSLOBody": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        },
        "create_if_missing": {
          "description": "If `true`, the SLO will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the SLO does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the SLO isn't created or updated, and no response SLO will be returned. The response will return an error if the given SLO is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTeamBody": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "create_if_missing": {
          "description": "If `true`, the Team will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Team does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the Team isn't created or updated, and no response Team will be returned. The response will return an error if the given Team is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceBehaviorBody": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceBehavior will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceBehavior does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceBehavior isn't created or updated, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy isn't created or updated, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceMetricsRuleBody": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceMetricsRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceMetricsRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceMetricsRule isn't created or updated, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConstructedLabelValueDefinition": {
      "properties": {
        "value": {
          "type": "string"
        },
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DatasetDatasetConfiguration": {
      "properties": {
        "type": {
          "$ref": "#/definitions/DatasetDatasetType"
        },
        "trace_dataset": {
          "$ref": "#/definitions/configv1TraceDataset"
        },
        "log_dataset": {
          "$ref": "#/definitions/configv1LogDataset"
        }
      },
      "type": "object"
    },
    "DatasetDatasetType": {
      "enum": [
        "TRACES",
        "LOGS"
      ],
      "type": "string"
    },
    "DefinitionBurnRateDefinition": {
      "properties": {
        "window": {
          "type": "string"
        },
        "budget": {
          "description": "The amount of allowed errors during a given time window,\nexpressed as a percentage of the error budget. Must be a\nvalue between `0.0` and `100.0`, exclusive.",
          "format": "double",
          "type": "number"
        },
        "severity": {
          "description": "Severity may only be one of: critical, warn.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to attach when this burn rate triggers. If you add these labels to\n`signal_groupings`, you can route them in the notification policy, and\ncan route different burn rates to other notifiers.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "DefinitionTimeWindow": {
      "properties": {
        "duration": {
          "description": "duration as a string in the format \"28d\" or \"24h\", etc.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DerivedLabelMetricLabel": {
      "properties": {
        "constructed_label": {
          "$ref": "#/definitions/MetricLabelConstructedLabel"
        },
        "mapping_label": {
          "$ref": "#/definitions/MetricLabelMappingLabel"
        }
      },
      "type": "object"
    },
    "DerivedMetricQuery": {
      "properties": {
        "prometheus_expr": {
          "description": "Required PromQL expression which the derived metric executes. Should\ninclude all configured variables.",
          "example": "cpu_usage{$service, $instance} / sum(cpu_usage{$service})",
          "type": "string"
        },
        "variables": {
          "description": "Optional variables which may be used in the derived metric as label\nselectors.",
          "items": {
            "$ref": "#/definitions/DerivedMetricVariable"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelector": {
      "properties": {
        "labels": {
          "description": "Labels which must match in the derived metric usage for the selector to\nmatch.",
          "items": {
            "$ref": "#/definitions/configv1DerivedMetricLabelMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelectorQuery": {
      "properties": {
        "selector": {
          "$ref": "#/definitions/DerivedMetricSelector"
        },
        "query": {
          "$ref": "#/definitions/DerivedMetricQuery"
        }
      },
      "type": "object"
    },
    "DerivedMetricVariable": {
      "properties": {
        "name": {
          "description": "Required name of the variable.",
          "example": "service",
          "type": "string"
        },
        "default_prometheus_selector": {
          "description": "Required PromQL label selector which must match the given variable name.\nIf the variable is not specified in the derived metric usage, then this\ndefault selector is used.",
          "example": "service=~\".*\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DropRuleConditionalRateBasedDrop": {
      "description": "No longer supported and cannot be used.\nDefines behavior for conditional drop policies.",
      "properties": {
        "enabled": {
          "description": "Enables rate-based metric dropping.",
          "type": "boolean"
        },
        "rate_limit_threshold": {
          "description": "Percentage of the licensed limit reached in order to activate the drop\nrule, between 0 and 100.",
          "format": "double",
          "type": "number"
        },
        "activated_drop_duration_secs": {
          "description": "Once activated, activated_drop_duration_secs defines how long the drop\nrule stays activated before rechecking against the rate_limit_threshold.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DropRuleValueBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables dropping metrics based on a set value.",
          "type": "boolean"
        },
        "target_drop_value": {
          "description": "The target data point value at which to drop metrics.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "GcpMetricsIntegrationMetricGroup": {
      "properties": {
        "project_id": {
          "description": "Project ID that has access to the metric data.",
          "type": "string"
        },
        "prefixes": {
          "description": "List of Gcp metric prefixes to ingest.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "GraphiteLabelPolicyReplace": {
      "properties": {
        "name": {
          "description": "Required name of the label whose value should be replaced. Only\n`__gX__` labels are allowed (aka positional Graphite labels).",
          "example": "__g1__",
          "type": "string"
        },
        "new_value": {
          "description": "Required new value of the replaced label.",
          "example": "ALL_HOSTS",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByGroupByKey": {
      "description": "GroupByKey describes a key to group by.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GroupByKeyGroupByKeyType"
        },
        "named_key": {
          "description": "For named key types, such as span tags, indicates the name of the key to\ngroup by.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByKeyGroupByKeyType": {
      "description": " - SERVICE: The service to group by.\n - OPERATION: The operation to group by.\n - TAG: The span tag to group by.",
      "enum": [
        "SERVICE",
        "OPERATION",
        "TAG"
      ],
      "type": "string"
    },
    "HTTPConfigBasicAuth": {
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "HTTPConfigTLSConfig": {
      "properties": {
        "insecure_skip_verify": {
          "description": "Disables validation of the server certificate.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ListMutingRulesRequestState": {
      "enum": [
        "PENDING",
        "ACTIVE",
        "EXPIRED"
      ],
      "type": "string"
    },
    "LogAllocationConfigDatasetAllocation": {
      "properties": {
        "dataset_slug": {
          "description": "Slug of the dataset.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDefaultDataset": {
      "description": "Configuration for default dataset.",
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigHighLowPriorities": {
      "description": "Defines explicit high and low priority match criteria to specify which logs to\ndrop first (low) and last (high). Anything not matched by either set of rules is\nconsidered default priority and is dropped after low priority but before high\npriority data.",
      "properties": {
        "high_priority_filters": {
          "description": "A list of search filters defining which logs are considered high priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "A list of search filters defining which logs are considered low priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParser": {
      "properties": {
        "mode": {
          "$ref": "#/definitions/LogIngestConfigLogFieldParserMode"
        },
        "source": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "destination": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "parser": {
          "$ref": "#/definitions/LogIngestConfigLogParser"
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogIngestConfigLogParser": {
      "properties": {
        "parser_type": {
          "$ref": "#/definitions/LogParserParserType"
        },
        "regex_parser": {
          "$ref": "#/definitions/LogParserRegexParser"
        },
        "key_value_parser": {
          "$ref": "#/definitions/LogParserKeyValueParser"
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParser": {
      "properties": {
        "name": {
          "description": "The name of the parser. Must be unique within the configuration.",
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/LogIngestConfigPlaintextParserMode"
        },
        "parser": {
          "$ref": "#/definitions/LogIngestConfigLogParser"
        },
        "drop_original": {
          "description": "If true, the original log will be dropped after parsing.\nOtherwise the original log is stored under the key \"plaintext_log\".",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogParserKeyValueParser": {
      "description": "A parser to extract key-value pairs from a string.\nIf duplicate keys are found, the first instance is used.",
      "properties": {
        "pair_separator": {
          "description": "String used to split each pair into its key and value. Required.",
          "type": "string"
        },
        "delimiter": {
          "description": "String used to split the input into key-value pairs. Required.",
          "type": "string"
        },
        "trim_set": {
          "description": "All leading and trailing Unicode code points contained in the trim\nset will be removed from keys and values. Optional.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogParserParserType": {
      "enum": [
        "JSON",
        "REGEX",
        "KEY_VALUE"
      ],
      "type": "string"
    },
    "LogParserRegexParser": {
      "properties": {
        "regex": {
          "description": "Regex is the Re2 regex parser pattern to apply.\nNamed capturing groups become named fields in the extracted log.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionActionType": {
      "enum": [
        "EMAIL",
        "HUMIO_REPO",
        "OPS_GENIE",
        "PAGER_DUTY",
        "SLACK",
        "SLACK_POST_MESSAGE",
        "VICTOR_OPS",
        "WEBHOOK",
        "UPLOAD_FILE"
      ],
      "type": "string"
    },
    "LogScaleActionEmailAction": {
      "properties": {
        "recipients": {
          "description": "List of email addresses to send an email to.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject_template": {
          "description": "Subject of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "body_template": {
          "description": "Body of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "attach_csv": {
          "description": "Whether the result set should be attached as a CSV file.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionHumioRepoAction": {
      "properties": {
        "ingest_token": {
          "description": "Ingest token for the repository that the action should ingest into.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionOpsGenieAction": {
      "properties": {
        "api_url": {
          "description": "OpsGenie webhook URL to send the request to.",
          "type": "string"
        },
        "ops_genie_key": {
          "description": "Key to authenticate with OpsGenie.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionPagerDutyAction": {
      "properties": {
        "severity": {
          "$ref": "#/definitions/PagerDutyActionSeverity"
        },
        "routing_key": {
          "description": "Routing key to authenticate with PagerDuty.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackAction": {
      "properties": {
        "url": {
          "description": "Slack webhook URL to send the request to.",
          "type": "string"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackPostMessageAction": {
      "properties": {
        "api_token": {
          "description": "API token to authenticate with Slack.",
          "type": "string"
        },
        "channels": {
          "description": "List of Slack channels to message.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionUploadFileAction": {
      "properties": {
        "file_name": {
          "description": "File name for the uploaded file.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionVictorOpsAction": {
      "properties": {
        "message_type": {
          "description": "Type of the VictorOps message to make.",
          "type": "string"
        },
        "notify_url": {
          "description": "VictorOps webhook URL to send the request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionWebhookAction": {
      "properties": {
        "method": {
          "$ref": "#/definitions/WebhookActionHTTPMethod"
        },
        "url": {
          "description": "URL to send the HTTP or HTTPS request to.",
          "type": "string"
        },
        "headers": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers of the HTTP or HTTPS request.",
          "type": "object"
        },
        "body_template": {
          "description": "Body of the HTTP or HTTPS request. Can be templated with values from the query result.",
          "type": "string"
        },
        "ignore_ssl": {
          "description": "Flag indicating whether SSL should be ignored for the request.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleAlertAlertType": {
      "enum": [
        "STANDARD",
        "FILTER"
      ],
      "type": "string"
    },
    "MappingLabelNameMapping": {
      "properties": {
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "source_label": {
          "description": "The actual label ingested on the time series",
          "type": "string"
        },
        "value_mappings": {
          "description": "These value mappings apply to just the name mapping they belong to.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MappingLabelValueMapping": {
      "properties": {
        "source_value_globs": {
          "description": "Defines the source label values that should be mapped into the given target_value.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_value": {
          "description": "The value that source_value_globs are mapped into.\nFor example, given this mapping:\n```yaml\nvalue_mappings:\n - source_value_globs:\n     - Cat\n     - CAT\n   target_value: cat\n```\nThis indicates that the target value `cat` maps to the source label's values `Cat` and `CAT`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingRuleAggregationPolicy": {
      "properties": {
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1MappingRuleStoragePolicy"
        },
        "interval": {
          "description": "Interval between aggregated data points, equivalent to the resolution\nfield in storage policy. If set, then the storage_policy field can't be\nset.",
          "type": "string"
        },
        "drop_timestamp": {
          "description": "Deprecated: This field is no longer supported.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MetricLabelConstructedLabel": {
      "properties": {
        "value_definitions": {
          "items": {
            "$ref": "#/definitions/ConstructedLabelValueDefinition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabel": {
      "properties": {
        "name_mappings": {
          "items": {
            "$ref": "#/definitions/MappingLabelNameMapping"
          },
          "type": "array"
        },
        "value_mappings": {
          "description": "These value mappings apply to the whole mapping label.\nIf there's no name_mappings, these value mappings apply to the label that exists on the metric.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricsRestrictionPermission": {
      "enum": [
        "READ",
        "WRITE",
        "READ_WRITE"
      ],
      "type": "string"
    },
    "MonitorCondition": {
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "Required. The value to compare to the metric value using the `op` operation.",
          "format": "double",
          "type": "number"
        },
        "sustain_secs": {
          "description": "Amount of time the query needs to fail the condition check before an alert is\ntriggered. Must be an integer. Accepts one of `s` (seconds), `m` (minutes), or\n`h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        },
        "resolve_sustain_secs": {
          "description": "Amount of time the query needs to no longer fire before resolving. Must be an\ninteger. Accepts one of `s` (seconds), `m` (minutes), or `h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "MonitorSchedule": {
      "properties": {
        "timezone": {
          "description": "The timezone of the time ranges.",
          "type": "string"
        },
        "weekly_schedule": {
          "$ref": "#/definitions/ScheduleWeeklySchedule"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditions": {
      "description": "Conditions evaluated against each queried series to determine the severity of each series.",
      "properties": {
        "defaults": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        },
        "overrides": {
          "description": "Optional. Specifies a list of overrides to use for series having matching\nlabels. Each override defines labels that potentially match a series' labels.\nIf one or more overrides match a series, the severity conditions of the first\nmatching override are used instead of the defaults.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "$ref": "#/definitions/MonitorSeriesConditionsOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditionsOverride": {
      "properties": {
        "label_matchers": {
          "description": "Set of matchers on a series' labels. If all labels match, then the conditions\ndefined in this override are used.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "severity_conditions": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        }
      },
      "type": "object"
    },
    "MonitorSignalGrouping": {
      "description": "SignalGrouping defines how the set of series from the query are split into signals.",
      "properties": {
        "label_names": {
          "description": "Set of label names used to split series into signals. Each unique combination\nof labels result in its own signal. For example, if `label_names` is\n`[\"service\", \"code\"]`, then all series including labels\n`{service=\"foo\",code=\"404\"}` will be grouped together in the same signal.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "signal_per_series": {
          "description": "If set to `true`, each series will have its own signal. Cannot be used with\n`label_names`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutes": {
      "properties": {
        "defaults": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        },
        "overrides": {
          "description": "Optional list of overrides to use for alerts having matching labels.\nEach override defines labels that potentially match an alert's labels.\nIf one or more overrides match an alert, the notifiers of the first matching\noverride are used instead of the defaults.",
          "items": {
            "$ref": "#/definitions/NotificationPolicyRoutesOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesGroupBy": {
      "properties": {
        "label_names": {
          "description": "Set of label names used to group alerts.\nFor example, if label_names is [\"service\", \"code\"] then all alerts including labels {service=\"foo\",code=\"404\"}\nwill be grouped together.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesOverride": {
      "properties": {
        "alert_label_matchers": {
          "description": "Set of matchers on an alert's labels.\nIf all labels match then the override notifiers apply.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "notifiers": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        }
      },
      "type": "object"
    },
    "NotifierEmailConfig": {
      "properties": {
        "to": {
          "description": "Required email address to send notifications to.",
          "type": "string"
        },
        "html": {
          "description": "Optional HTML body of the email.",
          "type": "string"
        },
        "text": {
          "description": "Optional text body of the email.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierHTTPConfig": {
      "properties": {
        "basic_auth": {
          "$ref": "#/definitions/HTTPConfigBasicAuth"
        },
        "bearer_token": {
          "description": "Bearer token authentication. Cannot be set if basic_auth is set.",
          "type": "string"
        },
        "proxy_url": {
          "description": "Optional proxy URL.\nDEPRECATED: Custom proxies are unsupported.",
          "type": "string"
        },
        "tls_config": {
          "$ref": "#/definitions/HTTPConfigTLSConfig"
        }
      },
      "type": "object"
    },
    "NotifierOpsGenieConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required OpsGenie API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required OpsGenie API URL to send requests to, e.g.\n\"https://api.opsgenie.com/\".",
          "type": "string"
        },
        "message": {
          "description": "Alert text.",
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "source": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of arbitrary key/value pairs that provide further detail about the\nalert.",
          "type": "object"
        },
        "responders": {
          "description": "List of responders responsible for notifications.",
          "items": {
            "$ref": "#/definitions/OpsGenieConfigResponder"
          },
          "type": "array"
        },
        "tags": {
          "description": "Comma separated list of tags attached to the notifications.",
          "type": "string"
        },
        "note": {
          "description": "Additional alert note.",
          "type": "string"
        },
        "priority": {
          "description": "Priority level of alert. Possible values are P1, P2, P3, P4, and P5.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierPagerdutyConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "The Pagerduty URL to send API requests to.",
          "type": "string"
        },
        "client": {
          "description": "Client identification of the notification sender.",
          "type": "string"
        },
        "client_url": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "description": {
          "description": "Description of the incident.",
          "type": "string"
        },
        "severity": {
          "description": "Severity of the incident.\nValid values are 'critical', 'error', 'warning', 'info', or blank",
          "type": "string"
        },
        "class": {
          "description": "The class/type of the event.",
          "type": "string"
        },
        "component": {
          "description": "The part or component of the affected system which is broken.",
          "type": "string"
        },
        "group": {
          "description": "A cluster or grouping of services.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set of arbitrary key/value pairs which provide further detail about the\nincident.",
          "type": "object"
        },
        "images": {
          "description": "Images to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigImage"
          },
          "type": "array"
        },
        "links": {
          "description": "Links to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigLink"
          },
          "type": "array"
        },
        "service_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Prometheus\"). Cannot be set if routing_key is set.",
          "type": "string"
        },
        "routing_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Events API v2\"). Cannot be set if service_key is set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_url": {
          "description": "Required Slack webhook API URL.",
          "type": "string"
        },
        "channel": {
          "description": "The channel to send notifications to.",
          "type": "string"
        },
        "username": {
          "description": "The user to send notifications to.",
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "title_link": {
          "type": "string"
        },
        "pretext": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "footer": {
          "type": "string"
        },
        "fallback": {
          "type": "string"
        },
        "callback_id": {
          "type": "string"
        },
        "icon_emoji": {
          "type": "string"
        },
        "icon_url": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "thumb_url": {
          "type": "string"
        },
        "short_fields": {
          "type": "boolean"
        },
        "link_names": {
          "type": "boolean"
        },
        "mrkdwn_in": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "items": {
            "$ref": "#/definitions/SlackConfigField"
          },
          "type": "array"
        },
        "actions": {
          "items": {
            "$ref": "#/definitions/NotifierSlackConfigAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfigAction": {
      "properties": {
        "type": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "style": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "confirm_field": {
          "$ref": "#/definitions/SlackConfigConfirmationField"
        }
      },
      "type": "object"
    },
    "NotifierVictorOpsConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required VictorOps API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required VictorOps API URL.",
          "type": "string"
        },
        "routing_key": {
          "description": "Required VictorOps routing key.",
          "type": "string"
        },
        "message_type": {
          "description": "Describes the behavior of the alert (CRITICAL, WARNING, INFO).",
          "type": "string"
        },
        "entity_display_name": {
          "description": "Summary of the alerted problem.",
          "type": "string"
        },
        "state_message": {
          "description": "Long explanation of the alerted problem.",
          "type": "string"
        },
        "monitoring_tool": {
          "description": "The monitoring tool the state message is from.",
          "type": "string"
        },
        "custom_fields": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "NotifierWebhookConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "Required webhook URL (will be called as a POST request).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OpsGenieConfigResponder": {
      "properties": {
        "id": {
          "description": "ID of the responder. Cannot be set if name or username are set.",
          "type": "string"
        },
        "name": {
          "description": "Name of the responder. Cannot be set if id or username are set.",
          "type": "string"
        },
        "username": {
          "description": "Username of the responder. Cannot be set if id or name are set.",
          "type": "string"
        },
        "responder_type": {
          "$ref": "#/definitions/ResponderResponderType"
        }
      },
      "type": "object"
    },
    "OtelMetricsIngestionResourceAttributes": {
      "properties": {
        "flatten_mode": {
          "$ref": "#/definitions/ResourceAttributesFlattenMode"
        },
        "filter_mode": {
          "$ref": "#/definitions/ResourceAttributesFilterMode"
        },
        "exclude_keys": {
          "description": "Do not copy any resource attribute whose key exactly matches one of the\nstrings in this list.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "generate_target_info": {
          "description": "Generate a target_info time series with labels derived from resource\nattributes. The filter_mode and exclude_keys settings apply in the same way as\nfor the \"flatten\" operation. The default is false.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PagerDutyActionSeverity": {
      "enum": [
        "CRITICAL",
        "ERROR",
        "WARNING",
        "INFO"
      ],
      "type": "string"
    },
    "PagerdutyConfigImage": {
      "properties": {
        "src": {
          "type": "string"
        },
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigLink": {
      "properties": {
        "href": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy applies.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "ResourceAttributesFilterMode": {
      "enum": [
        "APPEND_DEFAULT_EXCLUDE_KEYS",
        "CUSTOM_EXCLUDE_KEYS"
      ],
      "type": "string"
    },
    "ResourceAttributesFlattenMode": {
      "enum": [
        "MERGE",
        "OVERWRITE",
        "IGNORE"
      ],
      "type": "string"
    },
    "ResourceChange": {
      "properties": {
        "resource": {
          "$ref": "#/definitions/configv1ResourceType"
        },
        "slug": {
          "type": "string"
        },
        "action": {
          "$ref": "#/definitions/ResourceChangeAction"
        }
      },
      "type": "object"
    },
    "ResourceChangeAction": {
      "enum": [
        "CREATED",
        "UPDATED",
        "DELETED",
        "NOOP"
      ],
      "type": "string"
    },
    "ResourcePoolsDefaultPool": {
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Currently, only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResourcePoolsLicense": {
      "enum": [
        "PERSISTED_WRITES_STANDARD",
        "PERSISTED_WRITES_HISTOGRAM",
        "PERSISTED_CARDINALITY_STANDARD",
        "PERSISTED_CARDINALITY_HISTOGRAM",
        "MATCHED_WRITES_STANDARD",
        "MATCHED_WRITES_HISTOGRAM"
      ],
      "type": "string"
    },
    "ResourcePoolsPool": {
      "properties": {
        "name": {
          "description": "Required name of the pool. Must be unique.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "filters": {
          "description": "Required filters which define which metrics map to this pool, where any\nmetric which matches at least one filter will map to the pool.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        }
      },
      "type": "object"
    },
    "ResourcePoolsPriorities": {
      "properties": {
        "high_priority_filters": {
          "description": "Required filters which define which metrics are high priority, where any\nmetric which matches at least one filter is considered high priority.\nHigh priority metrics are dropped last when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "Required filters which define which metrics are low priority, where any\nmetric which matches at least one filter is considered low priority. Low\npriority metrics are dropped first when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResponderResponderType": {
      "enum": [
        "TEAM",
        "USER",
        "ESCALATION",
        "SCHEDULE"
      ],
      "type": "string"
    },
    "RollupRuleGraphiteLabelPolicy": {
      "properties": {
        "replace": {
          "description": "Required list of labels to replace. Useful for discarding\nhigh-cardinality values while still preserving the original positions of\nthe Graphite metric.",
          "items": {
            "$ref": "#/definitions/GraphiteLabelPolicyReplace"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RollupRuleLabelReplace": {
      "description": "Must keep this around for backwards compatibility because terraform will\nstill send this key w/ a null value.",
      "type": "object"
    },
    "RollupRuleMetricType": {
      "description": " - CUMULATIVE_COUNTER: Alias of COUNTER.\n - DELTA_COUNTER: Alias of DELTA.",
      "enum": [
        "COUNTER",
        "GAUGE",
        "DELTA",
        "DISTRIBUTION",
        "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
        "MEASUREMENT",
        "CUMULATIVE_COUNTER",
        "DELTA_COUNTER",
        "DELTA_EXPONENTIAL_HISTOGRAM"
      ],
      "type": "string"
    },
    "RoutesNotifierList": {
      "properties": {
        "notifier_slugs": {
          "description": "Slugs of notifiers that will receive the alerts.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "repeat_interval_secs": {
          "description": "Frequency at which to resend alerts.",
          "format": "int32",
          "type": "integer"
        },
        "group_by": {
          "$ref": "#/definitions/NotificationPolicyRoutesGroupBy"
        }
      },
      "type": "object"
    },
    "RoutesSeverityNotifiers": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/RoutesNotifierList"
        },
        "critical": {
          "$ref": "#/definitions/RoutesNotifierList"
        }
      },
      "type": "object"
    },
    "SLICustomIndicatorConfig": {
      "description": "Configuration for error ratio SLIs.\nYou can include these variables in PromQL queries for SLIs:\n- {{.Window}}. Specifies the window of time that the PromQL query operates on.\n- {{.GroupBy}}. Specifies a comma-separated list of signal and dimension labels to group the results by.\n- {{.AdditionalFilters}}. Requires setting `additional_promql_filters`.",
      "properties": {
        "good_query_template": {
          "description": "A PromQL query that measures the number of \"good\" events for this SLI.\nEither this or the bad_query_template must be set.",
          "type": "string"
        },
        "bad_query_template": {
          "description": "A PromQL query that measures the number of \"bad\" events for this SLI.\nEither this or the good_query_template must be set.",
          "type": "string"
        },
        "total_query_template": {
          "description": "A PromQL query that measures the total number of events for this SLI.\nThis is required for all error ratio SLOs.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SLICustomTimeSliceIndicatorConfig": {
      "properties": {
        "query_template": {
          "description": "A PromQL query template for the timeslice SLI.",
          "type": "string"
        },
        "timeslice_size": {
          "$ref": "#/definitions/SLITimeSliceSize"
        },
        "condition": {
          "$ref": "#/definitions/SLITimeSliceCondition"
        }
      },
      "title": "Defines the configuration for TimeSlice SLIs.\nTimeSlice SLIs are evaluated by running a PromQL query over a certain time window and comparing the result again a condition.\nYou can include these variables in PromQL queries for SLIs:\n- {{.Window}}. Specifies the window of time that the PromQL query operates on.\n- {{.GroupBy}}. Specifies a comma-separated list of signal and dimension labels to group the results by.\n- {{.TimeSlice}} :The time slice being evaluated, e.g. `1m` or `5m`.\n- {{.AdditionalFilters}}. Requires setting `additional_promql_filters`.",
      "type": "object"
    },
    "SLITimeSliceCondition": {
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "The value to compare against.",
          "format": "double",
          "type": "number"
        }
      },
      "title": "Defines the condition for evaluating TimeSlice SLIs.",
      "type": "object"
    },
    "SLITimeSliceSize": {
      "enum": [
        "TIMESLICE_SIZE_ONE_MINUTE",
        "TIMESLICE_SIZE_FIVE_MINUTES"
      ],
      "title": "Defines the supported time slice sizes for TimeSlice SLIs.",
      "type": "string"
    },
    "SLODefinition": {
      "properties": {
        "objective": {
          "format": "double",
          "type": "number"
        },
        "time_window": {
          "$ref": "#/definitions/DefinitionTimeWindow"
        },
        "burn_rate_alerting_config": {
          "description": "Provides the burn rate alert configuration for the SLO. If not provided the\ndefault burn rates will be used. The configuration is only valid if the\nenable_burn_rate_alerting flag is set to true.",
          "items": {
            "$ref": "#/definitions/DefinitionBurnRateDefinition"
          },
          "type": "array"
        },
        "enable_burn_rate_alerting": {
          "description": "If true enables burn rate alerting.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ScheduleDayActive": {
      "enum": [
        "ALL_DAY",
        "ONLY_DURING_RANGES",
        "NEVER"
      ],
      "type": "string"
    },
    "ScheduleDayTimeRange": {
      "properties": {
        "start_hh_mm": {
          "description": "Start time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        },
        "end_hh_mm": {
          "description": "End time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScheduleScheduleDay": {
      "properties": {
        "active": {
          "$ref": "#/definitions/ScheduleDayActive"
        },
        "ranges": {
          "description": "The time ranges that the monitor is active on this day. Required if `active`\nis set to `ONLY_DURING_RANGES`. Otherwise, this field must be empty.",
          "items": {
            "$ref": "#/definitions/ScheduleDayTimeRange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ScheduleWeeklySchedule": {
      "properties": {
        "monday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "tuesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "wednesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "thursday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "friday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "saturday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "sunday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        }
      },
      "type": "object"
    },
    "SeriesConditionsConditions": {
      "properties": {
        "conditions": {
          "description": "List of conditions to evaluate against a series. Only one condition must\nmatch to assign a severity to a signal.",
          "items": {
            "$ref": "#/definitions/MonitorCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SeriesConditionsSeverityConditions": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        },
        "critical": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        }
      },
      "type": "object"
    },
    "ServiceAccountMetricsRestriction": {
      "properties": {
        "permission": {
          "$ref": "#/definitions/MetricsRestrictionPermission"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels which further restricts the service account to only read\nor write metrics with the given label names and values.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SlackConfigConfirmationField": {
      "properties": {
        "text": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "ok_text": {
          "type": "string"
        },
        "dismiss_text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SlackConfigField": {
      "properties": {
        "title": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "short": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "TraceBehaviorConfigMainBehaviorAssignment": {
      "properties": {
        "created_at": {
          "description": "The timestamp of when the trace behavior was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the trace behavior was updated.",
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the behavior assignment.",
          "type": "string"
        },
        "description": {
          "description": "A description of the behavior assignment.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigOverrideBehaviorAssignment": {
      "properties": {
        "created_at": {
          "description": "The timestamp of when the override behavior assignment was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the override behavior assignment was updated.",
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "start_time": {
          "description": "The starting time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "end_time": {
          "description": "The ending time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the override.",
          "type": "string"
        },
        "description": {
          "description": "A description of the override.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorErrorSampleOptions": {
      "properties": {
        "sample_rate": {
          "description": "Specifies the sample rate for traces with errors.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for error traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorFastSampleOptions": {
      "properties": {
        "max_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for fast traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorLargeTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "Defines the sampling rate for large traces. If the number of spans in the\ntrace is grater than or equal to (`\u003e=`) the `span_count_threshold`, the trace\nis sampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for large traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSamplingType": {
      "description": " - LOW_VALUE: Match indicates a low value trace. With multiple low value matches sample at the lowest rate.\n - HIGH_VALUE: Match indicates a high value trace. With multiple high value matches sample at the highest rate.",
      "enum": [
        "LOW_VALUE",
        "HIGH_VALUE"
      ],
      "type": "string"
    },
    "TraceBehaviorSlowSampleOptions": {
      "properties": {
        "min_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for slow traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSmallTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "Defines the sampling rate for small traces. If the number of spans in the\ntrace is less than or equal to (`\u003c=`) the `span_count_threshold`, the trace is\nsampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for small traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range `[0, 1]`) when\nspecific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the\ndefault sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range `[0, 1]` that defines the percentage probability of\nsampling any trace, where `0` is zero percent and `1` equals 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate span.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        },
        "is_root_span": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "string"
        },
        "in_values": {
          "description": "Values the filter tests against when using `IN` or `NOT_IN` match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key or name of the span tag that this filter inspects.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "WebhookActionHTTPMethod": {
      "enum": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "HEAD",
        "OPTIONS"
      ],
      "type": "string"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/commonPromQLMatcherType"
        },
        "name": {
          "description": "Prometheus label name for the matcher",
          "type": "string"
        },
        "value": {
          "description": "Prometheus label value for the matcher",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcherType": {
      "enum": [
        "MatchEqual",
        "MatchRegexp",
        "MatchNotEqual",
        "MatchNotRegexp"
      ],
      "type": "string"
    },
    "configv1AggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX",
        "MEAN",
        "MEDIAN",
        "COUNT",
        "SUM",
        "SUMSQ",
        "STDEV",
        "P10",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "P90",
        "P95",
        "P99",
        "P999",
        "P9999",
        "P25",
        "P75",
        "COUNT_SAMPLES",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "configv1Bucket": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Bucket. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Bucket is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Bucket. You can modify this value after the Bucket is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Bucket was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Bucket was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional description of the bucket.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels marking the bucket.",
          "type": "object"
        },
        "team_slug": {
          "description": "Optional slug of the team the bucket belongs to.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this bucket.\nThis is optional if the bucket does not contain monitors or all of its monitors explicitly reference a policy.\nThis policy takes precedence over a bucket-owned notification policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Collection": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Collection. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Collection is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Collection. You can modify this value after the Collection is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Collection was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Collection was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReference": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1CollectionReferenceType"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReferenceType": {
      "description": "Type values must match entitiespb.Collection.CollectionType.",
      "enum": [
        "SIMPLE",
        "SERVICE"
      ],
      "type": "string"
    },
    "configv1CreateBucketRequest": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "dry_run": {
          "description": "If `true`, the Bucket isn't created, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardRequest": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If `true`, the GrafanaDashboard isn't created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionRequest": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "dry_run": {
          "description": "If `true`, the Collection isn't created, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "dry_run": {
          "description": "If `true`, the Dashboard isn't created, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetRequest": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "dry_run": {
          "description": "If `true`, the Dataset isn't created, and no response Dataset will be returned. The response will return an error if the given Dataset is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelRequest": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "dry_run": {
          "description": "If `true`, the DerivedLabel isn't created, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricRequest": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "dry_run": {
          "description": "If `true`, the DerivedMetric isn't created, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleRequest": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "dry_run": {
          "description": "If `true`, the DropRule isn't created, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationRequest": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "dry_run": {
          "description": "If `true`, the GcpMetricsIntegration isn't created, and no response GcpMetricsIntegration will be returned. The response will return an error if the given GcpMetricsIntegration is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardRequest": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If `true`, the GrafanaDashboard isn't created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "dry_run": {
          "description": "If `true`, the LogAllocationConfig isn't created, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigRequest": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        },
        "dry_run": {
          "description": "If `true`, the LogIngestConfig isn't created, and no response LogIngestConfig will be returned. The response will return an error if the given LogIngestConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionRequest": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "dry_run": {
          "description": "If `true`, the LogScaleAction isn't created, and no response LogScaleAction will be returned. The response will return an error if the given LogScaleAction is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertRequest": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "dry_run": {
          "description": "If `true`, the LogScaleAlert isn't created, and no response LogScaleAlert will be returned. The response will return an error if the given LogScaleAlert is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleRequest": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "dry_run": {
          "description": "If `true`, the MappingRule isn't created, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorRequest": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "dry_run": {
          "description": "If `true`, the Monitor isn't created, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleRequest": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "dry_run": {
          "description": "If `true`, the MutingRule isn't created, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyRequest": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "dry_run": {
          "description": "If `true`, the NotificationPolicy isn't created, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierRequest": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "dry_run": {
          "description": "If `true`, the Notifier isn't created, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "dry_run": {
          "description": "If `true`, the OtelMetricsIngestion isn't created, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleRequest": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "dry_run": {
          "description": "If `true`, the RecordingRule isn't created, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "dry_run": {
          "description": "If `true`, the ResourcePools isn't created, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleRequest": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "dry_run": {
          "description": "If `true`, the RollupRule isn't created, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1CreateSLORequest": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        },
        "dry_run": {
          "description": "If `true`, the SLO isn't created, and no response SLO will be returned. The response will return an error if the given SLO is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountRequest": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        },
        "dry_run": {
          "description": "If `true`, the ServiceAccount isn't created, and no response ServiceAccount will be returned. The response will return an error if the given ServiceAccount is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamRequest": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "dry_run": {
          "description": "If `true`, the Team isn't created, and no response Team will be returned. The response will return an error if the given Team is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "dry_run": {
          "description": "If `true`, the TraceBehaviorConfig isn't created, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorRequest": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "dry_run": {
          "description": "If `true`, the TraceBehavior isn't created, and no response TraceBehavior will be returned. The response will return an error if the given TraceBehavior is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy isn't created, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleRequest": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "dry_run": {
          "description": "If `true`, the TraceMetricsRule isn't created, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If `true`, the TraceTailSamplingRules isn't created, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1Dashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Dashboard. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Dashboard. You can modify this value after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Optional. Slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Raw JSON representation that defines the structure of the dashboard.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Defines tags that add metadata about the dashboard.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1Dataset": {
      "properties": {
        "name": {
          "description": "Name of the Dataset. You can modify this value after the Dataset is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the Dataset. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Dataset is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dataset was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dataset was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Required. Description of the dataset.",
          "type": "string"
        },
        "configuration": {
          "$ref": "#/definitions/DatasetDatasetConfiguration"
        }
      },
      "type": "object"
    },
    "configv1DefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Determines whether to override the default sample rate.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1DeleteBucketResponse": {
      "properties": {
        "changes": {
          "description": "Changes contains what resources are deleted. The bucket being deleted will\nalways be included. When force_delete is used, the changelog will include\nall resources that reference the bucket that were deleted.",
          "items": {
            "$ref": "#/definitions/ResourceChange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DeleteClassicDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteCollectionResponse": {
      "type": "object"
    },
    "configv1DeleteDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteDatasetResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedLabelResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedMetricResponse": {
      "type": "object"
    },
    "configv1DeleteDropRuleResponse": {
      "type": "object"
    },
    "configv1DeleteGcpMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteGrafanaDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteLogAllocationConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogIngestConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleActionResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleAlertResponse": {
      "type": "object"
    },
    "configv1DeleteMappingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteMonitorResponse": {
      "type": "object"
    },
    "configv1DeleteMutingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteNotificationPolicyResponse": {
      "type": "object"
    },
    "configv1DeleteNotifierResponse": {
      "type": "object"
    },
    "configv1DeleteOtelMetricsIngestionResponse": {
      "type": "object"
    },
    "configv1DeleteRecordingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteResourcePoolsResponse": {
      "type": "object"
    },
    "configv1DeleteRollupRuleResponse": {
      "type": "object"
    },
    "configv1DeleteSLOResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAccountResponse": {
      "type": "object"
    },
    "configv1DeleteTeamResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorConfigResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorResponse": {
      "type": "object"
    },
    "configv1DeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configv1DeleteTraceMetricsRuleResponse": {
      "type": "object"
    },
    "configv1DeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configv1DerivedLabel": {
      "properties": {
        "name": {
          "description": "Name of the DerivedLabel. You can modify this value after the DerivedLabel is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedLabel. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the DerivedLabel is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedLabel was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedLabel was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_name": {
          "description": "Name of the derived label. It needs to be unique across the system.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived label.",
          "type": "string"
        },
        "metric_label": {
          "$ref": "#/definitions/DerivedLabelMetricLabel"
        },
        "existing_label_policy": {
          "$ref": "#/definitions/configv1DerivedLabelLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1DerivedLabelLabelPolicy": {
      "enum": [
        "KEEP",
        "OVERRIDE"
      ],
      "type": "string"
    },
    "configv1DerivedMetric": {
      "properties": {
        "name": {
          "description": "Name of the DerivedMetric. You can modify this value after the DerivedMetric is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedMetric. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the DerivedMetric is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedMetric was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedMetric was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "Required metric name of the derived metric, which must be unique across the system.",
          "example": "cpu_usage:instance",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived metric.",
          "type": "string"
        },
        "queries": {
          "description": "Required queries that the derived metric can map to.",
          "items": {
            "$ref": "#/definitions/DerivedMetricSelectorQuery"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1DerivedMetricLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcherMatcherType": {
      "enum": [
        "EXACT"
      ],
      "type": "string"
    },
    "configv1DropRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the DropRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the DropRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the DropRule. You can modify this value after the DropRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DropRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DropRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/configv1DropRuleMode"
        },
        "filters": {
          "description": "Defines the conditions that determine whether to drop a metric. Drop rules can\nhave multiple filter conditions on different labels, making it possible to drop\na subset of the series matching a particular metric name.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "conditional_rate_based_drop": {
          "$ref": "#/definitions/DropRuleConditionalRateBasedDrop"
        },
        "value_based_drop": {
          "$ref": "#/definitions/DropRuleValueBasedDrop"
        },
        "drop_nan_value": {
          "description": "Drops data points if values are Not a Number (NaN). If set to true, Chronosphere\ndrops NaN data points, along with any published staleness markers. See the\n[drop rules\ndocumentation](https://docs.chronosphere.io/control/shaping/rules/drop-rules#define-a-value-based-drop-rule)\nfor more information.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1DropRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "configv1GcpMetricsIntegration": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the GcpMetricsIntegration. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the GcpMetricsIntegration. You can modify this value after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_account": {
          "$ref": "#/definitions/configv1GcpMetricsIntegrationServiceAccount"
        },
        "metric_groups": {
          "description": "Metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/GcpMetricsIntegrationMetricGroup"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1GcpMetricsIntegrationServiceAccount": {
      "properties": {
        "client_email": {
          "description": "Email address of the service account to impersonate.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1GrafanaDashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the GrafanaDashboard. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the GrafanaDashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the GrafanaDashboard. You can modify this value after the GrafanaDashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GrafanaDashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GrafanaDashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the dashboard belongs to. Required if collection_slug\nis not set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the dashboard belongs to. Required if bucket_slug\nis not set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the Grafana dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelFilter": {
      "properties": {
        "name": {
          "description": "Name of the label to match.",
          "example": "job",
          "type": "string"
        },
        "value_glob": {
          "description": "Glob value of the label to match.",
          "example": "myservice*",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1LabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX"
      ],
      "type": "string"
    },
    "configv1ListBucketsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "buckets": {
          "items": {
            "$ref": "#/definitions/configv1Bucket"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListClassicDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "classic_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListCollectionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "collections": {
          "items": {
            "$ref": "#/definitions/configv1Collection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configv1Dashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDatasetsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "datasets": {
          "items": {
            "$ref": "#/definitions/configv1Dataset"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedLabelsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_labels": {
          "items": {
            "$ref": "#/definitions/configv1DerivedLabel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedMetricsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_metrics": {
          "items": {
            "$ref": "#/definitions/configv1DerivedMetric"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDropRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "drop_rules": {
          "items": {
            "$ref": "#/definitions/configv1DropRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGcpMetricsIntegrationsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "gcp_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1GcpMetricsIntegration"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGrafanaDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "grafana_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleActionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_actions": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleAlertsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_alerts": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAlert"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMappingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "mapping_rules": {
          "items": {
            "$ref": "#/definitions/configv1MappingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMonitorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "monitors": {
          "items": {
            "$ref": "#/definitions/configv1Monitor"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMutingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "muting_rules": {
          "items": {
            "$ref": "#/definitions/configv1MutingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotificationPoliciesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notification_policies": {
          "items": {
            "$ref": "#/definitions/configv1NotificationPolicy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotifiersResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notifiers": {
          "items": {
            "$ref": "#/definitions/configv1Notifier"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRecordingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "recording_rules": {
          "items": {
            "$ref": "#/definitions/configv1RecordingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRollupRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "rollup_rules": {
          "items": {
            "$ref": "#/definitions/configv1RollupRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListSLOsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "slos": {
          "items": {
            "$ref": "#/definitions/configv1SLO"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAccountsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_accounts": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configv1Service"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTeamsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "teams": {
          "items": {
            "$ref": "#/definitions/configv1Team"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceBehaviorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_behaviors": {
          "items": {
            "$ref": "#/definitions/configv1TraceBehavior"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceMetricsRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_metrics_rules": {
          "description": "Found trace metrics rules.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfig": {
      "description": "LogAllocationConfig is a singleton configuration object that specifies the\nconfiguration for Log budget allocations.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogAllocationConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogAllocationConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_dataset": {
          "$ref": "#/definitions/LogAllocationConfigDefaultDataset"
        },
        "dataset_allocations": {
          "description": "Defines datasets and budget allocations. Datasets are evaluated in order.",
          "items": {
            "$ref": "#/definitions/LogAllocationConfigDatasetAllocation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfigAllocation": {
      "description": "Configuration for allocating resources to a dataset.",
      "properties": {
        "percent_of_license": {
          "description": "Sets the percentage of the license limit to allocate to the default dataset.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1LogDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1LogSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1LogFieldPath": {
      "properties": {
        "selector": {
          "description": "LogQL Selector to indicate field path. Use `parent[child]` syntax to\nindicate nesting.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogIngestConfig": {
      "description": "LogIngestConfig is a singleton configuration object that specifies the configuration for log ingest.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogIngestConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogIngestConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "plaintext_parsers": {
          "description": "The parsers to run on plaintext logs. The first parser that matches the log is used.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigPlaintextParser"
          },
          "type": "array"
        },
        "field_parsers": {
          "description": "The parsers to run on specific fields within structured logs or plaintext logs after parsing.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigLogFieldParser"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAction": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the LogScaleAction. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the LogScaleAction is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of the LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of an action.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAction was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAction was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "action_type": {
          "$ref": "#/definitions/LogScaleActionActionType"
        },
        "email_action": {
          "$ref": "#/definitions/LogScaleActionEmailAction"
        },
        "humio_action": {
          "$ref": "#/definitions/LogScaleActionHumioRepoAction"
        },
        "ops_genie_action": {
          "$ref": "#/definitions/LogScaleActionOpsGenieAction"
        },
        "pager_duty_action": {
          "$ref": "#/definitions/LogScaleActionPagerDutyAction"
        },
        "slack_action": {
          "$ref": "#/definitions/LogScaleActionSlackAction"
        },
        "slack_post_message_action": {
          "$ref": "#/definitions/LogScaleActionSlackPostMessageAction"
        },
        "victor_ops_action": {
          "$ref": "#/definitions/LogScaleActionVictorOpsAction"
        },
        "webhook_action": {
          "$ref": "#/definitions/LogScaleActionWebhookAction"
        },
        "upload_file_action": {
          "$ref": "#/definitions/LogScaleActionUploadFileAction"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAlert": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the LogScaleAlert. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the LogScaleAlert is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of the alert.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAlert was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAlert was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "disabled": {
          "description": "Flag indicating whether the alert is disabled.",
          "type": "boolean"
        },
        "log_scale_query": {
          "description": "LogScale query to execute.",
          "example": "level = ERROR | severity \u003e 3 | count(as=numErrors) | numErrors \u003e 500",
          "type": "string"
        },
        "time_window_secs": {
          "description": "Lookback window used for an alert's evaluation.\nIf this is set to 86400 seconds (24 hours), only the events from the last 24 hours will be considered when the alert query is run.",
          "example": "3600",
          "format": "int32",
          "type": "integer"
        },
        "throttle_secs": {
          "description": "Throttle time in seconds. The alert is triggered at most once per throttle period.",
          "format": "int32",
          "type": "integer"
        },
        "throttle_field": {
          "description": "Field to throttle on. Optional.",
          "type": "string"
        },
        "log_scale_action_slugs": {
          "description": "Slugs of LogScale actions that will receive the alerts. When the value is empty\nthis alert won't trigger. Optional.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tags": {
          "description": "Tags attached to the alert.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "run_as_user": {
          "description": "Email of the user that the alert runs on behalf of. Required.",
          "type": "string"
        },
        "alert_type": {
          "$ref": "#/definitions/LogScaleAlertAlertType"
        }
      },
      "type": "object"
    },
    "configv1LogSearchFilter": {
      "properties": {
        "query": {
          "description": "Returns logs that match this query. The query can include only top-level\noperations. Nested clauses aren't supported. Only one type of `AND` or `OR`\noperator is allowed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MappingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MappingRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the MappingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the MappingRule. You can modify this value after the MappingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MappingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MappingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the MappingRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Required filters that determine to which metrics to apply the rule.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "aggregation_policy": {
          "$ref": "#/definitions/MappingRuleAggregationPolicy"
        },
        "drop": {
          "description": "Whether to drop the given set of metrics. If set, then the aggregation\npolicy can't be set.",
          "type": "boolean"
        },
        "mode": {
          "$ref": "#/definitions/configv1MappingRuleMode"
        }
      },
      "type": "object"
    },
    "configv1MappingRuleMode": {
      "description": " - ENABLED: ENABLED rules are applied. Rules default to ENABLED.\n - PREVIEW: PREVIEW rules are not applied, but shaping impact stats\nfor them rule are recorded.",
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1MappingRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Monitor": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Monitor. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Monitor is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Monitor. You can modify this value after the Monitor is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Monitor was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Monitor was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the monitor belongs to. Required if `collection_slug` isn't\nset.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the monitor belongs to. Required if `bucket_slug` isn't\nset.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Required. Labels to include in notifications generated by this monitor, and can\nbe used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this monitor.\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "series_conditions": {
          "$ref": "#/definitions/MonitorSeriesConditions"
        },
        "notification_policy_slug": {
          "description": "Specifies the notification policy used to route alerts generated by the monitor.\nIf omitted, the notification policy is inherited from the monitor.",
          "type": "string"
        },
        "interval_secs": {
          "description": "Specifies how often alerts are evaluated. Default: `60s`.",
          "format": "int32",
          "type": "integer"
        },
        "prometheus_query": {
          "description": "PromQL query to evaluate for the alert. If set, no other queries can be set.",
          "example": "up{job=\"prometheus\"} == 0",
          "type": "string"
        },
        "graphite_query": {
          "description": "Graphite query to evaluate for the alert. If set, no other queries can be set.",
          "example": "sumSeries(stats.timers.*.mean_90)",
          "type": "string"
        },
        "schedule": {
          "$ref": "#/definitions/MonitorSchedule"
        },
        "logging_query": {
          "description": "Logging query to evaluate for the alert. If set, no other queries can be set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MutingRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the MutingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the MutingRule. You can modify this value after the MutingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MutingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MutingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_matchers": {
          "description": "Required. Specifies which series are silenced by the muting rule. Alerting\nseries must match all muting rule matchers to be silenced. You can't update this\nvalue. Updates must specify the original value.",
          "items": {
            "$ref": "#/definitions/configv1MutingRuleLabelMatcher"
          },
          "type": "array"
        },
        "starts_at": {
          "description": "Required. Timestamp of when the muting rule becomes active. You can't update\nthis value. Updates must specify the original value.",
          "format": "date-time",
          "type": "string"
        },
        "ends_at": {
          "description": "Required. Timestamp of when the muting rule stops being active.",
          "format": "date-time",
          "type": "string"
        },
        "comment": {
          "description": "Descriptive comment that explains why the muting rule was created.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1MutingRuleLabelMatcherMatcherType"
        },
        "name": {
          "description": "Required. Always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "Required. Matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX",
        "NOT_EXACT",
        "NOT_REGEXP"
      ],
      "type": "string"
    },
    "configv1NotificationPolicy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the NotificationPolicy. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the NotificationPolicy is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the NotificationPolicy. You can modify this value after the NotificationPolicy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NotificationPolicy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NotificationPolicy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the notification policy belongs to. Required if\nteam_slug is not set.",
          "type": "string"
        },
        "team_slug": {
          "description": "Slug of the team the notification policy belongs to. Required if\nbucket_slug is not set.",
          "type": "string"
        },
        "routes": {
          "$ref": "#/definitions/NotificationPolicyRoutes"
        }
      },
      "type": "object"
    },
    "configv1Notifier": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Notifier. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Notifier is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Notifier. You can modify this value after the Notifier is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Notifier was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Notifier was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "skip_resolved": {
          "description": "If true, do not notify on resolved alerts. Cannot set if discard is set.",
          "type": "boolean"
        },
        "webhook": {
          "$ref": "#/definitions/NotifierWebhookConfig"
        },
        "slack": {
          "$ref": "#/definitions/NotifierSlackConfig"
        },
        "pagerduty": {
          "$ref": "#/definitions/NotifierPagerdutyConfig"
        },
        "email": {
          "$ref": "#/definitions/NotifierEmailConfig"
        },
        "ops_genie": {
          "$ref": "#/definitions/NotifierOpsGenieConfig"
        },
        "victor_ops": {
          "$ref": "#/definitions/NotifierVictorOpsConfig"
        },
        "discard": {
          "description": "If set, enables the \"discard\" integration which simply discards all\nnotifications. Cannot set if another integration is set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1OtelMetricsIngestion": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource_attributes": {
          "$ref": "#/definitions/OtelMetricsIngestionResourceAttributes"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1ReadClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1ReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1ReadDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1ReadGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1ReadMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1ReadMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1ReadNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1ReadOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1ReadRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1ReadRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1ReadSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configv1Service"
        }
      },
      "type": "object"
    },
    "configv1ReadTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1RecordingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RecordingRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the RecordingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the RecordingRule. You can modify this value after the RecordingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RecordingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RecordingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Optional slug of the bucket the RecordingRule belongs to.",
          "type": "string"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RecordingRuleLabelPolicy"
        },
        "interval_secs": {
          "description": "Optional interval for evaluating the recording rule.",
          "format": "int32",
          "type": "integer"
        },
        "metric_name": {
          "description": "The name of the time series to use for output, which must be a valid\nmetric name.",
          "type": "string"
        },
        "prometheus_expr": {
          "description": "The PromQL expression to evaluate at the time of each evaluation cycle.\nThe result is recorded as a new time series with its metric name\ndefined by the metric_name (or name) field.",
          "type": "string"
        },
        "execution_group": {
          "description": "Optional execution_group in which this rule is to be evaluated.\nAt least one of bucket_slug and execution_group must be set. If both are set, then they are expected to match.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1RecordingRuleLabelPolicy": {
      "properties": {
        "add": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to add or overwrite before storing the result.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1ResourcePools": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ResourcePools was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ResourcePools was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_pool": {
          "$ref": "#/definitions/ResourcePoolsDefaultPool"
        },
        "pools": {
          "description": "Optional pools. Cannot set more than 20 pools.",
          "items": {
            "$ref": "#/definitions/ResourcePoolsPool"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourcePoolsAllocation": {
      "properties": {
        "percent_of_license": {
          "description": "Percent of the license to allocate to this pool. Must be between 0\nand 100 inclusive. The percent_of_license values across all pools\n(excluding the default pool) must be \u003c= 100. default_pool need not specify\nan allocation, and implicitly receives any remaining allocation. If default_pool does\nexplicitly specify an allocation, the sum of percent_of_license across all pools\n(including the default pool) must exactly equal 100.",
          "format": "double",
          "type": "number"
        },
        "fixed_values": {
          "description": "Fixed values optionally override `percent_of_license` allocations for specified licenses.\nWhen defining fixed values for a license, all pools must have an explicit fixed value\nspecification for that given license. The default pool receives all remaining quota left\nwithin the license, after subtracting the sum of fixed values across pools for that license.",
          "items": {
            "$ref": "#/definitions/AllocationFixedValue"
          },
          "type": "array"
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Currently, only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourceType": {
      "enum": [
        "BUCKET",
        "DASHBOARD",
        "GRAFANA_DASHBOARD",
        "MONITOR",
        "NOTIFICATION_POLICY",
        "RECORDING_RULE",
        "MAPPING_RULE",
        "ROLLUP_RULE"
      ],
      "type": "string"
    },
    "configv1RollupRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RollupRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the RollupRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the RollupRule. You can modify this value after the RollupRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RollupRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RollupRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the RollupRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Filters incoming metrics by label. If multiple label filters are specified, an\nincoming metric must match every label filter to match the rule. Label values\nsupport glob patterns, including matching multiple patterns with an `OR`, such\nas `service:{svc1,svc2}`. These special filters are available for matching\nmetrics by non-label request metadata:\n * `__metric_type__`: Matches the incoming metric's [Observability Platform\n   metric\n   type](https://docs.chronosphere.io/control/shaping/types#observability-platform-types).\n   This is the recommended method for filtering on metric type. Valid values:\n   `cumulative_counter`, `cumulative_exponential_histogram`, `delta_counter`,\n   `delta_exponential_histogram`, `gauge`, `measurement`.\n * `__metric_source__`: Matches the incoming metric's [source\n   format](https://docs.chronosphere.io/control/shaping/types#supported-formats).\n   Valid values: `carbon`, `chrono_gcp`, `dogstatsd`, `open_metrics`,\n   `open_telemetry`, `prometheus`, `signalfx`, `statsd`, `wavefront`.\n * `__m3_prom_type__`: When ingesting with Prometheus, matches the incoming\n   metric's [Prometheus metric\n   type](https://docs.chronosphere.io/control/shaping/types#prometheus). Valid\n   values: `counter`, `gauge`, `histogram`, `gauge_histogram`, `summary`,\n   `info`, `state_set`, `quantile`.\n * `__otel_type__`: When ingesting with OpenTelemetry, matches on the incoming\n   metric's [OpenTelemetry metric type](https://docs.chronosphere.io/control/shaping/types#opentelemetry).\n   Valid values: `sum`, `monotonic_sum`, `gauge`, `histogram`, `exp_histogram`,\n   `summary`.\nFor example, the following filter matches any cumulative counter metric with a\n`service=gateway` label whose metric name starts with `http_requests_`:\n```\n__metric_type__:cumulative_counter service:gateway __name__:http_requests_*\n```",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "metric_name": {
          "description": "This field is optional for Graphite rollup rules.",
          "type": "string"
        },
        "metric_type": {
          "$ref": "#/definitions/RollupRuleMetricType"
        },
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1RollupRuleStoragePolicy"
        },
        "interval": {
          "description": "The distance in time between aggregated data points. Intervals are based on your\n[retention policy](https://docs.chronosphere.io/administer/licensing#retention-policies).\nUse this optional field to set a custom interval.\nThis field was known as `storage_policies` in version\n0.286.0-2023-01-06-release.1 and earlier.",
          "type": "string"
        },
        "expansive_match": {
          "description": "DEPRECATED.\nA series matches and aggregates only if each label defined by filters and\n`label_policy.keep` or `graphite_label_policy.replace` (respectively) exist in\nthe series. Setting `expansive_match=true` removes this restriction. Default:\n`expansive_match=false`.\n\nIf `false`, a series matches and aggregates only if each label defined by the\nprovided `filters` and the `label_policy.keep` or\n`graphite_label_policy.replace` settings exist in the series.",
          "type": "boolean"
        },
        "add_metric_type_label": {
          "description": "Defines whether to add a `__rollup_type__` label in the new metric.",
          "type": "boolean"
        },
        "drop_raw": {
          "description": "Defines whether to automatically generate drop rules for this rollup rule.\nSet to `true` to remove raw metrics that match this rollup rule. Default: `false`.",
          "type": "boolean"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RollupRuleLabelPolicy"
        },
        "label_replace": {
          "$ref": "#/definitions/RollupRuleLabelReplace"
        },
        "mode": {
          "$ref": "#/definitions/configv1RollupRuleMode"
        },
        "graphite_label_policy": {
          "$ref": "#/definitions/RollupRuleGraphiteLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleLabelPolicy": {
      "description": "TODO: consolidate w/ RecordingRule.LabelPolicy once both of these\n entities implement the same label semantics.",
      "properties": {
        "keep": {
          "description": "Labels that should be retained in the output metric. If set, then the\ndiscard field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "discard": {
          "description": "Labels that should be discarded in the output metric. If set, then the\nkeep field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleMode": {
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "title": "- PREVIEW: TODO: DISABLED = 2;",
      "type": "string"
    },
    "configv1RollupRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1SLI": {
      "properties": {
        "custom_indicator": {
          "$ref": "#/definitions/SLICustomIndicatorConfig"
        },
        "custom_timeslice_indicator": {
          "$ref": "#/definitions/SLICustomTimeSliceIndicatorConfig"
        },
        "custom_dimension_labels": {
          "description": "Used to configure additional labels to export from\nthe underlying queries. This feature provides a logical budget to group\nunique combination of dimensions. For example, if you want to track a\nbudget per endpoint, add the endpoint label as a dimension. These dimensions\nare provided on the top-level SLI so that SLOs will receive them\nin `.GroupBy`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "additional_promql_filters": {
          "description": "These are made available to the SLO queries and are intended to be used for things\nlike `cluster!~\"dev\"`",
          "items": {
            "$ref": "#/definitions/commonPromQLMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1SLO": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the SLO. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the SLO is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the SLO. You can modify this value after the SLO is created.",
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the SLO was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SLO was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_ref": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "notification_policy_slug": {
          "description": "Optional notification policy to explicitly apply to the generated monitors.\nSlug of the notification policy to use for the SLO. If you don't specify a value,\nthen the collection or service this SLO belongs to must have a notification\npolicy.",
          "type": "string"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are visible in notifications generated by this SLO,\nand can be used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this SLO\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "sli": {
          "$ref": "#/definitions/configv1SLI"
        },
        "definition": {
          "$ref": "#/definitions/SLODefinition"
        }
      },
      "type": "object"
    },
    "configv1Service": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Service. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Service. You can modify this value after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ServiceAccount": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the ServiceAccount. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the ServiceAccount is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the ServiceAccount. You can modify this value after the ServiceAccount is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ServiceAccount was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ServiceAccount was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "token": {
          "description": "token is the generated API token of the service account. Cannot be set by\nclients.\n\ntoken is only set once by the server in the CreateServiceAccount response.\nReadServiceAccount will always return an empty token. Therefore, when\ncreating a service account, clients are responsible for securely storing\nthe response token on their end, as they will not be able to read it\nagain.",
          "readOnly": true,
          "type": "string"
        },
        "email": {
          "description": "email is the generated email address of the service account. Cannot be set\nby clients.",
          "readOnly": true,
          "type": "string"
        },
        "unrestricted": {
          "description": "If set, grants the service account access to all Chronosphere APIs\n(including resource configuration and metric data) within the access\ncontrols defined by the service account's team membership.\n\nExactly one of unrestricted or metrics_restriction must be set.",
          "type": "boolean"
        },
        "metrics_restriction": {
          "$ref": "#/definitions/ServiceAccountMetricsRestriction"
        }
      },
      "type": "object"
    },
    "configv1Team": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Team. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the Team is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the Team. You can modify this value after the Team is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Team was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Team was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "user_emails": {
          "description": "Unordered set of emails whose users are members of this team.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "description": {
          "description": "Optional short description of the team.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceBehavior": {
      "properties": {
        "name": {
          "description": "Name of the TraceBehavior. You can modify this value after the TraceBehavior is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceBehavior. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the TraceBehavior is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehavior was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehavior was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "base_tail_sample_rate": {
          "description": "Specifies the base sample rate for fully assembled traces that don't apply to\nthe `error_sample_options`, `fast_sample_options`, `slow_sample_options`,\n`large_trace_sample_options`, or `small_trace_sample_options` sampling options.",
          "format": "double",
          "type": "number"
        },
        "base_head_sample_rate": {
          "description": "Specifies the sample rate for head sampling. This rate applies to all root spans\nthat are enrolled in head sampling, but don't have a specific rule defined for\ntheir service.",
          "format": "double",
          "type": "number"
        },
        "error_sample_options": {
          "$ref": "#/definitions/TraceBehaviorErrorSampleOptions"
        },
        "fast_sample_options": {
          "$ref": "#/definitions/TraceBehaviorFastSampleOptions"
        },
        "slow_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSlowSampleOptions"
        },
        "large_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorLargeTraceSampleOptions"
        },
        "small_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSmallTraceSampleOptions"
        }
      },
      "type": "object"
    },
    "configv1TraceBehaviorConfig": {
      "description": "TraceBehaviorConfig is a singleton configuration object that specifies the\nconfiguration for trace behaviors.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "main_behavior_assignments": {
          "description": "List of assignments for the main behavior. The referenced datasets will be\nenrolled in behaviors. The referenced behaviors are the active behaviors for the\ndataset when there is no active override. Only one main behavior can be assigned\nto a dataset. See the documentation for\n[customizing your sampling\nstrategy](https://docs.chronosphere.io/control/sampling/behaviors#customize-your-sampling-strategy)\nfor more information.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigMainBehaviorAssignment"
          },
          "type": "array"
        },
        "override_behavior_assignments": {
          "description": "List of assignments for the override behavior. These assignments specify the\nactive behavior for a dataset over a specific time range. Only one override\nbehavior can be assigned to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "dataset_priorities": {
          "description": "List of dataset priorities. This list specifies the order in which datasets are\nconsidered when determining the behavior to follow for a trace. Dataset\npriorities are used to break ties when a trace matches more than one dataset\nwith an active behavior.\n* Each entry in this list must refer to the slug of an existing dataset.\n* The order of the list is the order in which the datasets are considered.\n* The list must contain all datasets referenced in either\n  `main_behavior_assignments` or `override_behavior_assignments`.\n* The list can contain datasets that are not referenced in either of these\n  assignments.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "baseline_behavior_slug": {
          "description": "The baseline behavior to use for behavior assignments and base head sampling rates.",
          "type": "string"
        },
        "preview_behavior_assignments": {
          "description": "List of assignments for the preview behavior. The referenced behaviors are in\npreview mode for the assigned dataset. You can assign only one preview behavior\nto a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1TraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the TraceJaegerRemoteSamplingStrategy. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "Name of the TraceJaegerRemoteSamplingStrategy. You can modify this value after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This value must match\nthe `slug` and `name` fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRule": {
      "properties": {
        "name": {
          "description": "Name of the TraceMetricsRule. You can modify this value after the TraceMetricsRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceMetricsRule. If a `slug` isn't provided, one will be generated based of the `name` field. You can't modify this field after the TraceMetricsRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceMetricsRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceMetricsRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "The name of the generated trace metrics.",
          "type": "string"
        },
        "metric_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to apply to the generated trace metrics.",
          "type": "object"
        },
        "histogram_buckets_secs": {
          "description": "Histogram bucket values, in seconds, for generated duration metrics.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "trace_filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "group_by": {
          "description": "Add labels to the resultant metrics based on the specified key:value pairs.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRuleGroupBy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRuleGroupBy": {
      "description": "GroupBy contains fields required to group the resultant metrics of a TraceMetricsRule by a specific key.",
      "properties": {
        "label": {
          "description": "The label to use in the resulting metrics.",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/GroupByGroupByKey"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Specifies the span conditions to match on. All conditions must be true in a\nsingle span for the span to be considered a match. If `span_count` is specified,\nthe number of spans within the trace that match span conditions must be within\n`[min, max]`. You can specify multiple span conditions, and each can be\nsatisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule.",
          "type": "string"
        },
        "system_name": {
          "description": "Name used as the metric label value for metrics that are emitted from this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. Specifies a list of rules and a sampling rate to apply. Rules are\nevaluated in order until a match is found. If no sample rate is specified, the\ndefault sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configv1TraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configv1DefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configv1UpdateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1UpdateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1UpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1UpdateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1UpdateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogAllocationConfig will be created if it does not already exist. If `false`, an error will be returned if the LogAllocationConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LogAllocationConfig isn't created or updated, and no response LogAllocationConfig will be returned. The response will return an error if the given LogAllocationConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigRequest": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogIngestConfig will be created if it does not already exist. If `false`, an error will be returned if the LogIngestConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the LogIngestConfig isn't created or updated, and no response LogIngestConfig will be returned. The response will return an error if the given LogIngestConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1UpdateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1UpdateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "create_if_missing": {
          "description": "If `true`, the OtelMetricsIngestion will be created if it does not already exist. If `false`, an error will be returned if the OtelMetricsIngestion does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the OtelMetricsIngestion isn't created or updated, and no response OtelMetricsIngestion will be returned. The response will return an error if the given OtelMetricsIngestion is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1UpdateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "create_if_missing": {
          "description": "If `true`, the ResourcePools will be created if it does not already exist. If `false`, an error will be returned if the ResourcePools does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the ResourcePools isn't created or updated, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1UpdateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1UpdateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceBehaviorConfig will be created if it does not already exist. If `false`, an error will be returned if the TraceBehaviorConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceBehaviorConfig isn't created or updated, and no response TraceBehaviorConfig will be returned. The response will return an error if the given TraceBehaviorConfig is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceTailSamplingRules will be created if it does not already exist. If `false`, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, the TraceTailSamplingRules isn't created or updated, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\nThe Config API provides standard HTTP/JSON REST endpoints for creating, reading,\nupdating, deleting, and listing configurable Chronosphere resources.\n\nUse this link to download the raw Swagger specification:\n\u003ca href=\"/api/v1/config/swagger.json\"\u003e/api/v1/config/swagger.json\u003c/a\u003e\n",
    "title": "Config V1 API",
    "version": "v1"
  },
  "paths": {
    "/api/v1/config/buckets": {
      "get": {
        "operationId": "ListBuckets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Bucket with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Bucket with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListBucketsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "post": {
        "operationId": "CreateBucket",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot create the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/buckets/{slug}": {
      "delete": {
        "operationId": "DeleteBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "description": "force_delete indicates deletion of the bucket and all resources that reference the bucket.\nThis includes monitors, dashboards, notification policies, recording rules, and alerts.",
            "in": "query",
            "name": "force_delete",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteBucketResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Bucket because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "get": {
        "operationId": "ReadBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadBucketResponse"
            }
          },
          "404": {
            "description": "Cannot read the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "put": {
        "operationId": "UpdateBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateBucketBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot update the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/classic-dashboards": {
      "get": {
        "operationId": "ListClassicDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ClassicDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any ClassicDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any ClassicDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ClassicDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListClassicDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "post": {
        "operationId": "CreateClassicDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/classic-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "get": {
        "operationId": "ReadClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadClassicDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateClassicDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/collections": {
      "get": {
        "operationId": "ListCollections",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Collection with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Collection with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Collection with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get collections that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListCollectionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "post": {
        "operationId": "CreateCollection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Collection.",
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot create the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/collections/{slug}": {
      "delete": {
        "operationId": "DeleteCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Collection because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "get": {
        "operationId": "ReadCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadCollectionResponse"
            }
          },
          "404": {
            "description": "Cannot read the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "put": {
        "operationId": "UpdateCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateCollectionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Collection.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot update the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional. Flag to populate the `dashboard_json` field of the returned\ndashboards. By default, `dashboard_json` is empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/datasets": {
      "get": {
        "operationId": "ListDatasets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dataset with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dataset with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Custom filtering option: list filtered down to a specific telemetry type.",
            "enum": [
              "TRACES",
              "LOGS"
            ],
            "in": "query",
            "name": "type",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDatasetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "post": {
        "operationId": "CreateDataset",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/datasets/{slug}": {
      "delete": {
        "operationId": "DeleteDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dataset because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "get": {
        "operationId": "ReadDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDatasetResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "put": {
        "operationId": "UpdateDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDatasetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/derived-labels": {
      "get": {
        "operationId": "ListDerivedLabels",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedLabel with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedLabel with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedLabelsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "post": {
        "operationId": "CreateDerivedLabel",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-labels/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedLabel because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "get": {
        "operationId": "ReadDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedLabelResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedLabelBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-metrics": {
      "get": {
        "operationId": "ListDerivedMetrics",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedMetric with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedMetric with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedMetricsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "post": {
        "operationId": "CreateDerivedMetric",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/derived-metrics/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedMetric because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "get": {
        "operationId": "ReadDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedMetricResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedMetricBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/drop-rules": {
      "get": {
        "operationId": "ListDropRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DropRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DropRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDropRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "post": {
        "operationId": "CreateDropRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/drop-rules/{slug}": {
      "delete": {
        "operationId": "DeleteDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DropRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "get": {
        "operationId": "ReadDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDropRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "put": {
        "operationId": "UpdateDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDropRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations": {
      "get": {
        "operationId": "ListGcpMetricsIntegrations",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GcpMetricsIntegration with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GcpMetricsIntegration with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGcpMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GcpMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGcpMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGcpMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards": {
      "get": {
        "operationId": "ListGrafanaDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GrafanaDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any GrafanaDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any GrafanaDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GrafanaDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGrafanaDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "post": {
        "operationId": "CreateGrafanaDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "get": {
        "operationId": "ReadGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGrafanaDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGrafanaDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/log-allocation-config": {
      "delete": {
        "operationId": "DeleteLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogAllocationConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogAllocationConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogAllocationConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogAllocationConfig because there is a conflict with an existing LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      }
    },
    "/api/v1/config/log-ingest-config": {
      "delete": {
        "operationId": "DeleteLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogIngestConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogIngestConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogIngestConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogIngestConfig because there is a conflict with an existing LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      }
    },
    "/api/v1/config/log-scale-actions": {
      "get": {
        "operationId": "ListLogScaleActions",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAction with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAction with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleActionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAction",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-actions/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAction because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleActionResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleActionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts": {
      "get": {
        "operationId": "ListLogScaleAlerts",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAlert with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAlert with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleAlertsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAlert",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAlert because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleAlertResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleAlertBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/mapping-rules": {
      "get": {
        "operationId": "ListMappingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MappingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any MappingRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MappingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMappingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "post": {
        "operationId": "CreateMappingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/mapping-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MappingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "get": {
        "operationId": "ReadMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMappingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMappingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/monitors": {
      "get": {
        "operationId": "ListMonitors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Monitor with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any Monitor with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Monitor with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Monitor with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter returned monitors by the teams that own the collections that they belong to.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMonitorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "CreateMonitor",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot create the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/monitors/{slug}": {
      "delete": {
        "operationId": "DeleteMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Monitor because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "get": {
        "operationId": "ReadMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMonitorResponse"
            }
          },
          "404": {
            "description": "Cannot read the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "operationId": "UpdateMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMonitorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot update the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/muting-rules": {
      "get": {
        "operationId": "ListMutingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MutingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MutingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Lists muting rules filtered by the states. If empty, all muting rules are\nincluded.",
            "in": "query",
            "items": {
              "enum": [
                "PENDING",
                "ACTIVE",
                "EXPIRED"
              ],
              "type": "string"
            },
            "name": "states",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMutingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "post": {
        "operationId": "CreateMutingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/muting-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MutingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "get": {
        "operationId": "ReadMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMutingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMutingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/notification-policies": {
      "get": {
        "operationId": "ListNotificationPolicies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any NotificationPolicy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any NotificationPolicy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any NotificationPolicy with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any NotificationPolicy with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotificationPoliciesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "post": {
        "operationId": "CreateNotificationPolicy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot create the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notification-policies/{slug}": {
      "delete": {
        "operationId": "DeleteNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NotificationPolicy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "get": {
        "operationId": "ReadNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotificationPolicyResponse"
            }
          },
          "404": {
            "description": "Cannot read the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "put": {
        "operationId": "UpdateNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotificationPolicyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot update the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notifiers": {
      "get": {
        "operationId": "ListNotifiers",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Notifier with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Notifier with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotifiersResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "post": {
        "operationId": "CreateNotifier",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot create the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/notifiers/{slug}": {
      "delete": {
        "operationId": "DeleteNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Notifier because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "get": {
        "operationId": "ReadNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotifierResponse"
            }
          },
          "404": {
            "description": "Cannot read the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "put": {
        "operationId": "UpdateNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotifierBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot update the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/otel-metrics-ingestion": {
      "delete": {
        "operationId": "DeleteOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the OtelMetricsIngestion because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the OtelMetricsIngestion because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "get": {
        "operationId": "ReadOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadOtelMetricsIngestionResponse"
            }
          },
          "404": {
            "description": "Cannot read the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "post": {
        "operationId": "CreateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot create the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the OtelMetricsIngestion because there is a conflict with an existing OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "put": {
        "operationId": "UpdateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot update the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      }
    },
    "/api/v1/config/recording-rules": {
      "get": {
        "operationId": "ListRecordingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RecordingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RecordingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The execution_groups filter cannot be used when a bucket_slug filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The bucket_slugs filter cannot be used when an execution_group filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "execution_groups",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRecordingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "post": {
        "operationId": "CreateRecordingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/recording-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RecordingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "get": {
        "operationId": "ReadRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRecordingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "put": {
        "operationId": "UpdateRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRecordingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/resource-pools": {
      "delete": {
        "operationId": "DeleteResourcePools",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ResourcePools because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ResourcePools because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "get": {
        "operationId": "ReadResourcePools",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadResourcePoolsResponse"
            }
          },
          "404": {
            "description": "Cannot read the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "post": {
        "description": "ResourcePools CRUD (subset for singleton objects)",
        "operationId": "CreateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot create the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ResourcePools because there is a conflict with an existing ResourcePools.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "put": {
        "operationId": "UpdateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot update the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      }
    },
    "/api/v1/config/rollup-rules": {
      "get": {
        "operationId": "ListRollupRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RollupRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RollupRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any RollupRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRollupRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "post": {
        "operationId": "CreateRollupRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/rollup-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RollupRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "get": {
        "operationId": "ReadRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRollupRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "put": {
        "operationId": "UpdateRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRollupRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/service-accounts": {
      "get": {
        "operationId": "ListServiceAccounts",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ServiceAccount with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ServiceAccount with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAccountsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "post": {
        "operationId": "CreateServiceAccount",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot create the ServiceAccount because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ServiceAccount because there is a conflict with an existing ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-accounts/{slug}": {
      "delete": {
        "operationId": "DeleteServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ServiceAccount because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "get": {
        "operationId": "ReadServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAccountResponse"
            }
          },
          "404": {
            "description": "Cannot read the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Service with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Service with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by notification_policy_slug, where any Service with a matching notification_policy_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/services/{slug}": {
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/slos": {
      "get": {
        "operationId": "ListSLOs",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SLO with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SLO with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListSLOsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "post": {
        "operationId": "CreateSLO",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateSLORequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SLO.",
            "schema": {
              "$ref": "#/definitions/configv1CreateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot create the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/slos/{slug}": {
      "delete": {
        "operationId": "DeleteSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteSLOResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SLO because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "get": {
        "operationId": "ReadSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadSLOResponse"
            }
          },
          "404": {
            "description": "Cannot read the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "put": {
        "operationId": "UpdateSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateSLOBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SLO.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot update the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/teams": {
      "get": {
        "operationId": "ListTeams",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Team with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Team with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTeamsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "post": {
        "operationId": "CreateTeam",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Team.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot create the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/teams/{slug}": {
      "delete": {
        "operationId": "DeleteTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTeamResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Team because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "get": {
        "operationId": "ReadTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTeamResponse"
            }
          },
          "404": {
            "description": "Cannot read the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "put": {
        "operationId": "UpdateTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTeamBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Team.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot update the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/trace-behavior-config": {
      "delete": {
        "operationId": "DeleteTraceBehaviorConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehaviorConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehaviorConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehaviorConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehaviorConfig because there is a conflict with an existing TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      }
    },
    "/api/v1/config/trace-behaviors": {
      "get": {
        "operationId": "ListTraceBehaviors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceBehavior with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceBehavior with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceBehaviorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehavior",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-behaviors/{slug}": {
      "delete": {
        "operationId": "DeleteTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehavior because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceBehaviorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules": {
      "get": {
        "operationId": "ListTraceMetricsRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceMetricsRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceMetricsRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get trace metric rules by name.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "metric_names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceMetricsRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "post": {
        "description": "***\nTrace Metrics Rules\n***",
        "operationId": "CreateTraceMetricsRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules/{slug}": {
      "delete": {
        "operationId": "DeleteTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceMetricsRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "get": {
        "operationId": "ReadTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceMetricsRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "put": {
        "operationId": "UpdateTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceMetricsRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigV1"
    }
  ]
}