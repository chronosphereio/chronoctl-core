{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "ConditionOp": {
      "enum": [
        "GEQ",
        "GT",
        "LEQ",
        "LT",
        "EQ",
        "NEQ",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "ConstructedLabelValueDefinition": {
      "properties": {
        "value": {
          "type": "string"
        },
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedLabelMetricLabel": {
      "properties": {
        "constructed_label": {
          "$ref": "#/definitions/MetricLabelConstructedLabel"
        },
        "mapping_label": {
          "$ref": "#/definitions/MetricLabelMappingLabel"
        }
      },
      "type": "object"
    },
    "DerivedMetricQuery": {
      "properties": {
        "prometheus_expr": {
          "description": "Required PromQL expression which the derived metric executes. Should\ninclude all configured variables.",
          "example": "cpu_usage{$service, $instance} / sum(cpu_usage{$service})",
          "type": "string"
        },
        "variables": {
          "description": "Optional variables which may be used in the derived metric as label\nselectors.",
          "items": {
            "$ref": "#/definitions/DerivedMetricVariable"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelector": {
      "properties": {
        "labels": {
          "description": "Labels which must match in the derived metric usage for the selector to\nmatch.",
          "items": {
            "$ref": "#/definitions/configv1DerivedMetricLabelMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelectorQuery": {
      "properties": {
        "selector": {
          "$ref": "#/definitions/DerivedMetricSelector"
        },
        "query": {
          "$ref": "#/definitions/DerivedMetricQuery"
        }
      },
      "type": "object"
    },
    "DerivedMetricVariable": {
      "properties": {
        "name": {
          "description": "Required name of the variable.",
          "example": "service",
          "type": "string"
        },
        "default_prometheus_selector": {
          "description": "Required PromQL label selector which must match the given variable name.\nIf the variable is not specified in the derived metric usage, then this\ndefault selector is used.",
          "example": "service=~\".*\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DropRuleConditionalRateBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables rate-based metric dropping.",
          "type": "boolean"
        },
        "rate_limit_threshold": {
          "description": "Percentage of the licensed limit reached in order to activate the drop\nrule, between 0 and 100.",
          "format": "double",
          "type": "number"
        },
        "activated_drop_duration_secs": {
          "description": "Once activated, activated_drop_duration_secs defines how long the drop\nrule stays activated before rechecking against the rate_limit_threshold.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DropRuleValueBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables value-based metric dropping.",
          "type": "boolean"
        },
        "target_drop_value": {
          "description": "The target datapoint value at which to drop metrics.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "GraphiteLabelPolicyReplace": {
      "properties": {
        "name": {
          "description": "Required name of the label whose value should be replaced. Only\n`__gX__` labels are allowed (aka positional Graphite labels).",
          "example": "__g1__",
          "type": "string"
        },
        "new_value": {
          "description": "Required new value of the replaced label.",
          "example": "ALL_HOSTS",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByGroupByKey": {
      "description": "GroupByKey describes a key to group by.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GroupByKeyGroupByKeyType"
        },
        "named_key": {
          "description": "For named KeyTypes (e.g. span tags), the name of the key to group by.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByKeyGroupByKeyType": {
      "description": " - SERVICE: Group by service.\n - OPERATION: Group by operation.\n - TAG: Group by span tag.",
      "enum": [
        "SERVICE",
        "OPERATION",
        "TAG"
      ],
      "type": "string"
    },
    "HTTPConfigBasicAuth": {
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "HTTPConfigTLSConfig": {
      "properties": {
        "insecure_skip_verify": {
          "description": "Disables validation of the server certificate.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ListMutingRulesRequestState": {
      "enum": [
        "PENDING",
        "ACTIVE",
        "EXPIRED"
      ],
      "type": "string"
    },
    "MappingLabelNameMapping": {
      "properties": {
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "source_label": {
          "description": "The actual label ingested on the time series",
          "type": "string"
        },
        "value_mappings": {
          "description": "These value mappings apply to just the name mapping they belong to.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MappingLabelValueMapping": {
      "properties": {
        "source_value_globs": {
          "description": "Defines the source label values that should be mapped into the given target_value.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_value": {
          "description": "The value that source_value_globs are mapped into.\nFor example, given this mapping:\n```yaml\nvalue_mappings:\n - source_value_globs:\n     - Cat\n     - CAT\n   target_value: cat\n```\nThis indicates that the target value `cat` maps to the source label's values `Cat` and `CAT`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingRuleAggregationPolicy": {
      "properties": {
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1MappingRuleStoragePolicy"
        },
        "interval": {
          "description": "Interval between aggregated data points, equivalent to the resolution\nfield in storage policy. If set, then the storage_policy field can't be\nset.",
          "type": "string"
        },
        "drop_timestamp": {
          "description": "Whether to drop the timestamp while writing the metric.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MetricLabelConstructedLabel": {
      "properties": {
        "value_definitions": {
          "items": {
            "$ref": "#/definitions/ConstructedLabelValueDefinition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabel": {
      "properties": {
        "name_mappings": {
          "items": {
            "$ref": "#/definitions/MappingLabelNameMapping"
          },
          "type": "array"
        },
        "value_mappings": {
          "description": "These value mappings apply to the whole mapping label.\nIf there's no name_mappings, these value mappings apply to the label that exists on the metric.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricsRestrictionPermission": {
      "enum": [
        "READ",
        "WRITE",
        "READ_WRITE"
      ],
      "type": "string"
    },
    "MonitorCondition": {
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "The value to compare to the metric value using the op operation.",
          "format": "double",
          "type": "number"
        },
        "sustain_secs": {
          "description": "Time op operation must evaluate to true for the condition to evaluate to true.",
          "format": "int32",
          "type": "integer"
        },
        "resolve_sustain_secs": {
          "description": "Time op operation must evaluate as false for an active alert, before that alert resolves.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "MonitorSchedule": {
      "properties": {
        "timezone": {
          "description": "The timezone of the time ranges.",
          "type": "string"
        },
        "weekly_schedule": {
          "$ref": "#/definitions/ScheduleWeeklySchedule"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditions": {
      "description": "Conditions evaluated against each queried series to determine the severity of each series.",
      "properties": {
        "defaults": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        },
        "overrides": {
          "description": "Optional list of overrides to use for series having matching labels.\nEach override defines labels that potentially match a series' labels.\nIf one or more overrides match a series, the severity conditions of the first matching\noverride are used instead of the defaults.\n\nCannot be used if graphite_query is set.",
          "items": {
            "$ref": "#/definitions/MonitorSeriesConditionsOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditionsOverride": {
      "properties": {
        "label_matchers": {
          "description": "Set of matchers on a series' labels.\nIf all labels match then the conditions defined in this override are used.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "severity_conditions": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        }
      },
      "type": "object"
    },
    "MonitorSignalGrouping": {
      "description": "SignalGrouping defines how the set of series from the query are split into signals.",
      "properties": {
        "label_names": {
          "description": "Set of labels names used to split series into signals.\nEach unique combination of labels will result in its own signal.\nFor example, if label_names is [\"service\", \"code\"] then all series including labels {service=\"foo\",code=\"404\"}\nwill be grouped together in the same signal.\n\nCannot be used if graphite_query is set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "signal_per_series": {
          "description": "If this is true, each series will have its own signal.\nIf this is true then label_names cannot be set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutes": {
      "properties": {
        "defaults": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        },
        "overrides": {
          "description": "Optional list of overrides to use for alerts having matching labels.\nEach override defines labels that potentially match an alert's labels.\nIf one or more overrides match an alert, the notifiers of the first matching\noverride are used instead of the defaults.",
          "items": {
            "$ref": "#/definitions/NotificationPolicyRoutesOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesOverride": {
      "properties": {
        "alert_label_matchers": {
          "description": "Set of matchers on an alert's labels.\nIf all labels match then the override notifiers apply.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "notifiers": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        }
      },
      "type": "object"
    },
    "NotifierEmailConfig": {
      "properties": {
        "to": {
          "description": "Required email address to send notifications to.",
          "type": "string"
        },
        "html": {
          "description": "Optional HTML body of the email.",
          "type": "string"
        },
        "text": {
          "description": "Optional text body of the email.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierHTTPConfig": {
      "properties": {
        "basic_auth": {
          "$ref": "#/definitions/HTTPConfigBasicAuth"
        },
        "bearer_token": {
          "description": "Bearer token authentication. Cannot be set if basic_auth is set.",
          "type": "string"
        },
        "proxy_url": {
          "description": "Optional proxy URL.",
          "type": "string"
        },
        "tls_config": {
          "$ref": "#/definitions/HTTPConfigTLSConfig"
        }
      },
      "type": "object"
    },
    "NotifierOpsGenieConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required OpsGenie API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required OpsGenie API URL to send requests to, e.g.\n\"https://api.opsgenie.com/\".",
          "type": "string"
        },
        "message": {
          "description": "Alert text.",
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "source": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of arbitrary key/value pairs that provide further detail about the\nalert.",
          "type": "object"
        },
        "responders": {
          "description": "List of responders responsible for notifications.",
          "items": {
            "$ref": "#/definitions/OpsGenieConfigResponder"
          },
          "type": "array"
        },
        "tags": {
          "description": "Comma separated list of tags attached to the notifications.",
          "type": "string"
        },
        "note": {
          "description": "Additional alert note.",
          "type": "string"
        },
        "priority": {
          "description": "Priority level of alert. Possible values are P1, P2, P3, P4, and P5.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierPagerdutyConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "The Pagerduty URL to send API requests to.",
          "type": "string"
        },
        "client": {
          "description": "Client identification of the notification sender.",
          "type": "string"
        },
        "client_url": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "description": {
          "description": "Description of the incident.",
          "type": "string"
        },
        "severity": {
          "description": "Severity of the incident.\nValid values are 'critical', 'error', 'warning', 'info', or blank",
          "type": "string"
        },
        "class": {
          "description": "The class/type of the event.",
          "type": "string"
        },
        "component": {
          "description": "The part or component of the affected system which is broken.",
          "type": "string"
        },
        "group": {
          "description": "A cluster or grouping of services.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set of arbitrary key/value pairs which provide further detail about the\nincident.",
          "type": "object"
        },
        "images": {
          "description": "Images to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigImage"
          },
          "type": "array"
        },
        "links": {
          "description": "Links to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigLink"
          },
          "type": "array"
        },
        "service_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Prometheus\"). Cannot be set if routing_key is set.",
          "type": "string"
        },
        "routing_key": {
          "description": "The PagerDuty integration key (when using PagerDuty integration type\n\"Events API v2\"). Cannot be set if service_key is set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_url": {
          "description": "Required Slack webhook API URL.",
          "type": "string"
        },
        "channel": {
          "description": "The channel to send notifications to.",
          "type": "string"
        },
        "username": {
          "description": "The user to send notifications to.",
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "title_link": {
          "type": "string"
        },
        "pretext": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "footer": {
          "type": "string"
        },
        "fallback": {
          "type": "string"
        },
        "callback_id": {
          "type": "string"
        },
        "icon_emoji": {
          "type": "string"
        },
        "icon_url": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "thumb_url": {
          "type": "string"
        },
        "short_fields": {
          "type": "boolean"
        },
        "link_names": {
          "type": "boolean"
        },
        "mrkdwn_in": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "items": {
            "$ref": "#/definitions/SlackConfigField"
          },
          "type": "array"
        },
        "actions": {
          "items": {
            "$ref": "#/definitions/NotifierSlackConfigAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfigAction": {
      "properties": {
        "type": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "style": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "confirm_field": {
          "$ref": "#/definitions/SlackConfigConfirmationField"
        }
      },
      "type": "object"
    },
    "NotifierVictorOpsConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Required VictorOps API key.",
          "type": "string"
        },
        "api_url": {
          "description": "Required VictorOps API URL.",
          "type": "string"
        },
        "routing_key": {
          "description": "Required VictorOps routing key.",
          "type": "string"
        },
        "message_type": {
          "description": "Describes the behavior of the alert (CRITICAL, WARNING, INFO).",
          "type": "string"
        },
        "entity_display_name": {
          "description": "Summary of the alerted problem.",
          "type": "string"
        },
        "state_message": {
          "description": "Long explanation of the alerted problem.",
          "type": "string"
        },
        "monitoring_tool": {
          "description": "The monitoring tool the state message is from.",
          "type": "string"
        },
        "custom_fields": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "NotifierWebhookConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "Required webhook URL (will be called as a POST request).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OpsGenieConfigResponder": {
      "properties": {
        "id": {
          "description": "ID of the responder. Cannot be set if name or username are set.",
          "type": "string"
        },
        "name": {
          "description": "Name of the responder. Cannot be set if id or username are set.",
          "type": "string"
        },
        "username": {
          "description": "Username of the responder. Cannot be set if id or name are set.",
          "type": "string"
        },
        "responder_type": {
          "$ref": "#/definitions/ResponderResponderType"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigImage": {
      "properties": {
        "src": {
          "type": "string"
        },
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigLink": {
      "properties": {
        "href": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy should apply.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "ResourceChange": {
      "properties": {
        "resource": {
          "$ref": "#/definitions/configv1ResourceType"
        },
        "slug": {
          "type": "string"
        },
        "action": {
          "$ref": "#/definitions/ResourceChangeAction"
        }
      },
      "type": "object"
    },
    "ResourceChangeAction": {
      "enum": [
        "CREATED",
        "UPDATED",
        "DELETED",
        "NOOP"
      ],
      "type": "string"
    },
    "ResourcePoolsAllocation": {
      "properties": {
        "percent_of_license": {
          "description": "Percentage of the license to allocate to this pool. Must be between 0\nand 100 inclusive. The percent_of_license values across all pools\n(including the default pool) must add up to exactly 100.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "ResourcePoolsDefaultPool": {
      "properties": {
        "allocation": {
          "$ref": "#/definitions/ResourcePoolsAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        }
      },
      "type": "object"
    },
    "ResourcePoolsPool": {
      "properties": {
        "name": {
          "description": "Required name of the pool. Must be unique.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/ResourcePoolsAllocation"
        },
        "filters": {
          "description": "Required filters which define which metrics map to this pool, where any\nmetric which matches at least one filter will map to the pool.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        }
      },
      "type": "object"
    },
    "ResourcePoolsPriorities": {
      "properties": {
        "high_priority_filters": {
          "description": "Required filters which define which metrics are high priority, where any\nmetric which matches at least one filter is considered high priority.\nHigh priority metrics are dropped last when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "Required filters which define which metrics are low priority, where any\nmetric which matches at least one filter is considered low priority. Low\npriority metrics are dropped first when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResponderResponderType": {
      "enum": [
        "TEAM",
        "USER",
        "ESCALATION",
        "SCHEDULE"
      ],
      "type": "string"
    },
    "RollupRuleGraphiteLabelPolicy": {
      "properties": {
        "replace": {
          "description": "Required list of labels to replace. Useful for discarding\nhigh-cardinality values while still preserving the original positions of\nthe Graphite metric.",
          "items": {
            "$ref": "#/definitions/GraphiteLabelPolicyReplace"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RollupRuleLabelReplace": {
      "description": "Must keep this around for backwards compatibility because terraform will\nstill send this key w/ a null value.",
      "type": "object"
    },
    "RollupRuleMetricType": {
      "enum": [
        "COUNTER",
        "GAUGE",
        "DELTA",
        "DISTRIBUTION",
        "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
        "MEASUREMENT",
        "CUMULATIVE_COUNTER",
        "DELTA_COUNTER",
        "DELTA_EXPONENTIAL_HISTOGRAM"
      ],
      "type": "string"
    },
    "RoutesNotifierList": {
      "properties": {
        "notifier_slugs": {
          "description": "Slugs of notifiers that will receive the alerts.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "repeat_interval_secs": {
          "description": "Frequency at which to resend alerts.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "RoutesSeverityNotifiers": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/RoutesNotifierList"
        },
        "critical": {
          "$ref": "#/definitions/RoutesNotifierList"
        }
      },
      "type": "object"
    },
    "ScheduleDayActive": {
      "enum": [
        "ALL_DAY",
        "ONLY_DURING_RANGES",
        "NEVER"
      ],
      "type": "string"
    },
    "ScheduleDayTimeRange": {
      "properties": {
        "start_hh_mm": {
          "description": "Start time in the in format \"\u003chour\u003e:\u003cminute\u003e\", e.g. \"15:30\".",
          "type": "string"
        },
        "end_hh_mm": {
          "description": "End time in the in format \"\u003chour\u003e:\u003cminute\u003e\", e.g. \"15:30\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScheduleScheduleDay": {
      "properties": {
        "active": {
          "$ref": "#/definitions/ScheduleDayActive"
        },
        "ranges": {
          "description": "The time ranges that the monitor is active on this day. Required if\nactive is set to ONLY_DURING_RANGES, else must be empty.",
          "items": {
            "$ref": "#/definitions/ScheduleDayTimeRange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ScheduleWeeklySchedule": {
      "properties": {
        "monday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "tuesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "wednesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "thursday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "friday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "saturday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "sunday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        }
      },
      "type": "object"
    },
    "SeriesConditionsConditions": {
      "properties": {
        "conditions": {
          "description": "List of conditions to evaluate against a series.\nOnly one condition -- not all -- needs to match in order to assign a severity to a signal.",
          "items": {
            "$ref": "#/definitions/MonitorCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SeriesConditionsSeverityConditions": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        },
        "critical": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        }
      },
      "type": "object"
    },
    "ServiceAccountMetricsRestriction": {
      "properties": {
        "permission": {
          "$ref": "#/definitions/MetricsRestrictionPermission"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels which further restricts the service account to only read\nor write metrics with the given label names and values.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SlackConfigConfirmationField": {
      "properties": {
        "text": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "ok_text": {
          "type": "string"
        },
        "dismiss_text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SlackConfigField": {
      "properties": {
        "title": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "short": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION"
      ],
      "type": "string"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range [0, 1]) when specific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the default sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range [0, 1] that defines the probability of sampling any trace.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceMetricsRuleGroupBy": {
      "description": "GroupBy contains fields required to group the resultant metrics of a TraceMetricsRule by a specific key.",
      "properties": {
        "label": {
          "description": "The label to use in the resultant metrics.",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/GroupByGroupByKey"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a SpanFilter (inclusive).",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value the filter compares to the target trace or span field.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key (or name) of the span tag that is inspected by this filter.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1AggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX",
        "MEAN",
        "MEDIAN",
        "COUNT",
        "SUM",
        "SUMSQ",
        "STDEV",
        "P10",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "P90",
        "P95",
        "P99",
        "P999",
        "P9999",
        "P25",
        "P75",
        "COUNT_SAMPLES",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "configv1Bucket": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Bucket. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Bucket is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Bucket. May be modified after the Bucket is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Bucket was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Bucket was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional description of the bucket.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels marking the bucket.",
          "type": "object"
        },
        "team_slug": {
          "description": "Optional slug of the team the bucket belongs to.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this bucket.\nThis is optional if the bucket does not contain monitors or all of its monitors explicitly reference a policy.\nThis policy takes precedence over a bucket-owned notification policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Collection": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Collection. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Collection is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Collection. May be modified after the Collection is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Collection was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Collection was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReference": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1CollectionReferenceType"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReferenceType": {
      "description": "Type values must match entitiespb.Collection.CollectionType.",
      "enum": [
        "SIMPLE",
        "SERVICE"
      ],
      "type": "string"
    },
    "configv1CreateBucketRequest": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "dry_run": {
          "description": "If true, the Bucket will not be created, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardRequest": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionRequest": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "dry_run": {
          "description": "If true, the Collection will not be created, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "dry_run": {
          "description": "If true, the Dashboard will not be created, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelRequest": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "dry_run": {
          "description": "If true, the DerivedLabel will not be created, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricRequest": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "dry_run": {
          "description": "If true, the DerivedMetric will not be created, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleRequest": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "dry_run": {
          "description": "If true, the DropRule will not be created, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardRequest": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If true, the GrafanaDashboard will not be created, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleRequest": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "dry_run": {
          "description": "If true, the MappingRule will not be created, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorRequest": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "dry_run": {
          "description": "If true, the Monitor will not be created, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleRequest": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "dry_run": {
          "description": "If true, the MutingRule will not be created, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyRequest": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "dry_run": {
          "description": "If true, the NotificationPolicy will not be created, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierRequest": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "dry_run": {
          "description": "If true, the Notifier will not be created, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleRequest": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "dry_run": {
          "description": "If true, the RecordingRule will not be created, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "dry_run": {
          "description": "If true, the ResourcePools will not be created, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleRequest": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "dry_run": {
          "description": "If true, the RollupRule will not be created, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountRequest": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        },
        "dry_run": {
          "description": "If true, the ServiceAccount will not be created, and no response ServiceAccount will be returned. The response will return an error if the given ServiceAccount is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamRequest": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "dry_run": {
          "description": "If true, the Team will not be created, and no response Team will be returned. The response will return an error if the given Team is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleRequest": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "dry_run": {
          "description": "If true, the TraceMetricsRule will not be created, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1Dashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Dashboard. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Dashboard. May be modified after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Optional slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Whether to override the default sample rate",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1DeleteBucketResponse": {
      "properties": {
        "changes": {
          "description": "Changes contains what resources are deleted. The bucket being deleted will\nalways be included. When force_delete is used, the changelog will include\nall resources that reference the bucket that were deleted.",
          "items": {
            "$ref": "#/definitions/ResourceChange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DeleteClassicDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteCollectionResponse": {
      "type": "object"
    },
    "configv1DeleteDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedLabelResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedMetricResponse": {
      "type": "object"
    },
    "configv1DeleteDropRuleResponse": {
      "type": "object"
    },
    "configv1DeleteGrafanaDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteMappingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteMonitorResponse": {
      "type": "object"
    },
    "configv1DeleteMutingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteNotificationPolicyResponse": {
      "type": "object"
    },
    "configv1DeleteNotifierResponse": {
      "type": "object"
    },
    "configv1DeleteRecordingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteResourcePoolsResponse": {
      "type": "object"
    },
    "configv1DeleteRollupRuleResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAccountResponse": {
      "type": "object"
    },
    "configv1DeleteTeamResponse": {
      "type": "object"
    },
    "configv1DeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configv1DeleteTraceMetricsRuleResponse": {
      "type": "object"
    },
    "configv1DeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configv1DerivedLabel": {
      "properties": {
        "name": {
          "description": "Required name of the DerivedLabel. May be modified after the DerivedLabel is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedLabel. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DerivedLabel is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedLabel was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedLabel was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_name": {
          "description": "Name of the derived label. It needs to be unique across the system.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived label.",
          "type": "string"
        },
        "metric_label": {
          "$ref": "#/definitions/DerivedLabelMetricLabel"
        },
        "existing_label_policy": {
          "$ref": "#/definitions/configv1DerivedLabelLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1DerivedLabelLabelPolicy": {
      "enum": [
        "KEEP",
        "OVERRIDE"
      ],
      "type": "string"
    },
    "configv1DerivedMetric": {
      "properties": {
        "name": {
          "description": "Required name of the DerivedMetric. May be modified after the DerivedMetric is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the DerivedMetric. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DerivedMetric is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedMetric was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedMetric was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "Required metric name of the derived metric, which must be unique across the system.",
          "example": "cpu_usage:instance",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the derived metric.",
          "type": "string"
        },
        "queries": {
          "description": "Required queries that the derived metric can map to.",
          "items": {
            "$ref": "#/definitions/DerivedMetricSelectorQuery"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1DerivedMetricLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcherMatcherType": {
      "enum": [
        "EXACT"
      ],
      "type": "string"
    },
    "configv1DropRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the DropRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the DropRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the DropRule. May be modified after the DropRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DropRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DropRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/configv1DropRuleMode"
        },
        "filters": {
          "description": "Series that match this filter are dropped.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "conditional_rate_based_drop": {
          "$ref": "#/definitions/DropRuleConditionalRateBasedDrop"
        },
        "value_based_drop": {
          "$ref": "#/definitions/DropRuleValueBasedDrop"
        },
        "drop_nan_value": {
          "description": "Drops datapoints if datapoint values are NaN.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1DropRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "configv1GrafanaDashboard": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the GrafanaDashboard. If slug is not provided, one will be generated based of the name field. Cannot be modified after the GrafanaDashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the GrafanaDashboard. May be modified after the GrafanaDashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GrafanaDashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GrafanaDashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the dashboard belongs to. Required if collection_slug\nis not set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the dashboard belongs to. Required if bucket_slug\nis not set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the Grafana dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelFilter": {
      "properties": {
        "name": {
          "description": "Name of the label to match.",
          "example": "job",
          "type": "string"
        },
        "value_glob": {
          "description": "Glob value of the label to match.",
          "example": "myservice*",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1LabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX"
      ],
      "type": "string"
    },
    "configv1ListBucketsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "buckets": {
          "items": {
            "$ref": "#/definitions/configv1Bucket"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListClassicDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "classic_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListCollectionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "collections": {
          "items": {
            "$ref": "#/definitions/configv1Collection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configv1Dashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedLabelsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_labels": {
          "items": {
            "$ref": "#/definitions/configv1DerivedLabel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedMetricsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_metrics": {
          "items": {
            "$ref": "#/definitions/configv1DerivedMetric"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDropRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "drop_rules": {
          "items": {
            "$ref": "#/definitions/configv1DropRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGrafanaDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "grafana_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMappingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "mapping_rules": {
          "items": {
            "$ref": "#/definitions/configv1MappingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMonitorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "monitors": {
          "items": {
            "$ref": "#/definitions/configv1Monitor"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMutingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "muting_rules": {
          "items": {
            "$ref": "#/definitions/configv1MutingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotificationPoliciesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notification_policies": {
          "items": {
            "$ref": "#/definitions/configv1NotificationPolicy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotifiersResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notifiers": {
          "items": {
            "$ref": "#/definitions/configv1Notifier"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRecordingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "recording_rules": {
          "items": {
            "$ref": "#/definitions/configv1RecordingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRollupRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "rollup_rules": {
          "items": {
            "$ref": "#/definitions/configv1RollupRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAccountsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_accounts": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTeamsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "teams": {
          "items": {
            "$ref": "#/definitions/configv1Team"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceMetricsRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_metrics_rules": {
          "description": "Found trace metrics rules.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1MappingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MappingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the MappingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the MappingRule. May be modified after the MappingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MappingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MappingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Required slug of the bucket the MappingRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Required filters that determine to which metrics to apply the rule.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "aggregation_policy": {
          "$ref": "#/definitions/MappingRuleAggregationPolicy"
        },
        "drop": {
          "description": "Whether to drop the given set of metrics. If set, then the aggregation\npolicy can't be set.",
          "type": "boolean"
        },
        "mode": {
          "$ref": "#/definitions/configv1MappingRuleMode"
        }
      },
      "type": "object"
    },
    "configv1MappingRuleMode": {
      "description": " - ENABLED: ENABLED rules are applied. Rules default to ENABLED.\n - PREVIEW: PREVIEW rules are not applied, but shaping impact stats\nfor them rule are recorded.",
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1MappingRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Monitor": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Monitor. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Monitor is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Monitor. May be modified after the Monitor is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Monitor was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Monitor was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the monitor belongs to. Required if collection_slug is\nnot set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the monitor belongs to. Required if bucket_slug is\nnot set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are visible in notifications generated by this monitor,\nand can be used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this monitor.\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "series_conditions": {
          "$ref": "#/definitions/MonitorSeriesConditions"
        },
        "notification_policy_slug": {
          "description": "Optional notification policy used to route alerts generated by the monitor.\nIf omitted, the notification policy is inherited from the monitor's bucket.",
          "type": "string"
        },
        "interval_secs": {
          "description": "Optional setting for configuring how often alerts are evaluated.\nIf this is not set, it will default to 60s.",
          "format": "int32",
          "type": "integer"
        },
        "prometheus_query": {
          "description": "PromQL query. If set, graphite_query cannot be set.",
          "example": "up{job=\"prometheus\"} == 0",
          "type": "string"
        },
        "graphite_query": {
          "description": "Graphite query. If set, prometheus_query cannot be set.",
          "example": "sumSeries(stats.timers.*.mean_90)",
          "type": "string"
        },
        "schedule": {
          "$ref": "#/definitions/MonitorSchedule"
        }
      },
      "type": "object"
    },
    "configv1MutingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the MutingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the MutingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the MutingRule. May be modified after the MutingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MutingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MutingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_matchers": {
          "description": "Specify which series are silenced by the muting rule. Alerting series must\nmatch all muting rule matchers to be silenced.\nThis value cannot be updated. Updates must specify the original value.",
          "items": {
            "$ref": "#/definitions/configv1MutingRuleLabelMatcher"
          },
          "type": "array"
        },
        "starts_at": {
          "description": "Timestamp of when the muting rule becomes active.\nThis value cannot be updated. Updates must specify the original value.",
          "format": "date-time",
          "type": "string"
        },
        "ends_at": {
          "description": "Timestamp of when the muting rule stops being active.",
          "format": "date-time",
          "type": "string"
        },
        "comment": {
          "description": "Optional comment that explains why the muting rule was created.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1MutingRuleLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX",
        "NOT_EXACT",
        "NOT_REGEXP"
      ],
      "type": "string"
    },
    "configv1NotificationPolicy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the NotificationPolicy. If slug is not provided, one will be generated based of the name field. Cannot be modified after the NotificationPolicy is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the NotificationPolicy. May be modified after the NotificationPolicy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NotificationPolicy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NotificationPolicy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the notification policy belongs to. Required if\nteam_slug is not set.",
          "type": "string"
        },
        "team_slug": {
          "description": "Slug of the team the notification policy belongs to. Required if\nbucket_slug is not set.",
          "type": "string"
        },
        "routes": {
          "$ref": "#/definitions/NotificationPolicyRoutes"
        }
      },
      "type": "object"
    },
    "configv1Notifier": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Notifier. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Notifier is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Notifier. May be modified after the Notifier is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Notifier was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Notifier was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "skip_resolved": {
          "description": "If true, do not notify on resolved alerts. Cannot set if discard is set.",
          "type": "boolean"
        },
        "webhook": {
          "$ref": "#/definitions/NotifierWebhookConfig"
        },
        "slack": {
          "$ref": "#/definitions/NotifierSlackConfig"
        },
        "pagerduty": {
          "$ref": "#/definitions/NotifierPagerdutyConfig"
        },
        "email": {
          "$ref": "#/definitions/NotifierEmailConfig"
        },
        "ops_genie": {
          "$ref": "#/definitions/NotifierOpsGenieConfig"
        },
        "victor_ops": {
          "$ref": "#/definitions/NotifierVictorOpsConfig"
        },
        "discard": {
          "description": "If set, enables the \"discard\" integration which simply discards all\nnotifications. Cannot set if another integration is set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1ReadClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1ReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1ReadDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1ReadGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1ReadMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1ReadNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1ReadRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1ReadRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configv1Service"
        }
      },
      "type": "object"
    },
    "configv1ReadTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1RecordingRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RecordingRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the RecordingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the RecordingRule. May be modified after the RecordingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RecordingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RecordingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Optional slug of the bucket the RecordingRule belongs to.",
          "type": "string"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RecordingRuleLabelPolicy"
        },
        "interval_secs": {
          "description": "Optional interval for evaluating the recording rule.",
          "format": "int32",
          "type": "integer"
        },
        "metric_name": {
          "description": "The name of the time series to use for output, which must be a valid\nmetric name.",
          "type": "string"
        },
        "prometheus_expr": {
          "description": "The PromQL expression to evaluate at the time of each evaluation cycle.\nThe result is recorded as a new time series with its metric name\ndefined by the metric_name (or name) field.",
          "type": "string"
        },
        "execution_group": {
          "description": "Optional execution_group in which this rule is to be evaluated.\nAt least one of bucket_slug and execution_group must be set. If both are set, then they are expected to match.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1RecordingRuleLabelPolicy": {
      "properties": {
        "add": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to add or overwrite before storing the result.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1ResourcePools": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ResourcePools was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ResourcePools was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_pool": {
          "$ref": "#/definitions/ResourcePoolsDefaultPool"
        },
        "pools": {
          "description": "Optional pools.",
          "items": {
            "$ref": "#/definitions/ResourcePoolsPool"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourceType": {
      "enum": [
        "BUCKET",
        "DASHBOARD",
        "GRAFANA_DASHBOARD",
        "MONITOR",
        "NOTIFICATION_POLICY",
        "RECORDING_RULE",
        "MAPPING_RULE",
        "ROLLUP_RULE"
      ],
      "type": "string"
    },
    "configv1RollupRule": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the RollupRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the RollupRule is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the RollupRule. May be modified after the RollupRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RollupRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RollupRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Required slug of the bucket the RollupRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Filters that determine to which metrics to apply the rule.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "metric_name": {
          "description": "Name of the new metric created as a result of the rollup.",
          "type": "string"
        },
        "metric_type": {
          "$ref": "#/definitions/RollupRuleMetricType"
        },
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1RollupRuleStoragePolicy"
        },
        "interval": {
          "description": "Interval between aggregated data points, equivalent to the resolution\nfield in storage policy. If set, then the storage_policy field can't be\nset.",
          "type": "string"
        },
        "expansive_match": {
          "description": "Enables expansive label matching behavior for the provided filters and\nlabel_policy.keep or graphite_label_policy.replace (if set). By default\n(expansive_match=false), a series matches and aggregates only if each label\ndefined by filters and label_policy.keep or graphite_label_policy.replace\n(respectively) exist in said series. Setting expansive_match=true removes\nthis restriction.",
          "type": "boolean"
        },
        "add_metric_type_label": {
          "description": "Defines whether to add a `__rollup_type__` label in the new metric.",
          "type": "boolean"
        },
        "drop_raw": {
          "description": "Defines whether to automatically generate drop rules for this rollup.",
          "type": "boolean"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RollupRuleLabelPolicy"
        },
        "label_replace": {
          "$ref": "#/definitions/RollupRuleLabelReplace"
        },
        "mode": {
          "$ref": "#/definitions/configv1RollupRuleMode"
        },
        "graphite_label_policy": {
          "$ref": "#/definitions/RollupRuleGraphiteLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleLabelPolicy": {
      "properties": {
        "keep": {
          "description": "Labels that should be retained in the output metric. If set, then the\ndiscard field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "discard": {
          "description": "Labels that should be discarded in the output metric. If set, then the\nkeep field must be empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleMode": {
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "title": "- PREVIEW: TODO: DISABLED = 2;",
      "type": "string"
    },
    "configv1RollupRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Required resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Required retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Service": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Service. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Service. May be modified after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ServiceAccount": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the ServiceAccount. If slug is not provided, one will be generated based of the name field. Cannot be modified after the ServiceAccount is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the ServiceAccount. May be modified after the ServiceAccount is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ServiceAccount was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ServiceAccount was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "token": {
          "description": "token is the generated API token of the service account. Cannot be set by\nclients.\n\ntoken is only set once by the server in the CreateServiceAccount response.\nReadServiceAccount will always return an empty token. Therefore, when\ncreating a service account, clients are responsible for securely storing\nthe response token on their end, as they will not be able to read it\nagain.",
          "readOnly": true,
          "type": "string"
        },
        "email": {
          "description": "email is the generated email address of the service account. Cannot be set\nby clients.",
          "readOnly": true,
          "type": "string"
        },
        "unrestricted": {
          "description": "If set, grants the service account access to all Chronosphere APIs\n(including resource configuration and metric data) within the access\ncontrols defined by the service account's team membership.\n\nExactly one of unrestricted or metrics_restriction must be set.",
          "type": "boolean"
        },
        "metrics_restriction": {
          "$ref": "#/definitions/ServiceAccountMetricsRestriction"
        }
      },
      "type": "object"
    },
    "configv1Team": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the Team. If slug is not provided, one will be generated based of the name field. Cannot be modified after the Team is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the Team. May be modified after the Team is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Team was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Team was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "user_emails": {
          "description": "Unordered set of emails whose users are members of this team.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "description": {
          "description": "Optional short description of the team.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "Unique identifier of the TraceJaegerRemoteSamplingStrategy. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "Required name of the TraceJaegerRemoteSamplingStrategy. May be modified after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This must match the slug and name fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRule": {
      "properties": {
        "name": {
          "description": "Required name of the TraceMetricsRule. May be modified after the TraceMetricsRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "Unique identifier of the TraceMetricsRule. If slug is not provided, one will be generated based of the name field. Cannot be modified after the TraceMetricsRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceMetricsRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceMetricsRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "The name of the generated trace metrics.",
          "type": "string"
        },
        "metric_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to apply to the generated trace metrics.",
          "type": "object"
        },
        "histogram_buckets_secs": {
          "description": "Histogram bucket values, in seconds, for generated duration metrics.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "trace_filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "group_by": {
          "description": "Add labels to the resultant metrics based on these specified GroupBy messages.",
          "items": {
            "$ref": "#/definitions/TraceMetricsRuleGroupBy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Each SpanFilter object represents all conditions that need to be true on\nthe same span for the span to be considered matching the SpanFilter. If\n`span_count` is used, the number of spans within the trace that match the\nSpanFilter needs to be within [min, max]. Multiple SpanFilters can be used,\nand each can be satisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule, which summarizes what it's for",
          "type": "string"
        },
        "system_name": {
          "description": "Value used as the metric label value for metrics emitted relating to this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "When the rule was created (novel system_name)",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "When the rule was updated (existing system_name)",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. A list of rules, evaluated in order until a match is found,\nand the sample rate applied, or else the default sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configv1TraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configv1DefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configv1UpdateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1UpdateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1UpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1UpdateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1UpdateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1UpdateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "create_if_missing": {
          "description": "If true, the ResourcePools will be created if it does not already exist. If false, an error will be returned if the ResourcePools does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the ResourcePools will not be created nor updated, and no response ResourcePools will be returned. The response will return an error if the given ResourcePools is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1UpdateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If true, the TraceTailSamplingRules will be created if it does not already exist. If false, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If true, the TraceTailSamplingRules will not be created nor updated, and no response TraceTailSamplingRules will be returned. The response will return an error if the given TraceTailSamplingRules is invalid.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\nThe Config API provides standard HTTP/JSON REST endpoints for creating, reading,\nupdating, deleting, and listing configurable Chronosphere resources.\n\nUse this link to download the raw Swagger specification:\n\u003ca href=\"/api/v1/config/swagger.json\"\u003e/api/v1/config/swagger.json\u003c/a\u003e\n",
    "title": "Config V1 API",
    "version": "v1"
  },
  "paths": {
    "/api/v1/config/buckets": {
      "get": {
        "operationId": "ListBuckets",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Bucket with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Bucket with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListBucketsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "post": {
        "operationId": "CreateBucket",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot create the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/buckets/{slug}": {
      "delete": {
        "operationId": "DeleteBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "description": "force_delete indicates deletion of the bucket and all resources that reference the bucket.\nThis includes monitors, dashboards, notification policies, recording rules, and alerts.",
            "in": "query",
            "name": "force_delete",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteBucketResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Bucket because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "get": {
        "operationId": "ReadBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadBucketResponse"
            }
          },
          "404": {
            "description": "Cannot read the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "put": {
        "operationId": "UpdateBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "bucket": {
                  "$ref": "#/definitions/configv1Bucket"
                },
                "create_if_missing": {
                  "description": "If true, the Bucket will be created if it does not already exist, identified by slug. If false, an error will be returned if the Bucket does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Bucket will not be created nor updated, and no response Bucket will be returned. The response will return an error if the given Bucket is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot update the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/classic-dashboards": {
      "get": {
        "operationId": "ListClassicDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ClassicDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any ClassicDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any ClassicDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ClassicDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListClassicDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "post": {
        "operationId": "CreateClassicDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/classic-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "get": {
        "operationId": "ReadClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadClassicDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "classic_dashboard": {
                  "$ref": "#/definitions/configv1GrafanaDashboard"
                },
                "create_if_missing": {
                  "description": "If true, the GrafanaDashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the GrafanaDashboard does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the GrafanaDashboard will not be created nor updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/collections": {
      "get": {
        "operationId": "ListCollections",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Collection with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Collection with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Collection with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get collections that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListCollectionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "post": {
        "operationId": "CreateCollection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Collection.",
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot create the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/collections/{slug}": {
      "delete": {
        "operationId": "DeleteCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Collection because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "get": {
        "operationId": "ReadCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadCollectionResponse"
            }
          },
          "404": {
            "description": "Cannot read the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "put": {
        "operationId": "UpdateCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "collection": {
                  "$ref": "#/definitions/configv1Collection"
                },
                "create_if_missing": {
                  "description": "If true, the Collection will be created if it does not already exist, identified by slug. If false, an error will be returned if the Collection does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Collection will not be created nor updated, and no response Collection will be returned. The response will return an error if the given Collection is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Collection.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot update the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Dashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the Dashboard does not already exist.",
                  "type": "boolean"
                },
                "dashboard": {
                  "$ref": "#/definitions/configv1Dashboard"
                },
                "dry_run": {
                  "description": "If true, the Dashboard will not be created nor updated, and no response Dashboard will be returned. The response will return an error if the given Dashboard is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/derived-labels": {
      "get": {
        "operationId": "ListDerivedLabels",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedLabel with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedLabel with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedLabelsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "post": {
        "operationId": "CreateDerivedLabel",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-labels/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedLabel because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "get": {
        "operationId": "ReadDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedLabelResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the DerivedLabel will be created if it does not already exist, identified by slug. If false, an error will be returned if the DerivedLabel does not already exist.",
                  "type": "boolean"
                },
                "derived_label": {
                  "$ref": "#/definitions/configv1DerivedLabel"
                },
                "dry_run": {
                  "description": "If true, the DerivedLabel will not be created nor updated, and no response DerivedLabel will be returned. The response will return an error if the given DerivedLabel is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-metrics": {
      "get": {
        "operationId": "ListDerivedMetrics",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedMetric with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedMetric with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedMetricsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "post": {
        "operationId": "CreateDerivedMetric",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/derived-metrics/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedMetric because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "get": {
        "operationId": "ReadDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedMetricResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the DerivedMetric will be created if it does not already exist, identified by slug. If false, an error will be returned if the DerivedMetric does not already exist.",
                  "type": "boolean"
                },
                "derived_metric": {
                  "$ref": "#/definitions/configv1DerivedMetric"
                },
                "dry_run": {
                  "description": "If true, the DerivedMetric will not be created nor updated, and no response DerivedMetric will be returned. The response will return an error if the given DerivedMetric is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/drop-rules": {
      "get": {
        "operationId": "ListDropRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DropRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DropRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDropRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "post": {
        "operationId": "CreateDropRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/drop-rules/{slug}": {
      "delete": {
        "operationId": "DeleteDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DropRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "get": {
        "operationId": "ReadDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDropRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "put": {
        "operationId": "UpdateDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the DropRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the DropRule does not already exist.",
                  "type": "boolean"
                },
                "drop_rule": {
                  "$ref": "#/definitions/configv1DropRule"
                },
                "dry_run": {
                  "description": "If true, the DropRule will not be created nor updated, and no response DropRule will be returned. The response will return an error if the given DropRule is invalid.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards": {
      "get": {
        "operationId": "ListGrafanaDashboards",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GrafanaDashboard with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any GrafanaDashboard with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any GrafanaDashboard with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GrafanaDashboard with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGrafanaDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "post": {
        "operationId": "CreateGrafanaDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "get": {
        "operationId": "ReadGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGrafanaDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the GrafanaDashboard will be created if it does not already exist, identified by slug. If false, an error will be returned if the GrafanaDashboard does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the GrafanaDashboard will not be created nor updated, and no response GrafanaDashboard will be returned. The response will return an error if the given GrafanaDashboard is invalid.",
                  "type": "boolean"
                },
                "grafana_dashboard": {
                  "$ref": "#/definitions/configv1GrafanaDashboard"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/mapping-rules": {
      "get": {
        "operationId": "ListMappingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MappingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any MappingRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MappingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMappingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "post": {
        "operationId": "CreateMappingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/mapping-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MappingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "get": {
        "operationId": "ReadMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMappingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the MappingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the MappingRule does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the MappingRule will not be created nor updated, and no response MappingRule will be returned. The response will return an error if the given MappingRule is invalid.",
                  "type": "boolean"
                },
                "mapping_rule": {
                  "$ref": "#/definitions/configv1MappingRule"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/monitors": {
      "get": {
        "operationId": "ListMonitors",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Monitor with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any Monitor with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Monitor with a matching collection_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Monitor with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter returned monitors by the teams that own the collections that they belong to.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMonitorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "CreateMonitor",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot create the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/monitors/{slug}": {
      "delete": {
        "operationId": "DeleteMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Monitor because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "get": {
        "operationId": "ReadMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMonitorResponse"
            }
          },
          "404": {
            "description": "Cannot read the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "operationId": "UpdateMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Monitor will be created if it does not already exist, identified by slug. If false, an error will be returned if the Monitor does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Monitor will not be created nor updated, and no response Monitor will be returned. The response will return an error if the given Monitor is invalid.",
                  "type": "boolean"
                },
                "monitor": {
                  "$ref": "#/definitions/configv1Monitor"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot update the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/muting-rules": {
      "get": {
        "operationId": "ListMutingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MutingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MutingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Lists muting rules filtered by the states.\nIf empty, all muting rules are included.",
            "in": "query",
            "items": {
              "enum": [
                "PENDING",
                "ACTIVE",
                "EXPIRED"
              ],
              "type": "string"
            },
            "name": "states",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMutingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "post": {
        "operationId": "CreateMutingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/muting-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MutingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "get": {
        "operationId": "ReadMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMutingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the MutingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the MutingRule does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the MutingRule will not be created nor updated, and no response MutingRule will be returned. The response will return an error if the given MutingRule is invalid.",
                  "type": "boolean"
                },
                "muting_rule": {
                  "$ref": "#/definitions/configv1MutingRule"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/notification-policies": {
      "get": {
        "operationId": "ListNotificationPolicies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any NotificationPolicy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any NotificationPolicy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any NotificationPolicy with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any NotificationPolicy with a matching team_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotificationPoliciesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "post": {
        "operationId": "CreateNotificationPolicy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot create the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notification-policies/{slug}": {
      "delete": {
        "operationId": "DeleteNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NotificationPolicy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "get": {
        "operationId": "ReadNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotificationPolicyResponse"
            }
          },
          "404": {
            "description": "Cannot read the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "put": {
        "operationId": "UpdateNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the NotificationPolicy will be created if it does not already exist, identified by slug. If false, an error will be returned if the NotificationPolicy does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the NotificationPolicy will not be created nor updated, and no response NotificationPolicy will be returned. The response will return an error if the given NotificationPolicy is invalid.",
                  "type": "boolean"
                },
                "notification_policy": {
                  "$ref": "#/definitions/configv1NotificationPolicy"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot update the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notifiers": {
      "get": {
        "operationId": "ListNotifiers",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Notifier with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Notifier with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotifiersResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "post": {
        "operationId": "CreateNotifier",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot create the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/notifiers/{slug}": {
      "delete": {
        "operationId": "DeleteNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Notifier because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "get": {
        "operationId": "ReadNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotifierResponse"
            }
          },
          "404": {
            "description": "Cannot read the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "put": {
        "operationId": "UpdateNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Notifier will be created if it does not already exist, identified by slug. If false, an error will be returned if the Notifier does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Notifier will not be created nor updated, and no response Notifier will be returned. The response will return an error if the given Notifier is invalid.",
                  "type": "boolean"
                },
                "notifier": {
                  "$ref": "#/definitions/configv1Notifier"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot update the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/recording-rules": {
      "get": {
        "operationId": "ListRecordingRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RecordingRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RecordingRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The execution_groups filter cannot be used when a bucket_slug filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The bucket_slugs filter cannot be used when an execution_group filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "execution_groups",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRecordingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "post": {
        "operationId": "CreateRecordingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/recording-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RecordingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "get": {
        "operationId": "ReadRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRecordingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "put": {
        "operationId": "UpdateRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the RecordingRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the RecordingRule does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the RecordingRule will not be created nor updated, and no response RecordingRule will be returned. The response will return an error if the given RecordingRule is invalid.",
                  "type": "boolean"
                },
                "recording_rule": {
                  "$ref": "#/definitions/configv1RecordingRule"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/resource-pools": {
      "delete": {
        "operationId": "DeleteResourcePools",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ResourcePools because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ResourcePools because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "get": {
        "operationId": "ReadResourcePools",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadResourcePoolsResponse"
            }
          },
          "404": {
            "description": "Cannot read the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "post": {
        "description": "ResourcePools CRUD (subset for singleton objects)",
        "operationId": "CreateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot create the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ResourcePools because there is a conflict with an existing ResourcePools.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "put": {
        "operationId": "UpdateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot update the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      }
    },
    "/api/v1/config/rollup-rules": {
      "get": {
        "operationId": "ListRollupRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RollupRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RollupRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any RollupRule with a matching bucket_slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRollupRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "post": {
        "operationId": "CreateRollupRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/rollup-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RollupRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "get": {
        "operationId": "ReadRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRollupRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "put": {
        "operationId": "UpdateRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the RollupRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the RollupRule does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the RollupRule will not be created nor updated, and no response RollupRule will be returned. The response will return an error if the given RollupRule is invalid.",
                  "type": "boolean"
                },
                "rollup_rule": {
                  "$ref": "#/definitions/configv1RollupRule"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/service-accounts": {
      "get": {
        "operationId": "ListServiceAccounts",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ServiceAccount with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ServiceAccount with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAccountsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "post": {
        "operationId": "CreateServiceAccount",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot create the ServiceAccount because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ServiceAccount because there is a conflict with an existing ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-accounts/{slug}": {
      "delete": {
        "operationId": "DeleteServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ServiceAccount because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "get": {
        "operationId": "ReadServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAccountResponse"
            }
          },
          "404": {
            "description": "Cannot read the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/services/{slug}": {
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/teams": {
      "get": {
        "operationId": "ListTeams",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Team with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Team with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTeamsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "post": {
        "operationId": "CreateTeam",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Team.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot create the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/teams/{slug}": {
      "delete": {
        "operationId": "DeleteTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTeamResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Team because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "get": {
        "operationId": "ReadTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTeamResponse"
            }
          },
          "404": {
            "description": "Cannot read the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "put": {
        "operationId": "UpdateTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the Team will be created if it does not already exist, identified by slug. If false, an error will be returned if the Team does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the Team will not be created nor updated, and no response Team will be returned. The response will return an error if the given Team is invalid.",
                  "type": "boolean"
                },
                "team": {
                  "$ref": "#/definitions/configv1Team"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Team.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot update the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the TraceJaegerRemoteSamplingStrategy will not be created nor updated, and no response TraceJaegerRemoteSamplingStrategy will be returned. The response will return an error if the given TraceJaegerRemoteSamplingStrategy is invalid.",
                  "type": "boolean"
                },
                "trace_jaeger_remote_sampling_strategy": {
                  "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules": {
      "get": {
        "operationId": "ListTraceMetricsRules",
        "parameters": [
          {
            "description": "Page size preference (i.e. how many items are returned in the next\npage). If zero, the server will use a default. Regardless of what size\nis given, clients must never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceMetricsRule with a matching slug in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceMetricsRule with a matching name in the given list (and matches all other filters) is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get trace metric rules by name.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "metric_names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceMetricsRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "post": {
        "description": "***\nTrace Metrics Rules\n***",
        "operationId": "CreateTraceMetricsRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules/{slug}": {
      "delete": {
        "operationId": "DeleteTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceMetricsRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "get": {
        "operationId": "ReadTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceMetricsRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "put": {
        "operationId": "UpdateTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "properties": {
                "create_if_missing": {
                  "description": "If true, the TraceMetricsRule will be created if it does not already exist, identified by slug. If false, an error will be returned if the TraceMetricsRule does not already exist.",
                  "type": "boolean"
                },
                "dry_run": {
                  "description": "If true, the TraceMetricsRule will not be created nor updated, and no response TraceMetricsRule will be returned. The response will return an error if the given TraceMetricsRule is invalid.",
                  "type": "boolean"
                },
                "trace_metrics_rule": {
                  "$ref": "#/definitions/configv1TraceMetricsRule"
                }
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigV1"
    }
  ]
}