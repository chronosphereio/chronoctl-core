{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "AllocationFixedValue": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "value": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThresholds": {
      "description": "Thresholds define strict quota limits for each metrics license.",
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "all_priorities": {
          "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
        },
        "default_and_low_priority": {
          "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
        },
        "low_priority": {
          "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzurePrincipal": {
      "properties": {
        "tenant_id": {
          "description": "Specifies the ID of the Azure tenant that hosts the managed identity principal.",
          "type": "string"
        },
        "client_id": {
          "description": "Specifies the OAuth2 client ID of the managed identity principal.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureResourceType": {
      "properties": {
        "name": {
          "description": "Name of the resource type.",
          "type": "string"
        },
        "metric_names": {
          "description": "List of metric names to be targeted (these apply to this resource type; use empty for all metrics).",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureScrapeConfig": {
      "properties": {
        "subscription_ids": {
          "description": "Subscriptions to be targeted for this integration (use empty for all subscriptions).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "locations": {
          "description": "Locations to be ingested for this integration (these apply to all subscriptions; use empty for all locations).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "resource_types": {
          "description": "Metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/AzureMetricsIntegrationAzureResourceType"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ConditionOp": {
      "enum": [
        "GEQ",
        "GT",
        "LEQ",
        "LT",
        "EQ",
        "NEQ",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "ConfigV1CreateServiceAttributeBody": {
      "properties": {
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        },
        "dry_run": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateAzureMetricsIntegrationBody": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        },
        "create_if_missing": {
          "description": "If `true`, the AzureMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the AzureMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the AzureMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the AzureMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateBucketBody": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "create_if_missing": {
          "description": "If `true`, the Bucket will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Bucket does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Bucket. If the specified configuration is valid, the endpoint returns a partial response without the Bucket. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateClassicDashboardBody": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateCollectionBody": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "create_if_missing": {
          "description": "If `true`, the Collection will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Collection does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Collection. If the specified configuration is valid, the endpoint returns a partial response without the Collection. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateConsumptionBudgetBody": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionBudget will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the ConsumptionBudget does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ConsumptionBudget. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionBudget. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDashboardBody": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the Dashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Dashboard. If the specified configuration is valid, the endpoint returns a partial response without the Dashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDatasetBody": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "create_if_missing": {
          "description": "If `true`, the Dataset will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dataset does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Dataset. If the specified configuration is valid, the endpoint returns a partial response without the Dataset. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedLabelBody": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "create_if_missing": {
          "description": "If `true`, the DerivedLabel will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedLabel does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DerivedLabel. If the specified configuration is valid, the endpoint returns a partial response without the DerivedLabel. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedMetricBody": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "create_if_missing": {
          "description": "If `true`, the DerivedMetric will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedMetric does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DerivedMetric. If the specified configuration is valid, the endpoint returns a partial response without the DerivedMetric. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDropRuleBody": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "create_if_missing": {
          "description": "If `true`, the DropRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DropRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DropRule. If the specified configuration is valid, the endpoint returns a partial response without the DropRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGcpMetricsIntegrationBody": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "create_if_missing": {
          "description": "If `true`, the GcpMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GcpMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GcpMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the GcpMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGrafanaDashboardBody": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleActionBody": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "create_if_missing": {
          "description": "If `true`, the LogScaleAction will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAction does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogScaleAction. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAction. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleAlertBody": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "create_if_missing": {
          "description": "If `true`, the LogScaleAlert will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAlert does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogScaleAlert. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAlert. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMappingRuleBody": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the MappingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MappingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the MappingRule. If the specified configuration is valid, the endpoint returns a partial response without the MappingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMonitorBody": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "create_if_missing": {
          "description": "If `true`, the Monitor will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Monitor does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Monitor. If the specified configuration is valid, the endpoint returns a partial response without the Monitor. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMutingRuleBody": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the MutingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MutingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the MutingRule. If the specified configuration is valid, the endpoint returns a partial response without the MutingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotificationPolicyBody": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "create_if_missing": {
          "description": "If `true`, the NotificationPolicy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the NotificationPolicy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the NotificationPolicy. If the specified configuration is valid, the endpoint returns a partial response without the NotificationPolicy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotifierBody": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "create_if_missing": {
          "description": "If `true`, the Notifier will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Notifier does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Notifier. If the specified configuration is valid, the endpoint returns a partial response without the Notifier. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRecordingRuleBody": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "create_if_missing": {
          "description": "If `true`, the RecordingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RecordingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the RecordingRule. If the specified configuration is valid, the endpoint returns a partial response without the RecordingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRollupRuleBody": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "create_if_missing": {
          "description": "If `true`, the RollupRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RollupRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the RollupRule. If the specified configuration is valid, the endpoint returns a partial response without the RollupRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateSLOBody": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        },
        "create_if_missing": {
          "description": "If `true`, the SLO will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the SLO does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the SLO. If the specified configuration is valid, the endpoint returns a partial response without the SLO. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateServiceAttributeBody": {
      "properties": {
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        },
        "create_if_missing": {
          "type": "boolean"
        },
        "dry_run": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTeamBody": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "create_if_missing": {
          "description": "If `true`, the Team will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Team does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Team. If the specified configuration is valid, the endpoint returns a partial response without the Team. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceBehaviorBody": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceBehavior will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceBehavior does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceBehavior. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehavior. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceMetricsRuleBody": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceMetricsRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceMetricsRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceMetricsRule. If the specified configuration is valid, the endpoint returns a partial response without the TraceMetricsRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConstructedLabelValueDefinition": {
      "properties": {
        "value": {
          "type": "string"
        },
        "filters": {
          "description": "Determine when to apply `name_mappings`, filtering out all other values.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetAlertActionConfig": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional annotations to set on the generated monitor. By default, the\nmonitors already contain \"description\", \"dashboard\", \"resource\",\n\"consumption_budget_slug\", \"threshold_type\", and \"partition\" annotations.\nSetting any of these annotations will override its default value.",
          "type": "object"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional labels to set on the generated monitor, which can be used for\nnotification routing. The following labels are reserved and cannot be\noverride: \"resource\", \"partition\", and \"threshold_type\".",
          "type": "object"
        },
        "instant_rate_sustain_secs": {
          "description": "How long instant rate consumption must sustain above the threshold in\norder to fire an alert. By default, the sustain is 0: any consumption\nover the threshold will fire an alert.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetPriority": {
      "properties": {
        "filters": {
          "description": "Criteria that defines which data matches the `priority`. Filters are\nconcatenated together as implied `AND` operators. A request must match every\nfilter to match the `priority`.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetPriorityFilter"
          },
          "type": "array"
        },
        "priority": {
          "description": "Priority order that determines when to drop data. A priority of `10` is\ndropped first, and a priority of `1` is dropped last.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetPriorityFilter": {
      "properties": {
        "dataset_slug": {
          "description": "If set, matches incoming data that belongs to the specified dataset.\nThe dataset type must match the budget resource. For example,\n`resource=LOG_PERSISTED_BYTES`, then the dataset type must be\n`type=LOGS`.\n\nExactly one of `dataset_slug` or `log_filter` must be set.",
          "type": "string"
        },
        "log_filter": {
          "$ref": "#/definitions/configv1LogSearchFilter"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetThresholdAction": {
      "enum": [
        "ALERT_WARN",
        "ALERT_CRITICAL",
        "DROP"
      ],
      "type": "string"
    },
    "ConsumptionBudgetThresholdType": {
      "enum": [
        "DAILY_VOLUME",
        "INSTANT_RATE",
        "WEEKLY_VOLUME",
        "MONTHLY_VOLUME",
        "HOURLY_VOLUME",
        "ROLLING_1_HOUR_VOLUME",
        "ROLLING_3_HOUR_VOLUME"
      ],
      "type": "string"
    },
    "ConsumptionConfigPartition": {
      "properties": {
        "name": {
          "description": "Name of the partition. Must be unique within the parent partition. You can\nmodify this value after the partition is created.",
          "type": "string"
        },
        "filters": {
          "description": "Criteria that defines which data matches the `partition`. Filters are\nconcatenated together as implied `AND` operators. A request must match every\nfilter to match the `partition`.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartitionFilter"
          },
          "type": "array"
        },
        "partitions": {
          "description": "Optional. Child partitions of this partition. If set, requests that match the\ncurrent partition are allocated to the first child partition that matches.\nRequests that don't match any child partition are assigned to an implicit `default`\nchild partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        },
        "slug": {
          "description": "Immutable identifier of the partition. Must be unique within the parent\npartition. You can't modify this value after the partition is created.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConsumptionConfigPartitionFilter": {
      "properties": {
        "operator": {
          "$ref": "#/definitions/FilterOperator"
        },
        "conditions": {
          "description": "Conditions for the query to match.",
          "items": {
            "$ref": "#/definitions/PartitionFilterCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DatasetDatasetConfiguration": {
      "properties": {
        "type": {
          "$ref": "#/definitions/DatasetDatasetType"
        },
        "trace_dataset": {
          "$ref": "#/definitions/configv1TraceDataset"
        },
        "log_dataset": {
          "$ref": "#/definitions/configv1LogDataset"
        }
      },
      "type": "object"
    },
    "DatasetDatasetType": {
      "enum": [
        "TRACES",
        "LOGS"
      ],
      "type": "string"
    },
    "DefinitionBurnRateDefinition": {
      "properties": {
        "window": {
          "description": "Time window for the burn rate calculation.",
          "type": "string"
        },
        "budget": {
          "description": "The amount of allowed errors during a given time window, expressed as a\npercentage of the error budget. Must be a value between `0.0` and `100.0`,\nexclusive.",
          "example": "50.0",
          "format": "double",
          "type": "number"
        },
        "severity": {
          "description": "Defines the alert severity level, which can only be one of `critical` or\n`warn`.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to attach when this burn rate triggers. If you add these labels to\n`signal_groupings`, you can route them in the notification policy, and can\nroute different burn rates to other notifiers.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "DefinitionTimeWindow": {
      "properties": {
        "duration": {
          "description": "Time window that defines the evaluation period as a string, in the format\nlike `\"28d\"` (28 days) or `\"24h\"` (24 hours).",
          "example": "\"30d\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DerivedLabelMetricLabel": {
      "properties": {
        "constructed_label": {
          "$ref": "#/definitions/MetricLabelConstructedLabel"
        },
        "mapping_label": {
          "$ref": "#/definitions/MetricLabelMappingLabel"
        }
      },
      "type": "object"
    },
    "DerivedLabelSpanTag": {
      "properties": {
        "name_mappings": {
          "description": "Determines where the input data for a derived label comes from. For each\nname mapping, you must define a `source_label`. If multiple name mappings\nare defined, the first name mapping that matches is used to map the source\ntag to the derived tag.",
          "items": {
            "$ref": "#/definitions/DerivedLabelSpanTagNameMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedLabelSpanTagNameMapping": {
      "properties": {
        "source_tag": {
          "description": "The source span tag name.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DerivedMetricQuery": {
      "properties": {
        "prometheus_expr": {
          "description": "PromQL expression the derived metric executes. The expression should\ninclude all configured variables.",
          "example": "cpu_usage{$service, $instance} / sum(cpu_usage{$service})",
          "type": "string"
        },
        "variables": {
          "description": "Optional. Specifies the variables that can be used in the derived metric as\nlabel selectors.",
          "items": {
            "$ref": "#/definitions/DerivedMetricVariable"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelector": {
      "properties": {
        "labels": {
          "description": "Labels that must match in the derived metric usage for the selector to match.",
          "items": {
            "$ref": "#/definitions/configv1DerivedMetricLabelMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelectorQuery": {
      "properties": {
        "selector": {
          "$ref": "#/definitions/DerivedMetricSelector"
        },
        "query": {
          "$ref": "#/definitions/DerivedMetricQuery"
        }
      },
      "type": "object"
    },
    "DerivedMetricVariable": {
      "properties": {
        "name": {
          "description": "Name of the variable.",
          "example": "service",
          "type": "string"
        },
        "default_prometheus_selector": {
          "description": "PromQL label selector, which must match the given variable name. If the\nvariable is not specified in the derived metric usage, then the default\nselector is used.",
          "example": "service=~\".*\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DropRuleConditionalRateBasedDrop": {
      "description": "No longer supported and cannot be used.\nDefines behavior for conditional drop policies.",
      "properties": {
        "enabled": {
          "description": "Enables rate-based metric dropping.",
          "type": "boolean"
        },
        "rate_limit_threshold": {
          "description": "Percentage of the licensed limit reached in order to activate the drop\nrule, between 0 and 100.",
          "format": "double",
          "type": "number"
        },
        "activated_drop_duration_secs": {
          "description": "Once activated, activated_drop_duration_secs defines how long the drop\nrule stays activated before rechecking against the rate_limit_threshold.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DropRuleValueBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables dropping metrics based on a set value.",
          "type": "boolean"
        },
        "target_drop_value": {
          "description": "The target data point value at which to drop metrics.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "EmitMetricsCounter": {
      "properties": {
        "value": {
          "$ref": "#/definitions/configv1LogFieldPath"
        }
      },
      "type": "object"
    },
    "EmitMetricsGauge": {
      "properties": {
        "value": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "aggregation_type": {
          "$ref": "#/definitions/GaugeAggregationType"
        }
      },
      "type": "object"
    },
    "EmitMetricsHistogram": {
      "properties": {
        "value": {
          "$ref": "#/definitions/configv1LogFieldPath"
        }
      },
      "type": "object"
    },
    "EmitMetricsMetricMode": {
      "enum": [
        "COUNTER",
        "GAUGE",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "FilterOperator": {
      "enum": [
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "GaugeAggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX"
      ],
      "type": "string"
    },
    "GcpMetricsIntegrationMetricGroup": {
      "properties": {
        "project_id": {
          "description": "The Google Cloud project ID that can access the metric data.",
          "type": "string"
        },
        "prefixes": {
          "description": "A list of Google Cloud metric prefixes to ingest.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "GraphiteLabelPolicyReplace": {
      "properties": {
        "name": {
          "description": "Name of the label to replace the value for. Only positional Graphite labels\nsuch as `__gX__` are allowed.",
          "example": "__g1__",
          "type": "string"
        },
        "new_value": {
          "description": "New value of the replaced label.",
          "example": "ALL_HOSTS",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByGroupByKey": {
      "description": "GroupByKey describes a key to group by.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GroupByKeyGroupByKeyType"
        },
        "named_key": {
          "description": "For named key types, such as span tags, indicates the name of the key to\ngroup by.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GroupByKeyGroupByKeyType": {
      "description": " - SERVICE: The service to group by.\n - OPERATION: The operation to group by.\n - TAG: The span tag to group by.",
      "enum": [
        "SERVICE",
        "OPERATION",
        "TAG"
      ],
      "type": "string"
    },
    "HTTPConfigBasicAuth": {
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "HTTPConfigTLSConfig": {
      "properties": {
        "insecure_skip_verify": {
          "description": "If `true`, disables validation of the server certificate.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ListMutingRulesRequestState": {
      "enum": [
        "PENDING",
        "ACTIVE",
        "EXPIRED"
      ],
      "type": "string"
    },
    "LogAllocationConfigDatasetAllocation": {
      "properties": {
        "dataset_slug": {
          "description": "Slug of the dataset.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDefaultDataset": {
      "description": "Configuration for default dataset.",
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
        }
      },
      "type": "object"
    },
    "LogAllocationConfigHighLowPriorities": {
      "description": "Defines explicit high and low priority match criteria to specify which logs to\ndrop first (low) and last (high). Anything not matched by either set of rules is\nconsidered default priority and is dropped after low priority but before high\npriority data.",
      "properties": {
        "high_priority_filters": {
          "description": "A list of search filters defining which logs are considered high priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "A list of search filters defining which logs are considered low priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogControlRuleDropField": {
      "description": "DropField is the configuration for a drop field action.",
      "properties": {
        "field_regex": {
          "description": "Defines the the regular expression that determines which fields to drop.",
          "type": "string"
        },
        "parent_path": {
          "$ref": "#/definitions/configv1LogFieldPath"
        }
      },
      "type": "object"
    },
    "LogControlRuleEmitMetrics": {
      "description": "EmitMetrics is the configuration for emit metrics action.",
      "properties": {
        "mode": {
          "$ref": "#/definitions/EmitMetricsMetricMode"
        },
        "name": {
          "description": "A unique name for the generated metric. This name must conform to Prometheus\nnaming conventions.",
          "type": "string"
        },
        "labels": {
          "description": "The labels to emit with the metric, specified as key/value pairs. The\ngenerated label is a valid Prometheus label name, mapped to a log key.",
          "items": {
            "$ref": "#/definitions/LogControlRuleEmitMetricsLabel"
          },
          "type": "array"
        },
        "drop_log": {
          "description": "Optional. If `true`, drops the entire log after emitting the defined metric.",
          "type": "boolean"
        },
        "counter": {
          "$ref": "#/definitions/EmitMetricsCounter"
        },
        "gauge": {
          "$ref": "#/definitions/EmitMetricsGauge"
        },
        "histogram": {
          "$ref": "#/definitions/EmitMetricsHistogram"
        }
      },
      "type": "object"
    },
    "LogControlRuleEmitMetricsLabel": {
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/configv1LogFieldPath"
        }
      },
      "type": "object"
    },
    "LogControlRuleReplaceField": {
      "description": "ReplaceField is the configuration for a replace field action.",
      "properties": {
        "field": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "replace_regex": {
          "description": "Defines the the regular expression that determines which part of the field to\nreplace.",
          "type": "string"
        },
        "replace_all": {
          "description": "Determines whether to replace all matches or just the first match.",
          "type": "boolean"
        },
        "replace_mode": {
          "$ref": "#/definitions/ReplaceFieldReplaceMode"
        },
        "static_value": {
          "$ref": "#/definitions/ReplaceFieldStaticValue"
        },
        "mapped_value": {
          "$ref": "#/definitions/ReplaceFieldMappedValue"
        }
      },
      "type": "object"
    },
    "LogControlRuleSample": {
      "description": "Sample is the configuration for the sample logs action.",
      "properties": {
        "rate": {
          "description": "Percentage of matching logs to keep. Must be in the range `[0, 1]`, where `1`\nis equal to 100% of logs. For example, to keep 25% of logs, enter `0.25` as\nthe `rate`.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "LogIngestConfigFieldNormalization": {
      "description": "FieldNormalization allows you to map and normalize well-known fields from your logs.\nThese mappings run after parsing to standardize common fields like timestamp,\nseverity level, primary key name, and message across different log formats.",
      "properties": {
        "primary_key": {
          "$ref": "#/definitions/LogIngestConfigNamedStringNormalization"
        },
        "timestamp": {
          "$ref": "#/definitions/LogIngestConfigTimestampNormalization"
        },
        "severity": {
          "$ref": "#/definitions/LogIngestConfigStringNormalization"
        },
        "message": {
          "$ref": "#/definitions/LogIngestConfigStringNormalization"
        },
        "custom_field_normalization": {
          "description": "Maps additional custom fields from your logs. These will not be indexed.\nUse these for any other fields you want to normalize, such as environment, region, or user ID.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigNamedStringNormalization"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParser": {
      "properties": {
        "mode": {
          "$ref": "#/definitions/LogIngestConfigLogFieldParserMode"
        },
        "source": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "destination": {
          "$ref": "#/definitions/configv1LogFieldPath"
        },
        "parser": {
          "$ref": "#/definitions/LogIngestConfigLogParser"
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogIngestConfigLogParser": {
      "properties": {
        "parser_type": {
          "$ref": "#/definitions/LogParserParserType"
        },
        "regex_parser": {
          "$ref": "#/definitions/LogParserRegexParser"
        },
        "key_value_parser": {
          "$ref": "#/definitions/LogParserKeyValueParser"
        }
      },
      "type": "object"
    },
    "LogIngestConfigNamedStringNormalization": {
      "description": "NamedStringNormalization maps a field to a named target with optional transformations.",
      "properties": {
        "target": {
          "description": "The name of the target field where the normalized value will be stored.",
          "type": "string"
        },
        "normalization": {
          "$ref": "#/definitions/LogIngestConfigStringNormalization"
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParser": {
      "properties": {
        "name": {
          "description": "The name of the parser. Must be unique within the configuration.",
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/LogIngestConfigPlaintextParserMode"
        },
        "parser": {
          "$ref": "#/definitions/LogIngestConfigLogParser"
        },
        "keep_original": {
          "description": "If `true`, the original log is retained after parsing and stored in the\nkey `plaintext_log`. If `false`, the original log is dropped after parsing.\nDefault value: `false`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogIngestConfigStringNormalization": {
      "description": "StringNormalization defines how to extract and transform string values from log fields.",
      "properties": {
        "source": {
          "description": "List of field paths to check for values, in priority order.\nThe first non-empty value found will be used.",
          "items": {
            "$ref": "#/definitions/configv1LogFieldPath"
          },
          "type": "array"
        },
        "default_value": {
          "description": "Default value to use when no source fields contain values.",
          "type": "string"
        },
        "value_map": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional mapping to normalize values.\nFor example: {\"warn\": \"WARNING\", \"err\": \"ERROR\"} to standardize severity levels.",
          "type": "object"
        },
        "sanitize_patterns": {
          "description": "Optional regex patterns to extract and sanitize values.\nEach pattern must have exactly one capturing group that will be used as the result.\nFor example: \"^.*level=([A-Z]+).*$\" to extract log level from a string.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogIngestConfigTimestampNormalization": {
      "description": "TimestampNormalization specifies which fields to check for timestamp values.",
      "properties": {
        "source": {
          "description": "List of field paths to check for timestamp values, in priority order.\nCommon fields include \"timestamp\", \"@timestamp\", \"time\", \"datetime\".",
          "items": {
            "$ref": "#/definitions/configv1LogFieldPath"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogParserKeyValueParser": {
      "description": "A parser to extract key/value pairs from a string.\nIf duplicate keys are found, the first instance is used.",
      "properties": {
        "pair_separator": {
          "description": "The string for splitting each pair into its key and value.",
          "type": "string"
        },
        "delimiter": {
          "description": "The string for splitting the input into key/value pairs.",
          "type": "string"
        },
        "trim_set": {
          "description": "Specifies the code points of any Unicode characters to trim from the\nbeginning and end of keys and values.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogParserParserType": {
      "enum": [
        "JSON",
        "REGEX",
        "KEY_VALUE"
      ],
      "type": "string"
    },
    "LogParserRegexParser": {
      "properties": {
        "regex": {
          "description": "The regular expression parser pattern to apply. Must use RE2 syntax.\nNamed capturing groups become named fields in the extracted log.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionActionType": {
      "enum": [
        "EMAIL",
        "HUMIO_REPO",
        "OPS_GENIE",
        "PAGER_DUTY",
        "SLACK",
        "SLACK_POST_MESSAGE",
        "VICTOR_OPS",
        "WEBHOOK",
        "UPLOAD_FILE"
      ],
      "type": "string"
    },
    "LogScaleActionEmailAction": {
      "properties": {
        "recipients": {
          "description": "List of email addresses to send an email to.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject_template": {
          "description": "Subject of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "body_template": {
          "description": "Body of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "attach_csv": {
          "description": "Whether the result set should be attached as a CSV file.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionHumioRepoAction": {
      "properties": {
        "ingest_token": {
          "description": "Ingest token for the repository that the action should ingest into.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionOpsGenieAction": {
      "properties": {
        "api_url": {
          "description": "OpsGenie webhook URL to send the request to.",
          "type": "string"
        },
        "ops_genie_key": {
          "description": "Key to authenticate with OpsGenie.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionPagerDutyAction": {
      "properties": {
        "severity": {
          "$ref": "#/definitions/PagerDutyActionSeverity"
        },
        "routing_key": {
          "description": "Routing key to authenticate with PagerDuty.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackAction": {
      "properties": {
        "url": {
          "description": "Slack webhook URL to send the request to.",
          "type": "string"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackPostMessageAction": {
      "properties": {
        "api_token": {
          "description": "API token to authenticate with Slack.",
          "type": "string"
        },
        "channels": {
          "description": "List of Slack channels to message.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionUploadFileAction": {
      "properties": {
        "file_name": {
          "description": "File name for the uploaded file.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionVictorOpsAction": {
      "properties": {
        "message_type": {
          "description": "Type of the VictorOps message to make.",
          "type": "string"
        },
        "notify_url": {
          "description": "VictorOps webhook URL to send the request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionWebhookAction": {
      "properties": {
        "method": {
          "$ref": "#/definitions/WebhookActionHTTPMethod"
        },
        "url": {
          "description": "URL to send the HTTP or HTTPS request to.",
          "type": "string"
        },
        "headers": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers of the HTTP or HTTPS request.",
          "type": "object"
        },
        "body_template": {
          "description": "Body of the HTTP or HTTPS request. Can be templated with values from the query result.",
          "type": "string"
        },
        "ignore_ssl": {
          "description": "Flag indicating whether SSL should be ignored for the request.",
          "type": "boolean"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleAlertAlertType": {
      "enum": [
        "STANDARD",
        "FILTER"
      ],
      "type": "string"
    },
    "MappedValueReplacePair": {
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingLabelValueMapping": {
      "properties": {
        "source_value_globs": {
          "description": "Defines the source label values that map into the given `target_value`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_value": {
          "description": "The value that `source_value_globs` are mapped into. For example, this\nmapping indicates that the target value `cat` maps to the source label's\nvalues of `Cat` and `CAT`.:\n```yaml\nvalue_mappings:\n - source_value_globs:\n     - Cat\n     - CAT\n   target_value: cat\n```",
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingRuleAggregationPolicy": {
      "properties": {
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1MappingRuleStoragePolicy"
        },
        "interval": {
          "description": "The interval between aggregated data points.",
          "type": "string"
        },
        "drop_timestamp": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MetricLabelConstructedLabel": {
      "properties": {
        "value_definitions": {
          "items": {
            "$ref": "#/definitions/ConstructedLabelValueDefinition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabel": {
      "properties": {
        "name_mappings": {
          "description": "Determines where the input data for a derived label comes from. For each\nname mapping, you must define a `source_label`. If multiple name mappings\nare defined, the first name mapping that matches is used to map the source\nlabel to the derived label.",
          "items": {
            "$ref": "#/definitions/MetricLabelMappingLabelNameMapping"
          },
          "type": "array"
        },
        "value_mappings": {
          "description": "These value mappings apply to the whole mapping label.\nIf there's no name_mappings, these value mappings apply to the label that exists on the metric.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabelNameMapping": {
      "properties": {
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "source_label": {
          "description": "The source label name on the time series from when it was ingested.",
          "type": "string"
        },
        "value_mappings": {
          "description": "These value mappings apply only to the name mapping they belong to.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricsRestrictionPermission": {
      "enum": [
        "READ",
        "WRITE",
        "READ_WRITE"
      ],
      "type": "string"
    },
    "MonitorSchedule": {
      "properties": {
        "timezone": {
          "description": "The timezone of the time ranges.",
          "type": "string"
        },
        "weekly_schedule": {
          "$ref": "#/definitions/ScheduleWeeklySchedule"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditions": {
      "description": "Conditions evaluated against each queried series to determine the severity of each series.",
      "properties": {
        "defaults": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        },
        "overrides": {
          "description": "Optional. Specifies a list of overrides to use for series having matching\nlabels. Each override defines labels that potentially match a series' labels.\nIf one or more overrides match a series, the severity conditions of the first\nmatching override are used instead of the defaults.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "$ref": "#/definitions/MonitorSeriesConditionsOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditionsOverride": {
      "properties": {
        "label_matchers": {
          "description": "Set of matchers on a series' labels. If all labels match, then the conditions\ndefined in this override are used.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "severity_conditions": {
          "$ref": "#/definitions/SeriesConditionsSeverityConditions"
        }
      },
      "type": "object"
    },
    "MonitorSignalGrouping": {
      "description": "SignalGrouping defines how the set of series from the query are split into signals.",
      "properties": {
        "label_names": {
          "description": "Set of label names used to split series into signals. Each unique combination\nof labels result in its own signal. For example, if `label_names` is\n`[\"service\", \"code\"]`, then all series including labels\n`{service=\"foo\",code=\"404\"}` will be grouped together in the same signal.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "signal_per_series": {
          "description": "If set to `true`, each series will have its own signal. Cannot be used with\n`label_names`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutes": {
      "properties": {
        "defaults": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        },
        "overrides": {
          "description": "A list of overrides to use for alert notification policies. Each\noverride defines the labels that potentially match an alert. If an alert has\nmatching labels, the override notification policy is used for that alert\ninstead of the default notification policy. If multiple overrides match\nthe same alert, the first matching override notification policy is used.",
          "items": {
            "$ref": "#/definitions/NotificationPolicyRoutesOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesGroupBy": {
      "properties": {
        "label_names": {
          "description": "Set of label names used to group alerts.\nFor example, if label_names is [\"service\", \"code\"] then all alerts including labels {service=\"foo\",code=\"404\"}\nwill be grouped together.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesOverride": {
      "properties": {
        "alert_label_matchers": {
          "description": "The alert labels to match against. If an alert matches all of these labels,\nthe override notifier is applied to that alert.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "notifiers": {
          "$ref": "#/definitions/RoutesSeverityNotifiers"
        }
      },
      "type": "object"
    },
    "NotifierEmailConfig": {
      "properties": {
        "to": {
          "description": "The email address to send notifications to. Required if including an\n`email` object in your request body.",
          "type": "string"
        },
        "html": {
          "description": "The body of the email to send, in HTML format.",
          "type": "string"
        },
        "text": {
          "description": "The body of the email to send, in plain text format.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierHTTPConfig": {
      "properties": {
        "basic_auth": {
          "$ref": "#/definitions/HTTPConfigBasicAuth"
        },
        "bearer_token": {
          "description": "Sets a token for bearer authentication. Cannot be set if `basic_auth` is set.",
          "type": "string"
        },
        "proxy_url": {
          "description": "Your proxy URL. (This parameter is deprecated, and custom proxies are\nunsupported.)",
          "type": "string"
        },
        "tls_config": {
          "$ref": "#/definitions/HTTPConfigTLSConfig"
        }
      },
      "type": "object"
    },
    "NotifierOpsGenieConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Your Opsgenie API key. Required if including an `ops_genie` object in your\nrequest body.",
          "type": "string"
        },
        "api_url": {
          "description": "The Opsgenie API URL to send requests to. Required if including an\n`ops_genie` object in your request body.",
          "example": "https://api.opsgenie.com/",
          "type": "string"
        },
        "message": {
          "description": "The alert text.",
          "type": "string"
        },
        "description": {
          "description": "A description of the alert.",
          "type": "string"
        },
        "source": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value pairs with additional information about the alert. These\nkey/value pairs can include any arbitrary data.",
          "type": "object"
        },
        "responders": {
          "description": "List of responders responsible for notifications.",
          "items": {
            "$ref": "#/definitions/OpsGenieConfigResponder"
          },
          "type": "array"
        },
        "tags": {
          "description": "A comma-separated list of tags attached to the notifications.",
          "type": "string"
        },
        "note": {
          "description": "A note about the alert.",
          "type": "string"
        },
        "priority": {
          "description": "The priority level of alert. Possible values are `P1`, `P2`, `P3`, `P4`, and `P5`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierPagerdutyConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "The Pagerduty URL to send API requests to.",
          "type": "string"
        },
        "client": {
          "description": "The client identification of the notification sender.",
          "type": "string"
        },
        "client_url": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "description": {
          "description": "A description of the incident.",
          "type": "string"
        },
        "severity": {
          "description": "The severity of the incident. Possible values: `critical`, `error`,\n`warning`, or `info`.",
          "type": "string"
        },
        "class": {
          "description": "The class of the event.",
          "type": "string"
        },
        "component": {
          "description": "The part or component of the affected system that is broken.",
          "type": "string"
        },
        "group": {
          "description": "A cluster or grouping of services.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value pairs with additional information about the incident. These\nkey/value pairs can include any arbitrary data.",
          "type": "object"
        },
        "images": {
          "description": "Images to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigImage"
          },
          "type": "array"
        },
        "links": {
          "description": "Links to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigLink"
          },
          "type": "array"
        },
        "service_key": {
          "description": "Your PagerDuty integration key, if using the PagerDuty integration type\n`Prometheus`. Cannot be set if `routing_key` is set.",
          "type": "string"
        },
        "routing_key": {
          "description": "Your PagerDuty integration key, if using the PagerDuty integration type\n`Events API v2`. Cannot be set if `service_key` is set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_url": {
          "description": "Your Slack webhook API URL. Required if including a `slack` object in\nyour request body.",
          "type": "string"
        },
        "channel": {
          "description": "The channel to send notifications to.",
          "type": "string"
        },
        "username": {
          "description": "The user to send notifications to.",
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "title_link": {
          "type": "string"
        },
        "pretext": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "footer": {
          "type": "string"
        },
        "fallback": {
          "type": "string"
        },
        "callback_id": {
          "type": "string"
        },
        "icon_emoji": {
          "type": "string"
        },
        "icon_url": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "thumb_url": {
          "type": "string"
        },
        "short_fields": {
          "type": "boolean"
        },
        "link_names": {
          "type": "boolean"
        },
        "mrkdwn_in": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "items": {
            "$ref": "#/definitions/SlackConfigField"
          },
          "type": "array"
        },
        "actions": {
          "items": {
            "$ref": "#/definitions/NotifierSlackConfigAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfigAction": {
      "properties": {
        "type": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "style": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "confirm_field": {
          "$ref": "#/definitions/SlackConfigConfirmationField"
        }
      },
      "type": "object"
    },
    "NotifierVictorOpsConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "api_key": {
          "description": "Your VictorOps API key. Required if including a `victor_ops` object in\nyour request body.",
          "type": "string"
        },
        "api_url": {
          "description": "The VictorOps API URL. Required if including a `victor_ops` object in your\nrequest body.",
          "type": "string"
        },
        "routing_key": {
          "description": "Your VictorOps routing key. Required if including a `victor_ops` object in\nyour request body.",
          "type": "string"
        },
        "message_type": {
          "description": "The behavior of the alert. Possible values are `CRITICAL`, `WARNING`, and\n`INFO`.",
          "type": "string"
        },
        "entity_display_name": {
          "description": "A summary of the alerted problem.",
          "type": "string"
        },
        "state_message": {
          "description": "A detailed explanation of the alerted problem.",
          "type": "string"
        },
        "monitoring_tool": {
          "description": "The monitoring tool from which the state message originated.",
          "type": "string"
        },
        "custom_fields": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "NotifierWebhookConfig": {
      "properties": {
        "http_config": {
          "$ref": "#/definitions/NotifierHTTPConfig"
        },
        "url": {
          "description": "Your webhook URL. This URL will be called as a `POST` request. Required\nif including a `webhook` object in your request body.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OpsGenieConfigResponder": {
      "properties": {
        "id": {
          "description": "The ID of the responder. Cannot be set if `name` or `username` are set.",
          "type": "string"
        },
        "name": {
          "description": "The name of the responder. Cannot be set if `id` or `username` are set.",
          "type": "string"
        },
        "username": {
          "description": "The username of the responder. Cannot be set if `id` or `name` are set.",
          "type": "string"
        },
        "responder_type": {
          "$ref": "#/definitions/ResponderResponderType"
        }
      },
      "type": "object"
    },
    "OtelMetricsIngestionResourceAttributes": {
      "properties": {
        "flatten_mode": {
          "$ref": "#/definitions/ResourceAttributesFlattenMode"
        },
        "filter_mode": {
          "$ref": "#/definitions/ResourceAttributesFilterMode"
        },
        "exclude_keys": {
          "description": "Specifies resource attributes to exclude. If a resource attribute's key\nmatches any of the strings in this array, that resource attribute is\nexcluded.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "generate_target_info": {
          "description": "If `true`, generates a `target_info` time series with labels derived from\nresource attributes. The `filter_mode` and `exclude_keys` settings apply\nin the same manner that they apply to the `flatten` operation. Default:\n`false`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PagerDutyActionSeverity": {
      "enum": [
        "CRITICAL",
        "ERROR",
        "WARNING",
        "INFO"
      ],
      "type": "string"
    },
    "PagerdutyConfigImage": {
      "properties": {
        "src": {
          "type": "string"
        },
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigLink": {
      "properties": {
        "href": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PartitionFilterCondition": {
      "properties": {
        "dataset_slug": {
          "description": "If set, matches incoming data that belongs to the specified dataset.\nThe dataset type must match the budget resource. For example,\n`resource=LOG_PERSISTED_BYTES`, then the dataset type must be\n`type=LOGS`.\n\nExactly one of `dataset_slug` or `log_filter` must be set.",
          "type": "string"
        },
        "log_filter": {
          "$ref": "#/definitions/configv1LogSearchFilter"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy applies.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        }
      },
      "type": "object"
    },
    "ReplaceFieldMappedValue": {
      "description": "MappedValue is the configuration for mapped value replace mode.",
      "properties": {
        "pairs": {
          "description": "A list of key/value pairs to replace matched content with.",
          "items": {
            "$ref": "#/definitions/MappedValueReplacePair"
          },
          "type": "array"
        },
        "use_default": {
          "description": "If `true`, specifies a default value if no matching key is found. If\n`false`, the value will be unchanged if no matching key is found.",
          "type": "boolean"
        },
        "default_value": {
          "description": "The value to use if no matching value is found.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReplaceFieldReplaceMode": {
      "description": " - HASH: Replace the matched content with a hashed string, which can help reduce the\nsize of large strings. After replacing the original content with a string,\ntheres no way to recover that information.\n - STATIC_VALUE: Replace the matched content with a static string. For example, replace\npunctuation in a field with an empty string, or truncate the ends of long\nstack traces.\n - MAPPED_VALUE: Replace the matched content with specified key/value pairs. For example,\nreduce log volume by replacing a string error with a specific error code. If\nnone of the key/value pairs match, the provided default value is used.\n\n@REQUIRED",
      "enum": [
        "HASH",
        "STATIC_VALUE",
        "MAPPED_VALUE"
      ],
      "type": "string"
    },
    "ReplaceFieldStaticValue": {
      "description": "StaticValue is the configuration for the replace field control rule in static value\nmode. Used to replace the selected content with a static value.",
      "properties": {
        "value": {
          "description": "The value to replace selected content with. If empty, the action removes the\nselected content.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ResourceAttributesFilterMode": {
      "enum": [
        "APPEND_DEFAULT_EXCLUDE_KEYS",
        "CUSTOM_EXCLUDE_KEYS"
      ],
      "type": "string"
    },
    "ResourceAttributesFlattenMode": {
      "enum": [
        "MERGE",
        "OVERWRITE",
        "IGNORE"
      ],
      "type": "string"
    },
    "ResourceChange": {
      "properties": {
        "resource": {
          "$ref": "#/definitions/configv1ResourceType"
        },
        "slug": {
          "type": "string"
        },
        "action": {
          "$ref": "#/definitions/ResourceChangeAction"
        }
      },
      "type": "object"
    },
    "ResourceChangeAction": {
      "enum": [
        "CREATED",
        "UPDATED",
        "DELETED",
        "NOOP"
      ],
      "type": "string"
    },
    "ResourcePoolsAllocationThreshold": {
      "properties": {
        "percent_of_pool_allocation": {
          "description": "Threshold expressed as a percent of the license allocated to a pool. A value\nof `100` represents a threshold that is the pool's full allocation. Values\nover `100` indicate thresholds that exceed the pool's allocation. For\nexample, a value of `50` represents a threshold that is half the pool's\nallocation, and a value of `200` represents a threshold that is double the\npool's allocation.",
          "format": "double",
          "type": "number"
        },
        "fixed_value": {
          "description": "Threshold expressed as a fixed value of the license.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ResourcePoolsDefaultPool": {
      "properties": {
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported. See the [product documentation](https://docs.chronosphere.io/control/shaping/quotas/define-pools#pool-thresholds)\nfor more information.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResourcePoolsLicense": {
      "enum": [
        "PERSISTED_WRITES_STANDARD",
        "PERSISTED_WRITES_HISTOGRAM",
        "PERSISTED_CARDINALITY_STANDARD",
        "PERSISTED_CARDINALITY_HISTOGRAM",
        "MATCHED_WRITES_STANDARD",
        "MATCHED_WRITES_HISTOGRAM"
      ],
      "type": "string"
    },
    "ResourcePoolsPool": {
      "properties": {
        "name": {
          "description": "Name of the pool, which must be unique.",
          "type": "string"
        },
        "allocation": {
          "$ref": "#/definitions/configv1ResourcePoolsAllocation"
        },
        "filters": {
          "description": "Filters that define which metrics map to this pool, where any metric that\nmatches at least one filter will map to the pool.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "priorities": {
          "$ref": "#/definitions/ResourcePoolsPriorities"
        }
      },
      "type": "object"
    },
    "ResourcePoolsPriorities": {
      "properties": {
        "high_priority_filters": {
          "description": "Optional. Filters that define which metrics are high priority. Any metric that\nmatches at least one filter is considered high priority. High priority metrics\nare dropped last when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "Optional. Filters that define which metrics are low priority. Any metric that\nmatches at least one filter is considered low priority. Low priority metrics\nare dropped first when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResponderResponderType": {
      "enum": [
        "TEAM",
        "USER",
        "ESCALATION",
        "SCHEDULE"
      ],
      "type": "string"
    },
    "RollupRuleGraphiteLabelPolicy": {
      "properties": {
        "replace": {
          "description": "List of labels to replace. Use to discard high-cardinality values while still\npreserving the original positions of the Graphite metric.",
          "items": {
            "$ref": "#/definitions/GraphiteLabelPolicyReplace"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RollupRuleLabelReplace": {
      "description": "Must keep this around for backwards compatibility because terraform will\nstill send this key w/ a null value.",
      "type": "object"
    },
    "RollupRuleMetricType": {
      "description": " - CUMULATIVE_COUNTER: Alias of COUNTER.\n - DELTA_COUNTER: Alias of DELTA.",
      "enum": [
        "COUNTER",
        "GAUGE",
        "DELTA",
        "DISTRIBUTION",
        "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
        "MEASUREMENT",
        "CUMULATIVE_COUNTER",
        "DELTA_COUNTER",
        "DELTA_EXPONENTIAL_HISTOGRAM"
      ],
      "type": "string"
    },
    "RoutesNotifierList": {
      "properties": {
        "notifier_slugs": {
          "description": "The slugs of the notifiers that will receive the alerts.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "repeat_interval_secs": {
          "description": "The frequency at which to resend alerts.",
          "format": "int32",
          "type": "integer"
        },
        "group_by": {
          "$ref": "#/definitions/NotificationPolicyRoutesGroupBy"
        }
      },
      "type": "object"
    },
    "RoutesSeverityNotifiers": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/RoutesNotifierList"
        },
        "critical": {
          "$ref": "#/definitions/RoutesNotifierList"
        }
      },
      "type": "object"
    },
    "SLICustomIndicatorConfig": {
      "description": "Configuration for error ratio SLIs. You can include these variables in PromQL\nqueries for SLIs:\n- `{{.Window}}`: Specifies the window of time that the PromQL query operates on.\n- `{{.GroupBy}}`: Specifies a comma-separated list of signal and dimension\n  labels to group the results by.\n- `{{.AdditionalFilters}}`: Requires setting `additional_promql_filters`.",
      "properties": {
        "good_query_template": {
          "description": "A PromQL query that measures the number of \"good\" events for this SLI.\nEither this or `bad_query_template` must be set.",
          "type": "string"
        },
        "bad_query_template": {
          "description": "A PromQL query that measures the number of \"bad\" events for this SLI.\nEither this or `good_query_template` must be set.",
          "type": "string"
        },
        "total_query_template": {
          "description": "A PromQL query that measures the total number of events for this SLI.\nThis is required for all error ratio SLOs.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SLICustomTimeSliceIndicatorConfig": {
      "description": "Defines the configuration for time slice SLIs. Time slice SLIs are evaluated by\nrunning a PromQL query over a certain time window and comparing the result against\na condition. You can include these variables in PromQL queries for SLIs:\n- `{{.Window}}`: Specifies the window of time that the PromQL query operates on.\n- `{{.GroupBy}}`: Specifies a comma-separated list of signal and dimension labels\n  to group the results by.\n- `{{.TimeSlice}}`: The time slice being evaluated, such as `1m` or `5m`.\n- `{{.AdditionalFilters}}`: Requires setting `additional_promql_filters`.",
      "properties": {
        "query_template": {
          "description": "A PromQL query template for the time slice SLI.",
          "type": "string"
        },
        "timeslice_size": {
          "$ref": "#/definitions/SLITimeSliceSize"
        },
        "condition": {
          "$ref": "#/definitions/SLITimeSliceCondition"
        }
      },
      "type": "object"
    },
    "SLITimeSliceCondition": {
      "description": "Defines the condition for evaluating time slice SLIs.",
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "The value to compare against.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "SLITimeSliceSize": {
      "description": "Defines the supported time slice sizes for time slice SLIs.",
      "enum": [
        "TIMESLICE_SIZE_ONE_MINUTE",
        "TIMESLICE_SIZE_FIVE_MINUTES"
      ],
      "type": "string"
    },
    "SLODefinition": {
      "properties": {
        "objective": {
          "description": "The SLO target percentage, which represents the availability of the SLO.",
          "example": "99.9995",
          "format": "double",
          "type": "number"
        },
        "time_window": {
          "$ref": "#/definitions/DefinitionTimeWindow"
        },
        "burn_rate_alerting_config": {
          "description": "Provides the burn rate alert configuration for the SLO. If not provided, the\ndefault burn rates are used. The configuration is only valid if the\n`enable_burn_rate_alerting` flag is set to `true`.",
          "items": {
            "$ref": "#/definitions/DefinitionBurnRateDefinition"
          },
          "type": "array"
        },
        "enable_burn_rate_alerting": {
          "description": "If `true`, enables burn rate alerting.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ScheduleDayActive": {
      "enum": [
        "ALL_DAY",
        "ONLY_DURING_RANGES",
        "NEVER"
      ],
      "type": "string"
    },
    "ScheduleDayTimeRange": {
      "properties": {
        "start_hh_mm": {
          "description": "Start time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        },
        "end_hh_mm": {
          "description": "End time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScheduleScheduleDay": {
      "properties": {
        "active": {
          "$ref": "#/definitions/ScheduleDayActive"
        },
        "ranges": {
          "description": "The time ranges that the monitor is active on this day. Required if `active`\nis set to `ONLY_DURING_RANGES`. Otherwise, this field must be empty.",
          "items": {
            "$ref": "#/definitions/ScheduleDayTimeRange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ScheduleWeeklySchedule": {
      "properties": {
        "monday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "tuesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "wednesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "thursday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "friday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "saturday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "sunday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        }
      },
      "type": "object"
    },
    "SeriesConditionsConditions": {
      "properties": {
        "conditions": {
          "description": "List of conditions to evaluate against a series. Only one condition must\nmatch to assign a severity to a signal.",
          "items": {
            "$ref": "#/definitions/configv1MonitorCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SeriesConditionsSeverityConditions": {
      "properties": {
        "warn": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        },
        "critical": {
          "$ref": "#/definitions/SeriesConditionsConditions"
        }
      },
      "type": "object"
    },
    "ServiceAccountMetricsRestriction": {
      "properties": {
        "permission": {
          "$ref": "#/definitions/MetricsRestrictionPermission"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Specifies labels that further restrict the service account to only\nread or write metrics with the given label names and values.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SlackConfigConfirmationField": {
      "properties": {
        "text": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "ok_text": {
          "type": "string"
        },
        "dismiss_text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SlackConfigField": {
      "properties": {
        "title": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "short": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "ThresholdInstantRate": {
      "properties": {
        "fixed_value_per_sec": {
          "description": "Value of the fixed rate threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ThresholdVolume": {
      "properties": {
        "fixed_value": {
          "description": "Value of the volume threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigMainBehaviorAssignment": {
      "properties": {
        "created_at": {
          "description": "The timestamp of when the trace behavior was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the trace behavior was updated.",
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the behavior assignment.",
          "type": "string"
        },
        "description": {
          "description": "A description of the behavior assignment.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigOverrideBehaviorAssignment": {
      "properties": {
        "created_at": {
          "description": "The timestamp of when the override behavior assignment was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the override behavior assignment was updated.",
          "format": "date-time",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "start_time": {
          "description": "The starting time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "end_time": {
          "description": "The ending time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the override.",
          "type": "string"
        },
        "description": {
          "description": "A description of the override.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorErrorSampleOptions": {
      "properties": {
        "sample_rate": {
          "description": "Specifies the sample rate for traces with errors.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for error traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorFastSampleOptions": {
      "properties": {
        "max_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for fast traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorLargeTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "Defines the sampling rate for large traces. If the number of spans in the\ntrace is grater than or equal to (`\u003e=`) the `span_count_threshold`, the trace\nis sampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for large traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSamplingType": {
      "description": " - LOW_VALUE: Match indicates a low value trace. With multiple low value matches sample at the lowest rate.\n - HIGH_VALUE: Match indicates a high value trace. With multiple high value matches sample at the highest rate.",
      "enum": [
        "LOW_VALUE",
        "HIGH_VALUE"
      ],
      "type": "string"
    },
    "TraceBehaviorSlowSampleOptions": {
      "properties": {
        "min_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for slow traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSmallTraceSampleOptions": {
      "properties": {
        "span_count_threshold": {
          "description": "Defines the sampling rate for small traces. If the number of spans in the\ntrace is less than or equal to (`\u003c=`) the `span_count_threshold`, the trace is\nsampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "$ref": "#/definitions/TraceBehaviorSamplingType"
        },
        "enabled": {
          "description": "Determines whether or not to define options for small traces.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "probabilistic_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
        },
        "per_operation_strategies": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
        },
        "rate_limiting_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range `[0, 1]`) when\nspecific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the\ndefault sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range `[0, 1]` that defines the percentage probability of\nsampling any trace, where `0` is zero percent and `1` equals 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "min": {
          "description": "Minimum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        },
        "max": {
          "description": "Maximum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "$ref": "#/definitions/NumericFilterComparisonType"
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterScopeFilter": {
      "properties": {
        "span_scopes": {
          "description": "Specifies the span filters that define which spans contribute to the metrics calculation.\nOnly spans matching these filters will be included in the metrics aggregation.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
        },
        "service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_service": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "parent_operation": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        },
        "tags": {
          "description": "Matches the tags of the candidate span.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        },
        "span_count": {
          "$ref": "#/definitions/TraceSearchFilterCountFilter"
        },
        "is_root_span": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "match": {
          "$ref": "#/definitions/StringFilterStringFilterMatchType"
        },
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "string"
        },
        "in_values": {
          "description": "Values the filter tests against when using `IN` or `NOT_IN` match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key or name of the span tag that this filter inspects.",
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/TraceSearchFilterStringFilter"
        },
        "numeric_value": {
          "$ref": "#/definitions/TraceSearchFilterNumericFilter"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "$ref": "#/definitions/TraceSearchFilterDurationFilter"
        },
        "error": {
          "$ref": "#/definitions/TraceSearchFilterBoolFilter"
        }
      },
      "type": "object"
    },
    "WebhookActionHTTPMethod": {
      "enum": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "HEAD",
        "OPTIONS"
      ],
      "type": "string"
    },
    "apiError": {
      "properties": {
        "code": {
          "description": "An optional private error code whose values are undefined.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/commonPromQLMatcherType"
        },
        "name": {
          "description": "Prometheus label name for the matcher",
          "type": "string"
        },
        "value": {
          "description": "Prometheus label value for the matcher",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcherType": {
      "enum": [
        "MatchEqual",
        "MatchRegexp",
        "MatchNotEqual",
        "MatchNotRegexp"
      ],
      "type": "string"
    },
    "configv1AggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX",
        "MEAN",
        "MEDIAN",
        "COUNT",
        "SUM",
        "SUMSQ",
        "STDEV",
        "P10",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "P90",
        "P95",
        "P99",
        "P999",
        "P9999",
        "P25",
        "P75",
        "COUNT_SAMPLES",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "configv1AzureMetricsIntegration": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the AzureMetricsIntegration. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the AzureMetricsIntegration. You can modify this value after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "principal": {
          "$ref": "#/definitions/AzureMetricsIntegrationAzurePrincipal"
        },
        "scrape_config": {
          "$ref": "#/definitions/AzureMetricsIntegrationAzureScrapeConfig"
        },
        "count_metrics_enabled": {
          "description": "Enables Azure count metrics for the configured resources.",
          "type": "boolean"
        },
        "usage_metrics_enabled": {
          "description": "Enables collection of azure usage metrics under this principal (Microsoft.Compute, Microsoft.Network, Microsoft.Storage).",
          "type": "boolean"
        },
        "propagate_tags": {
          "description": "Specifies whether Azure resource, group, and subscription tags should be propagated as metric labels.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1Bucket": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Bucket. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Bucket is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Bucket. You can modify this value after the Bucket is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Bucket was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Bucket was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional description of the bucket.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels marking the bucket.",
          "type": "object"
        },
        "team_slug": {
          "description": "Optional slug of the team the bucket belongs to.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this bucket.\nThis is optional if the bucket does not contain monitors or all of its monitors explicitly reference a policy.\nThis policy takes precedence over a bucket-owned notification policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Collection": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Collection. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Collection is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Collection. You can modify this value after the Collection is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Collection was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Collection was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "A description of the collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "The slug of the default notification policy for monitors in this collection.\nThis value is only required when the collection contains monitors and one\nor more of those monitors don't explicitly reference a policy. This value does\nnot override the policy used when a monitor explicitly references a different\npolicy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReference": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1CollectionReferenceType"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CollectionReferenceType": {
      "description": "Type values must match entitiespb.Collection.CollectionType.",
      "enum": [
        "SIMPLE",
        "SERVICE"
      ],
      "type": "string"
    },
    "configv1ConsumptionBudget": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the ConsumptionBudget. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the ConsumptionBudget is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the ConsumptionBudget. You can modify this value after the ConsumptionBudget is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ConsumptionBudget was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionBudget was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource": {
          "$ref": "#/definitions/configv1ConsumptionBudgetResource"
        },
        "partition_slug_path": {
          "description": "Path of the budget's partition, delimited by forward slashes (`/`), in the\nformat `global/SLUG1/SLUG2`, where `SLUG1` is a top-level partition, and `SLUG2`\nis a child partition of `SLUG1`.\n\nA well-formed partition path always starts with the `global` partition slug, and\nhas no leading or trailing forward slashes.",
          "type": "string"
        },
        "priorities": {
          "description": "Optional. Controls the order in which data is dropped when a drop action is\napplied. For example, a priority of 10 is dropped first, and a priority of 1 is\ndropped last. Priorities are evaluated in match order, and the first priority to\nmatch is applied. All other priorities are ignored. If a request does not match\nany priority, then it is assigned the `default_priority`.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetPriority"
          },
          "type": "array"
        },
        "thresholds": {
          "description": "Optional. Defines which actions to take when a threshold is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1ConsumptionBudgetThreshold"
          },
          "type": "array"
        },
        "default_priority": {
          "description": "Optional. The default priority for requests that don't match any priority in the\n`priorities` list. If not set, then `priority=10` (dropped first) is used as the\ndefault.",
          "format": "int32",
          "type": "integer"
        },
        "notification_policy_slug": {
          "description": "Notification policy slug for routing alerts. Required only if `ALERT_WARN` or\n`ALERT_CRITICAL` actions are configured.",
          "type": "string"
        },
        "alert_action_config": {
          "$ref": "#/definitions/ConsumptionBudgetAlertActionConfig"
        }
      },
      "type": "object"
    },
    "configv1ConsumptionBudgetResource": {
      "enum": [
        "LOG_PERSISTED_BYTES",
        "LOG_PROCESSED_BYTES"
      ],
      "type": "string"
    },
    "configv1ConsumptionBudgetThreshold": {
      "properties": {
        "action": {
          "$ref": "#/definitions/ConsumptionBudgetThresholdAction"
        },
        "type": {
          "$ref": "#/definitions/ConsumptionBudgetThresholdType"
        },
        "instant_rate": {
          "$ref": "#/definitions/ThresholdInstantRate"
        },
        "volume": {
          "$ref": "#/definitions/ThresholdVolume"
        }
      },
      "type": "object"
    },
    "configv1ConsumptionConfig": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ConsumptionConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "partitions": {
          "description": "Partitions define non-overlapping groupings of telemetry data. Partitions are\ndefined in order of precedence, where incoming requests are allocated to the\nfirst partition that matches. Requests that don't match any partition use an\nimplicit `default` partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1CreateAzureMetricsIntegrationRequest": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the AzureMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the AzureMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketRequest": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Bucket. If the specified configuration is valid, the endpoint returns a partial response without the Bucket. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardRequest": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionRequest": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Collection. If the specified configuration is valid, the endpoint returns a partial response without the Collection. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionBudgetRequest": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ConsumptionBudget. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionBudget. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ConsumptionConfig. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Dashboard. If the specified configuration is valid, the endpoint returns a partial response without the Dashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetRequest": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Dataset. If the specified configuration is valid, the endpoint returns a partial response without the Dataset. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelRequest": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DerivedLabel. If the specified configuration is valid, the endpoint returns a partial response without the DerivedLabel. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricRequest": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DerivedMetric. If the specified configuration is valid, the endpoint returns a partial response without the DerivedMetric. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleRequest": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DropRule. If the specified configuration is valid, the endpoint returns a partial response without the DropRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationRequest": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GcpMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the GcpMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardRequest": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogAllocationConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogAllocationConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogControlConfigRequest": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogControlConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogControlConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigRequest": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogIngestConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogIngestConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionRequest": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogScaleAction. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAction. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertRequest": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogScaleAlert. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAlert. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleRequest": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the MappingRule. If the specified configuration is valid, the endpoint returns a partial response without the MappingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorRequest": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Monitor. If the specified configuration is valid, the endpoint returns a partial response without the Monitor. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleRequest": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the MutingRule. If the specified configuration is valid, the endpoint returns a partial response without the MutingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyRequest": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the NotificationPolicy. If the specified configuration is valid, the endpoint returns a partial response without the NotificationPolicy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierRequest": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Notifier. If the specified configuration is valid, the endpoint returns a partial response without the Notifier. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the OtelMetricsIngestion. If the specified configuration is valid, the endpoint returns a partial response without the OtelMetricsIngestion. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleRequest": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the RecordingRule. If the specified configuration is valid, the endpoint returns a partial response without the RecordingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ResourcePools. If the specified configuration is valid, the endpoint returns a partial response without the ResourcePools. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleRequest": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the RollupRule. If the specified configuration is valid, the endpoint returns a partial response without the RollupRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1CreateSLORequest": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the SLO. If the specified configuration is valid, the endpoint returns a partial response without the SLO. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountRequest": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ServiceAccount. If the specified configuration is valid, the endpoint returns a partial response without the ServiceAccount. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAttributeResponse": {
      "properties": {
        "service_slug": {
          "type": "string"
        },
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamRequest": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Team. If the specified configuration is valid, the endpoint returns a partial response without the Team. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceBehaviorConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehaviorConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorRequest": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceBehavior. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehavior. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleRequest": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceMetricsRule. If the specified configuration is valid, the endpoint returns a partial response without the TraceMetricsRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1Dashboard": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Dashboard. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Dashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Dashboard. You can modify this value after the Dashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_slug": {
          "description": "Optional. Slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Raw JSON representation that defines the structure of the dashboard.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Defines tags that add metadata about the dashboard.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1Dataset": {
      "properties": {
        "name": {
          "description": "The name of the Dataset. You can modify this value after the Dataset is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Dataset. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Dataset is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dataset was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dataset was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Required. Description of the dataset.",
          "type": "string"
        },
        "configuration": {
          "$ref": "#/definitions/DatasetDatasetConfiguration"
        }
      },
      "type": "object"
    },
    "configv1DefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Determines whether to override the default sample rate.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1DeleteAzureMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteBucketResponse": {
      "properties": {
        "changes": {
          "description": "Changes contains what resources are deleted. The bucket being deleted will\nalways be included. When force_delete is used, the changelog will include\nall resources that reference the bucket that were deleted.",
          "items": {
            "$ref": "#/definitions/ResourceChange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DeleteClassicDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteCollectionResponse": {
      "type": "object"
    },
    "configv1DeleteConsumptionBudgetResponse": {
      "type": "object"
    },
    "configv1DeleteConsumptionConfigResponse": {
      "type": "object"
    },
    "configv1DeleteDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteDatasetResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedLabelResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedMetricResponse": {
      "type": "object"
    },
    "configv1DeleteDropRuleResponse": {
      "type": "object"
    },
    "configv1DeleteGcpMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteGrafanaDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteLogAllocationConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogControlConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogIngestConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleActionResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleAlertResponse": {
      "type": "object"
    },
    "configv1DeleteMappingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteMonitorResponse": {
      "type": "object"
    },
    "configv1DeleteMutingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteNotificationPolicyResponse": {
      "type": "object"
    },
    "configv1DeleteNotifierResponse": {
      "type": "object"
    },
    "configv1DeleteOtelMetricsIngestionResponse": {
      "type": "object"
    },
    "configv1DeleteRecordingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteResourcePoolsResponse": {
      "type": "object"
    },
    "configv1DeleteRollupRuleResponse": {
      "type": "object"
    },
    "configv1DeleteSLOResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAccountResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAttributeResponse": {
      "type": "object"
    },
    "configv1DeleteTeamResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorConfigResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorResponse": {
      "type": "object"
    },
    "configv1DeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configv1DeleteTraceMetricsRuleResponse": {
      "type": "object"
    },
    "configv1DeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configv1DerivedLabel": {
      "properties": {
        "name": {
          "description": "The name of the DerivedLabel. You can modify this value after the DerivedLabel is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the DerivedLabel. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DerivedLabel is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedLabel was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedLabel was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_name": {
          "description": "Name of the derived label. Must be unique across the system.",
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the derived label.",
          "type": "string"
        },
        "metric_label": {
          "$ref": "#/definitions/DerivedLabelMetricLabel"
        },
        "existing_label_policy": {
          "$ref": "#/definitions/configv1DerivedLabelLabelPolicy"
        },
        "span_tag": {
          "$ref": "#/definitions/DerivedLabelSpanTag"
        }
      },
      "type": "object"
    },
    "configv1DerivedLabelLabelPolicy": {
      "enum": [
        "KEEP",
        "OVERRIDE"
      ],
      "type": "string"
    },
    "configv1DerivedMetric": {
      "properties": {
        "name": {
          "description": "The name of the DerivedMetric. You can modify this value after the DerivedMetric is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the DerivedMetric. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DerivedMetric is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DerivedMetric was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedMetric was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "Name of the derived metric, which must be unique across the system.",
          "example": "cpu_usage:instance",
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the derived metric.",
          "type": "string"
        },
        "queries": {
          "description": "Defines the queries that the derived metric can map to.",
          "items": {
            "$ref": "#/definitions/DerivedMetricSelectorQuery"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1DerivedMetricLabelMatcherMatcherType"
        },
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcherMatcherType": {
      "enum": [
        "EXACT"
      ],
      "type": "string"
    },
    "configv1DropRule": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the DropRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DropRule is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the DropRule. You can modify this value after the DropRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the DropRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DropRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/configv1DropRuleMode"
        },
        "filters": {
          "description": "Defines the conditions that determine whether to drop a metric. Drop rules can\nhave multiple filter conditions on different labels, making it possible to drop\na subset of the series matching a particular metric name.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "conditional_rate_based_drop": {
          "$ref": "#/definitions/DropRuleConditionalRateBasedDrop"
        },
        "value_based_drop": {
          "$ref": "#/definitions/DropRuleValueBasedDrop"
        },
        "drop_nan_value": {
          "description": "Drops data points if values are Not a Number (NaN). If set to true, Chronosphere\ndrops NaN data points, along with any published staleness markers. See the\n[drop rules\ndocumentation](https://docs.chronosphere.io/control/shaping/rules/drop-rules#define-a-value-based-drop-rule)\nfor more information.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1DropRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1GcpMetricsIntegration": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the GcpMetricsIntegration. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the GcpMetricsIntegration. You can modify this value after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_account": {
          "$ref": "#/definitions/configv1GcpMetricsIntegrationServiceAccount"
        },
        "metric_groups": {
          "description": "An array of metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/GcpMetricsIntegrationMetricGroup"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1GcpMetricsIntegrationServiceAccount": {
      "properties": {
        "client_email": {
          "description": "The email address of the Google Cloud service account to impersonate for authentication.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1GrafanaDashboard": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the GrafanaDashboard. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the GrafanaDashboard is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the GrafanaDashboard. You can modify this value after the GrafanaDashboard is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GrafanaDashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GrafanaDashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the dashboard belongs to. Required if collection_slug\nis not set.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the dashboard belongs to. Required if bucket_slug\nis not set.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the Grafana dashboard.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelFilter": {
      "properties": {
        "name": {
          "description": "The name of the label to match.",
          "example": "job",
          "type": "string"
        },
        "value_glob": {
          "description": "The glob value of the label to match.",
          "example": "myservice*",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1LabelMatcherMatcherType"
        },
        "name": {
          "description": "The name of the label to match against. This always matches against an\nexact label name, regardless of the value of `type`.",
          "type": "string"
        },
        "value": {
          "description": "The value of the label to match against. If `type` is set to `EXACT`, this\nmatches against an exact label value. If `type` is set to `REGEX`, this\nparameter is treated as a regular expression for parsing label values.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX"
      ],
      "type": "string"
    },
    "configv1ListAzureMetricsIntegrationsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "azure_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1AzureMetricsIntegration"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListBucketsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "buckets": {
          "items": {
            "$ref": "#/definitions/configv1Bucket"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListClassicDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "classic_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListCollectionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "collections": {
          "items": {
            "$ref": "#/definitions/configv1Collection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListConsumptionBudgetsResponse": {
      "properties": {
        "consumption_budgets": {
          "items": {
            "$ref": "#/definitions/configv1ConsumptionBudget"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configv1Dashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDatasetsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "datasets": {
          "items": {
            "$ref": "#/definitions/configv1Dataset"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedLabelsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_labels": {
          "items": {
            "$ref": "#/definitions/configv1DerivedLabel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedMetricsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "derived_metrics": {
          "items": {
            "$ref": "#/definitions/configv1DerivedMetric"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListDropRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "drop_rules": {
          "items": {
            "$ref": "#/definitions/configv1DropRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGcpMetricsIntegrationsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "gcp_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1GcpMetricsIntegration"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListGrafanaDashboardsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "grafana_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleActionsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_actions": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAction"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleAlertsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "log_scale_alerts": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAlert"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMappingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "mapping_rules": {
          "items": {
            "$ref": "#/definitions/configv1MappingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMonitorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "monitors": {
          "items": {
            "$ref": "#/definitions/configv1Monitor"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListMutingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "muting_rules": {
          "items": {
            "$ref": "#/definitions/configv1MutingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotificationPoliciesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notification_policies": {
          "items": {
            "$ref": "#/definitions/configv1NotificationPolicy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListNotifiersResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "notifiers": {
          "items": {
            "$ref": "#/definitions/configv1Notifier"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRecordingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "recording_rules": {
          "items": {
            "$ref": "#/definitions/configv1RecordingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRollupRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "rollup_rules": {
          "items": {
            "$ref": "#/definitions/configv1RollupRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListSLOsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "slos": {
          "items": {
            "$ref": "#/definitions/configv1SLO"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAccountsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_accounts": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAttributesResponse": {
      "properties": {
        "service_attributes": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAttribute"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configv1Service"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTeamsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "teams": {
          "items": {
            "$ref": "#/definitions/configv1Team"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceBehaviorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_behaviors": {
          "items": {
            "$ref": "#/definitions/configv1TraceBehavior"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceMetricsRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_metrics_rules": {
          "description": "Found trace metrics rules.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfig": {
      "description": "LogAllocationConfig is a singleton configuration object that specifies the\nconfiguration for Log budget allocations.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogAllocationConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogAllocationConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_dataset": {
          "$ref": "#/definitions/LogAllocationConfigDefaultDataset"
        },
        "dataset_allocations": {
          "description": "Defines datasets and budget allocations. Datasets are evaluated in order.",
          "items": {
            "$ref": "#/definitions/LogAllocationConfigDatasetAllocation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfigAllocation": {
      "description": "Configuration for allocating resources to a dataset.",
      "properties": {
        "percent_of_license": {
          "description": "Sets the percentage of the license limit to allocate to the default dataset.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1LogControlConfig": {
      "description": "LogControlConfig is a singleton configuration object that specifies the\nconfiguration for log control.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogControlConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogControlConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Control Rules are the ordered list of control rules.",
          "items": {
            "$ref": "#/definitions/configv1LogControlRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogControlRule": {
      "description": "LogControlRule is the configuration for a log control rule.",
      "properties": {
        "name": {
          "description": "User-defined name of the control rule.",
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/configv1LogControlRuleMode"
        },
        "filter": {
          "description": "Log query filter to return log data for the control rule. The control action\napplies to only matching logs.",
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/configv1LogControlRuleType"
        },
        "sample": {
          "$ref": "#/definitions/LogControlRuleSample"
        },
        "drop_field": {
          "$ref": "#/definitions/LogControlRuleDropField"
        },
        "replace_field": {
          "$ref": "#/definitions/LogControlRuleReplaceField"
        },
        "emit_metrics": {
          "$ref": "#/definitions/LogControlRuleEmitMetrics"
        }
      },
      "type": "object"
    },
    "configv1LogControlRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "configv1LogControlRuleType": {
      "enum": [
        "DROP",
        "SAMPLE",
        "DROP_FIELD",
        "REPLACE_FIELD",
        "EMIT_METRICS"
      ],
      "type": "string"
    },
    "configv1LogDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1LogSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1LogFieldPath": {
      "properties": {
        "selector": {
          "description": "The log filter used to indicate the field path. Use `parent[child]` syntax to\nindicate nesting.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogIngestConfig": {
      "description": "LogIngestConfig is a singleton configuration object that specifies the configuration for log ingest.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogIngestConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogIngestConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "plaintext_parsers": {
          "description": "The parsers to apply to plaintext logs. The first parser that matches the log is used.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigPlaintextParser"
          },
          "type": "array"
        },
        "field_parsers": {
          "description": "The parsers to apply to specific fields within structured logs or plaintext logs after those logs are parsed.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigLogFieldParser"
          },
          "type": "array"
        },
        "field_normalization": {
          "$ref": "#/definitions/LogIngestConfigFieldNormalization"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAction": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the LogScaleAction. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the LogScaleAction is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of the LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of an action.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAction was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAction was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "action_type": {
          "$ref": "#/definitions/LogScaleActionActionType"
        },
        "email_action": {
          "$ref": "#/definitions/LogScaleActionEmailAction"
        },
        "humio_action": {
          "$ref": "#/definitions/LogScaleActionHumioRepoAction"
        },
        "ops_genie_action": {
          "$ref": "#/definitions/LogScaleActionOpsGenieAction"
        },
        "pager_duty_action": {
          "$ref": "#/definitions/LogScaleActionPagerDutyAction"
        },
        "slack_action": {
          "$ref": "#/definitions/LogScaleActionSlackAction"
        },
        "slack_post_message_action": {
          "$ref": "#/definitions/LogScaleActionSlackPostMessageAction"
        },
        "victor_ops_action": {
          "$ref": "#/definitions/LogScaleActionVictorOpsAction"
        },
        "webhook_action": {
          "$ref": "#/definitions/LogScaleActionWebhookAction"
        },
        "upload_file_action": {
          "$ref": "#/definitions/LogScaleActionUploadFileAction"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAlert": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the LogScaleAlert. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the LogScaleAlert is created.",
          "type": "string"
        },
        "repository": {
          "description": "Name of LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "name": {
          "description": "Name of the alert.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAlert was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAlert was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "disabled": {
          "description": "Flag indicating whether the alert is disabled.",
          "type": "boolean"
        },
        "log_scale_query": {
          "description": "LogScale query to execute.",
          "example": "level = ERROR | severity \u003e 3 | count(as=numErrors) | numErrors \u003e 500",
          "type": "string"
        },
        "time_window_secs": {
          "description": "Lookback window used for an alert's evaluation.\nIf this is set to 86400 seconds (24 hours), only the events from the last 24 hours will be considered when the alert query is run.",
          "example": "3600",
          "format": "int32",
          "type": "integer"
        },
        "throttle_secs": {
          "description": "Throttle time in seconds. The alert is triggered at most once per throttle period.",
          "format": "int32",
          "type": "integer"
        },
        "throttle_field": {
          "description": "Field to throttle on. Optional.",
          "type": "string"
        },
        "log_scale_action_slugs": {
          "description": "Slugs of LogScale actions that will receive the alerts. When the value is empty\nthis alert won't trigger. Optional.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tags": {
          "description": "Tags attached to the alert.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "run_as_user": {
          "description": "Email of the user that the alert runs on behalf of. Required.",
          "type": "string"
        },
        "alert_type": {
          "$ref": "#/definitions/LogScaleAlertAlertType"
        }
      },
      "type": "object"
    },
    "configv1LogSearchFilter": {
      "properties": {
        "query": {
          "description": "Returns logs that match this query. The query can include only top-level\noperations. Nested clauses aren't supported. Only one type of `AND` or `OR`\noperator is allowed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MappingRule": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the MappingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the MappingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the MappingRule. You can modify this value after the MappingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MappingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MappingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "The slug of the bucket the MappingRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "The filters that determine which metrics should have rules applied to them.\nTo be considered a match, a metric must meet the criteria for all of the\nfilters specified in this array.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "aggregation_policy": {
          "$ref": "#/definitions/MappingRuleAggregationPolicy"
        },
        "drop": {
          "description": "Specifies whether to drop the given set of metrics. Cannot be set if the\n`aggregation_policy` object is set.",
          "type": "boolean"
        },
        "mode": {
          "$ref": "#/definitions/configv1MappingRuleMode"
        }
      },
      "type": "object"
    },
    "configv1MappingRuleMode": {
      "description": " - ENABLED: ENABLED rules are applied. Rules default to ENABLED.\n - PREVIEW: PREVIEW rules are not applied, but shaping impact stats\nfor them rule are recorded.",
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1MappingRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "string"
        },
        "retention": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Monitor": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Monitor. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Monitor is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Monitor. You can modify this value after the Monitor is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Monitor was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Monitor was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the monitor belongs to. Required if `collection_slug` isn't\nset.",
          "type": "string"
        },
        "collection_slug": {
          "description": "Slug of the collection the monitor belongs to. Required if `bucket_slug` isn't\nset.",
          "type": "string"
        },
        "collection": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Required. Labels to include in notifications generated by this monitor, and can\nbe used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this monitor.\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "series_conditions": {
          "$ref": "#/definitions/MonitorSeriesConditions"
        },
        "notification_policy_slug": {
          "description": "Specifies the notification policy used to route alerts generated by the monitor.\nIf omitted, the notification policy is inherited from the monitor.",
          "type": "string"
        },
        "interval_secs": {
          "description": "Specifies how often alerts are evaluated. Default: `60s`.",
          "format": "int32",
          "type": "integer"
        },
        "prometheus_query": {
          "description": "PromQL query to evaluate for the alert. If set, no other queries can be set.",
          "example": "up{job=\"prometheus\"} == 0",
          "type": "string"
        },
        "graphite_query": {
          "description": "Graphite query to evaluate for the alert. If set, no other queries can be set.",
          "example": "sumSeries(stats.timers.*.mean_90)",
          "type": "string"
        },
        "schedule": {
          "$ref": "#/definitions/MonitorSchedule"
        },
        "logging_query": {
          "description": "Logging query to evaluate for the alert. If set, no other queries can be set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MonitorCondition": {
      "properties": {
        "op": {
          "$ref": "#/definitions/ConditionOp"
        },
        "value": {
          "description": "Required. The value to compare to the metric value using the `op` operation.",
          "format": "double",
          "type": "number"
        },
        "sustain_secs": {
          "description": "Amount of time the query needs to fail the condition check before an alert is\ntriggered. Must be an integer. Accepts one of `s` (seconds), `m` (minutes), or\n`h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        },
        "resolve_sustain_secs": {
          "description": "Amount of time the query needs to no longer fire before resolving. Must be an\ninteger. Accepts one of `s` (seconds), `m` (minutes), or `h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "configv1MutingRule": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the MutingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the MutingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the MutingRule. You can modify this value after the MutingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MutingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MutingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "label_matchers": {
          "description": "Required. Specifies which series are silenced by the muting rule. Alerting\nseries must match all muting rule matchers to be silenced. You can't update this\nvalue. Updates must specify the original value.",
          "items": {
            "$ref": "#/definitions/configv1MutingRuleLabelMatcher"
          },
          "type": "array"
        },
        "starts_at": {
          "description": "Required. Timestamp of when the muting rule becomes active. You can't update\nthis value. Updates must specify the original value.",
          "format": "date-time",
          "type": "string"
        },
        "ends_at": {
          "description": "Required. Timestamp of when the muting rule stops being active.",
          "format": "date-time",
          "type": "string"
        },
        "comment": {
          "description": "Descriptive comment that explains why the muting rule was created.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcher": {
      "properties": {
        "type": {
          "$ref": "#/definitions/configv1MutingRuleLabelMatcherMatcherType"
        },
        "name": {
          "description": "Required. Always matches against an exact label name.",
          "type": "string"
        },
        "value": {
          "description": "Required. Matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX",
        "NOT_EXACT",
        "NOT_REGEXP"
      ],
      "type": "string"
    },
    "configv1NotificationPolicy": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the NotificationPolicy. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the NotificationPolicy is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the NotificationPolicy. You can modify this value after the NotificationPolicy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NotificationPolicy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NotificationPolicy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "The slug of the bucket that the notification policy belongs to. Required if\n`team_slug` is not set.",
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the notification policy belongs to. Required if\n`bucket_slug` is not set.",
          "type": "string"
        },
        "routes": {
          "$ref": "#/definitions/NotificationPolicyRoutes"
        }
      },
      "type": "object"
    },
    "configv1Notifier": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Notifier. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Notifier is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Notifier. You can modify this value after the Notifier is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Notifier was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Notifier was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "skip_resolved": {
          "description": "If `true`, disables notifications for resolved alerts. Cannot be set if\n`discard` equals `true`.",
          "type": "boolean"
        },
        "webhook": {
          "$ref": "#/definitions/NotifierWebhookConfig"
        },
        "slack": {
          "$ref": "#/definitions/NotifierSlackConfig"
        },
        "pagerduty": {
          "$ref": "#/definitions/NotifierPagerdutyConfig"
        },
        "email": {
          "$ref": "#/definitions/NotifierEmailConfig"
        },
        "ops_genie": {
          "$ref": "#/definitions/NotifierOpsGenieConfig"
        },
        "victor_ops": {
          "$ref": "#/definitions/NotifierVictorOpsConfig"
        },
        "discard": {
          "description": "If `true`, enables the `discard` integration, which discards all\nnotifications. Cannot be set if another integration is set.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1OtelMetricsIngestion": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource_attributes": {
          "$ref": "#/definitions/OtelMetricsIngestionResourceAttributes"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "An opaque page token that identifies the next page of items that the\nclient should request. An empty value indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1ReadClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1ReadConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1ReadConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1ReadDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1ReadGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1ReadMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1ReadMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1ReadNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1ReadOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1ReadRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1ReadRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1ReadSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAttributeResponse": {
      "properties": {
        "service_slug": {
          "type": "string"
        },
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configv1Service"
        }
      },
      "type": "object"
    },
    "configv1ReadTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1RecordingRule": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the RecordingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the RecordingRule is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the RecordingRule. You can modify this value after the RecordingRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RecordingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RecordingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "The slug of the bucket the recording rule belongs to. Required if\n`execution_group` is not set. If both `bucket_slug` and `execution_group`\nare set, their values must match.",
          "type": "string"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RecordingRuleLabelPolicy"
        },
        "interval_secs": {
          "description": "Specifies how often to evaluate the recording rule.",
          "format": "int32",
          "type": "integer"
        },
        "metric_name": {
          "description": "The name of the time series to use for the output of `prometheus_expr`.\nThis value must be a valid metric name. If you don't set this value,\nthe output of `prometheus_expr` is output to a time series with a name\ndefined by the value of `name`.",
          "type": "string"
        },
        "prometheus_expr": {
          "description": "The PromQL expression to evaluate at the time of each evaluation cycle. The\nresult is output to a new time series with a name defined by the value of\n`metric_name`. If `metric_name` is unset, the result is output to a\ntime series defined by the value of `name`.",
          "type": "string"
        },
        "execution_group": {
          "description": "The slug of the execution group in which the recording rule will be\nevaluated. Required if `bucket_slug` is not set.  If both `bucket_slug` and\n`execution_group` are set, their values must match.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1RecordingRuleLabelPolicy": {
      "properties": {
        "add": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A list of labels to add or overwrite before storing the result.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1ResourcePools": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ResourcePools was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ResourcePools was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_pool": {
          "$ref": "#/definitions/ResourcePoolsDefaultPool"
        },
        "pools": {
          "description": "Optional. Defines additional pools, which can't exceed 20 pools.",
          "items": {
            "$ref": "#/definitions/ResourcePoolsPool"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourcePoolsAllocation": {
      "properties": {
        "percent_of_license": {
          "description": "Percent of the license to allocate to this pool. This value must be between\n`0` and `100`, inclusive. The `percent_of_license` values across all pools,\nexcluding the default pool, must be less than or equal to 100. The\n`default_pool` receives any remaining allocation, so you don't need to specify\na value for it explicitly. If you specify an allocation for the\n`default_pool`, the sum of `percent_of_license` across all pools (including\nthe default pool) must exactly equal `100`.",
          "format": "double",
          "type": "number"
        },
        "fixed_values": {
          "description": "Optional. Specifies overrides for the `percent_of_license` allocations for\nspecified licenses. When defining fixed values for a license, all pools must\nhave an explicit fixed value specification for that given license. The default\npool receives all remaining quota left within the license, after subtracting\nthe sum of fixed values across pools for that license.",
          "items": {
            "$ref": "#/definitions/AllocationFixedValue"
          },
          "type": "array"
        },
        "priority_thresholds": {
          "description": "Defines thresholds with strict limits for when to drop new consumption of the\npersisted cardinality license for a pool. Setting `priority_thresholds` is\nrequired to set limits for cardinality licenses. Only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourceType": {
      "enum": [
        "BUCKET",
        "DASHBOARD",
        "GRAFANA_DASHBOARD",
        "MONITOR",
        "NOTIFICATION_POLICY",
        "RECORDING_RULE",
        "MAPPING_RULE",
        "ROLLUP_RULE"
      ],
      "type": "string"
    },
    "configv1RollupRule": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the RollupRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the RollupRule is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the RollupRule. You can modify this value after the RollupRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RollupRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RollupRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "bucket_slug": {
          "description": "The slug of the bucket the RollupRule belongs to.",
          "type": "string"
        },
        "filters": {
          "description": "Filters incoming metrics by label. If multiple label filters are specified, an\nincoming metric must match every label filter to match the rule. Label values\nsupport glob patterns, including matching multiple patterns with an `OR`, such\nas `service:{svc1,svc2}`. These special filters are available for matching\nmetrics by non-label request metadata:\n * `__metric_type__`: Matches the incoming metric's [Observability Platform\n   metric\n   type](https://docs.chronosphere.io/control/shaping/types#observability-platform-types).\n   This is the recommended method for filtering on metric type. Valid values:\n   `cumulative_counter`, `cumulative_exponential_histogram`, `delta_counter`,\n   `delta_exponential_histogram`, `gauge`, `measurement`.\n * `__metric_source__`: Matches the incoming metric's [source\n   format](https://docs.chronosphere.io/control/shaping/types#supported-formats).\n   Valid values: `carbon`, `chrono_gcp`, `dogstatsd`, `open_metrics`,\n   `open_telemetry`, `prometheus`, `signalfx`, `statsd`, `wavefront`.\n * `__m3_prom_type__`: When ingesting metric data with Prometheus, matches the\n   incoming metric's [Prometheus metric\n   type](https://docs.chronosphere.io/control/shaping/types#prometheus). Valid\n   values: `counter`, `gauge`, `histogram`, `gauge_histogram`, `summary`,\n   `info`, `state_set`, `quantile`.\n * `__otel_type__`: When ingesting with OpenTelemetry, matches on the incoming\n   metric's [OpenTelemetry metric\n   type](https://docs.chronosphere.io/control/shaping/types#opentelemetry).\n   Valid values: `sum`, `monotonic_sum`, `gauge`, `histogram`, `exp_histogram`,\n  `summary`. For example, the following filter matches any cumulative counter\n  metric with a `service=gateway` label whose metric name starts with\n  `http_requests_`:\n```\n__metric_type__:cumulative_counter service:gateway __name__:http_requests_*\n```",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "metric_name": {
          "description": "The name of the new metric to create and persist to the database. You can use\nthe template string `{{.MetricName }}` to create a new metric name that\nreferences the original metric name. For example, `new_metric: '{{ .MetricName\n}}:by_instance'` outputs a metric with the name `my_metric:by_instance` if the\nmatched metric is `my_metric`.\nThis field is optional for Graphite rollup rules.",
          "type": "string"
        },
        "metric_type": {
          "$ref": "#/definitions/RollupRuleMetricType"
        },
        "aggregation": {
          "$ref": "#/definitions/configv1AggregationType"
        },
        "storage_policy": {
          "$ref": "#/definitions/configv1RollupRuleStoragePolicy"
        },
        "interval": {
          "description": "Optional. Sets a custom interval that defines the amount of\ntime between aggregated data points. Intervals are based on your\n[retention policy](https://docs.chronosphere.io/administer/licensing#retention-policies).\nThis field was known as `storage_policies` in version\n0.286.0-2023-01-06-release.1\nand earlier.",
          "type": "string"
        },
        "expansive_match": {
          "description": "**DEPRECATED**.\nA series matches and aggregates only if each label defined by filters and\n`label_policy.keep` or `graphite_label_policy.replace` (respectively) exist in\nthe series. Setting `expansive_match=true` removes this restriction. Default:\n`expansive_match=false`.\n\nIf `false`, a series matches and aggregates only if each label defined by the\nprovided `filters` and the `label_policy.keep` or\n`graphite_label_policy.replace` settings exist in the series.",
          "type": "boolean"
        },
        "add_metric_type_label": {
          "description": "Defines whether to add a `__rollup_type__` label in the new metric.",
          "type": "boolean"
        },
        "drop_raw": {
          "description": "Defines whether to automatically generate drop rules for this rollup rule. Set\nto `true` to remove raw metrics that match this rollup rule. Default: `false`.",
          "type": "boolean"
        },
        "label_policy": {
          "$ref": "#/definitions/configv1RollupRuleLabelPolicy"
        },
        "label_replace": {
          "$ref": "#/definitions/RollupRuleLabelReplace"
        },
        "mode": {
          "$ref": "#/definitions/configv1RollupRuleMode"
        },
        "graphite_label_policy": {
          "$ref": "#/definitions/RollupRuleGraphiteLabelPolicy"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleLabelPolicy": {
      "description": "TODO: consolidate w/ RecordingRule.LabelPolicy once both of these\n entities implement the same label semantics.",
      "properties": {
        "keep": {
          "description": "Labels to retain in the output metric. If set, the `discard` field must\nbe empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "discard": {
          "description": "Labels to discard in the output metric. If set, the `keep` field must be\nempty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleMode": {
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "title": "- PREVIEW: TODO: DISABLED = 2;",
      "type": "string"
    },
    "configv1RollupRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1SLI": {
      "properties": {
        "custom_indicator": {
          "$ref": "#/definitions/SLICustomIndicatorConfig"
        },
        "custom_timeslice_indicator": {
          "$ref": "#/definitions/SLICustomTimeSliceIndicatorConfig"
        },
        "custom_dimension_labels": {
          "description": "Configures additional labels to export from the underlying queries. This feature\nprovides a logical budget to group unique combinations of dimensions. For\nexample, if you want to track a budget per endpoint, add the endpoint label as a\ndimension. These dimensions are provided on the top-level SLI so that SLOs will\nreceive them in the `.GroupBy` variable.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "additional_promql_filters": {
          "description": "Specifies additional PromQL filters, which are made available to the SLO queries.\nUse these filters to reduce the number of metrics used by the SLO.",
          "example": "cluster!~\"dev\"",
          "items": {
            "$ref": "#/definitions/commonPromQLMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1SLO": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the SLO. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the SLO is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the SLO. You can modify this value after the SLO is created.",
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the SLO was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SLO was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "collection_ref": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "notification_policy_slug": {
          "description": "Optional. Slug of the notification policy to use for the SLO. If you don't\nspecify a value, then the collection or service this SLO belongs to must have a\nnotification policy. Required if alerting is enabled for this SLO.",
          "example": "alerting_notification_policy",
          "type": "string"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are visible in notifications generated by this SLO,\nand can be used to route alerts with notification overrides.",
          "type": "object"
        },
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this SLO.\nYou can template annotations with labels from notifications.",
          "type": "object"
        },
        "sli": {
          "$ref": "#/definitions/configv1SLI"
        },
        "definition": {
          "$ref": "#/definitions/SLODefinition"
        }
      },
      "type": "object"
    },
    "configv1Service": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Service. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Service is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Service. You can modify this value after the Service is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "team_slug": {
          "description": "Slug of the team the service collection belongs to.",
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the service collection.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service\ncollection. This parameter is optional if the collection doesn't contain\nmonitors, or if all of its monitors explicitly reference a policy. This\nparameter doesn't override the policy used if a monitor explicitly references\na policy.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ServiceAccount": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the ServiceAccount. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the ServiceAccount is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the ServiceAccount. You can modify this value after the ServiceAccount is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the ServiceAccount was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the ServiceAccount was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "token": {
          "description": "Generated API token of the service account. Cannot be set by clients.\n\nThe token is set only once by the server in the `CreateServiceAccount` response.\nThe `ReadServiceAccount` response always returns an empty token. Therefore, when\ncreating a service account, ensure you securely store the response token.\nIf you lose the token, you must delete and recreate the service account to\ngenerate a new token.",
          "readOnly": true,
          "type": "string"
        },
        "email": {
          "description": "The unique email user for this service account. Cannot be set by clients.",
          "readOnly": true,
          "type": "string"
        },
        "unrestricted": {
          "description": "If set, grants the service account access to all Chronosphere APIs, including\nresource configuration and metric data within the access controls defined by the\nservice account's team membership.\n\nOnly one of `unrestricted` or `metrics_restriction` must be set.",
          "type": "boolean"
        },
        "metrics_restriction": {
          "$ref": "#/definitions/ServiceAccountMetricsRestriction"
        }
      },
      "type": "object"
    },
    "configv1ServiceAttribute": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the service attributes were created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the service attributes were updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the service. You can modify this value after the service\nattributes are created.",
          "type": "string"
        },
        "service_slug": {
          "description": "The slug of the service.",
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the associated service belongs to.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "The slug of the notification policy for the associated service.",
          "type": "string"
        },
        "description": {
          "description": "A description of the service.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Team": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the Team. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Team is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Team. You can modify this value after the Team is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Team was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Team was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "user_emails": {
          "description": "Unordered set of emails whose users are members of this team.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "description": {
          "description": "Optional. Short description of the team.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceBehavior": {
      "properties": {
        "name": {
          "description": "The name of the TraceBehavior. You can modify this value after the TraceBehavior is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the TraceBehavior. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceBehavior is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehavior was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehavior was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "base_tail_sample_rate": {
          "description": "Specifies the base sample rate for fully assembled traces that don't apply to\nthe `error_sample_options`, `fast_sample_options`, `slow_sample_options`,\n`large_trace_sample_options`, or `small_trace_sample_options` sampling options.",
          "format": "double",
          "type": "number"
        },
        "base_head_sample_rate": {
          "description": "Specifies the sample rate for head sampling. This rate applies to all root spans\nthat are enrolled in head sampling, but don't have a specific rule defined for\ntheir service.",
          "format": "double",
          "type": "number"
        },
        "error_sample_options": {
          "$ref": "#/definitions/TraceBehaviorErrorSampleOptions"
        },
        "fast_sample_options": {
          "$ref": "#/definitions/TraceBehaviorFastSampleOptions"
        },
        "slow_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSlowSampleOptions"
        },
        "large_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorLargeTraceSampleOptions"
        },
        "small_trace_sample_options": {
          "$ref": "#/definitions/TraceBehaviorSmallTraceSampleOptions"
        }
      },
      "type": "object"
    },
    "configv1TraceBehaviorConfig": {
      "description": "TraceBehaviorConfig is a singleton configuration object that specifies the\nconfiguration for trace behaviors.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "main_behavior_assignments": {
          "description": "List of assignments for the main behavior. The referenced datasets will be\nenrolled in behaviors. The referenced behaviors are the active behaviors for the\ndataset when there is no active override. Only one main behavior can be assigned\nto a dataset. See the documentation for\n[customizing your sampling\nstrategy](https://docs.chronosphere.io/control/sampling/behaviors#customize-your-sampling-strategy)\nfor more information.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigMainBehaviorAssignment"
          },
          "type": "array"
        },
        "override_behavior_assignments": {
          "description": "List of assignments for the override behavior. These assignments specify the\nactive behavior for a dataset over a specific time range. Only one override\nbehavior can be assigned to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "dataset_priorities": {
          "description": "List of dataset priorities. This list specifies the order in which datasets are\nconsidered when determining the behavior to follow for a trace. Dataset\npriorities are used to break ties when a trace matches more than one dataset\nwith an active behavior.\n* Each entry in this list must refer to the slug of an existing dataset.\n* The order of the list is the order in which the datasets are considered.\n* The list must contain all datasets referenced in either\n  `main_behavior_assignments` or `override_behavior_assignments`.\n* The list can contain datasets that are not referenced in either of these\n  assignments.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "baseline_behavior_slug": {
          "description": "The baseline behavior to use for behavior assignments and base head sampling rates.",
          "type": "string"
        },
        "preview_behavior_assignments": {
          "description": "List of assignments for the preview behavior. The referenced behaviors are in\npreview mode for the assigned dataset. You can assign only one preview behavior\nto a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1TraceDataset": {
      "properties": {
        "match_criteria": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        }
      },
      "type": "object"
    },
    "configv1TraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "slug": {
          "description": "The unique identifier of the TraceJaegerRemoteSamplingStrategy. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "name": {
          "description": "The name of the TraceJaegerRemoteSamplingStrategy. You can modify this value after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This value must match\nthe `slug` and `name` fields.",
          "type": "string"
        },
        "applied_strategy": {
          "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRule": {
      "properties": {
        "name": {
          "description": "The name of the TraceMetricsRule. You can modify this value after the TraceMetricsRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the TraceMetricsRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceMetricsRule is created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceMetricsRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceMetricsRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_name": {
          "description": "The name of the generated trace metrics.",
          "type": "string"
        },
        "metric_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to apply to the generated trace metrics.",
          "type": "object"
        },
        "histogram_buckets_secs": {
          "description": "Histogram bucket values, in seconds, for generated duration metrics.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "trace_filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "group_by": {
          "description": "Add labels to the resultant metrics based on the specified key:value pairs.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRuleGroupBy"
          },
          "type": "array"
        },
        "scope_filter": {
          "$ref": "#/definitions/TraceSearchFilterScopeFilter"
        }
      },
      "type": "object"
    },
    "configv1TraceMetricsRuleGroupBy": {
      "description": "GroupBy contains fields required to group the resultant metrics of a TraceMetricsRule by a specific key.",
      "properties": {
        "label": {
          "description": "The label to use in the resulting metrics.",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/GroupByGroupByKey"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "trace": {
          "$ref": "#/definitions/TraceSearchFilterTraceFilter"
        },
        "span": {
          "description": "Specifies the span conditions to match on. All conditions must be true in a\nsingle span for the span to be considered a match. If `span_count` is specified,\nthe number of spans within the trace that match span conditions must be within\n`[min, max]`. You can specify multiple span conditions, and each can be\nsatisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        },
        "scope_filter": {
          "$ref": "#/definitions/TraceSearchFilterScopeFilter"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "filter": {
          "$ref": "#/definitions/configv1TraceSearchFilter"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        },
        "name": {
          "description": "A human-readable name of the rule.",
          "type": "string"
        },
        "system_name": {
          "description": "Name used as the metric label value for metrics that are emitted from this rule.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Optional. Specifies a list of rules and a sampling rate to apply. Rules are\nevaluated in order until a match is found. If no sample rate is specified, the\ndefault sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configv1TraceTailSamplingRule"
          },
          "type": "array"
        },
        "default_sample_rate": {
          "$ref": "#/definitions/configv1DefaultSampleRate"
        }
      },
      "type": "object"
    },
    "configv1UpdateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1UpdateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1UpdateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionConfig will be created if it does not already exist. If `false`, an error will be returned if the ConsumptionConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ConsumptionConfig. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1UpdateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1UpdateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigRequest": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogAllocationConfig will be created if it does not already exist. If `false`, an error will be returned if the LogAllocationConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogAllocationConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogAllocationConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogControlConfigRequest": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogControlConfig will be created if it does not already exist. If `false`, an error will be returned if the LogControlConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogControlConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogControlConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigRequest": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the LogIngestConfig will be created if it does not already exist. If `false`, an error will be returned if the LogIngestConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogIngestConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogIngestConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1UpdateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1UpdateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionRequest": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        },
        "create_if_missing": {
          "description": "If `true`, the OtelMetricsIngestion will be created if it does not already exist. If `false`, an error will be returned if the OtelMetricsIngestion does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the OtelMetricsIngestion. If the specified configuration is valid, the endpoint returns a partial response without the OtelMetricsIngestion. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1UpdateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsRequest": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        },
        "create_if_missing": {
          "description": "If `true`, the ResourcePools will be created if it does not already exist. If `false`, an error will be returned if the ResourcePools does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ResourcePools. If the specified configuration is valid, the endpoint returns a partial response without the ResourcePools. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1UpdateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1UpdateServiceAttributeResponse": {
      "properties": {
        "service_slug": {
          "type": "string"
        },
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        }
      },
      "type": "object"
    },
    "configv1UpdateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigRequest": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceBehaviorConfig will be created if it does not already exist. If `false`, an error will be returned if the TraceBehaviorConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceBehaviorConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehaviorConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        },
        "create_if_missing": {
          "description": "If `true`, the TraceTailSamplingRules will be created if it does not already exist. If `false`, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\nThe Config API provides standard HTTP/JSON REST endpoints for creating, reading,\nupdating, deleting, and listing configurable Chronosphere resources.\n\nUse this link to download the raw Swagger specification:\n\u003ca href=\"/api/v1/config/swagger.json\"\u003e/api/v1/config/swagger.json\u003c/a\u003e\n",
    "title": "Config V1 API",
    "version": "v1"
  },
  "paths": {
    "/api/v1/config/azure-metrics-integrations": {
      "get": {
        "operationId": "ListAzureMetricsIntegrations",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any AzureMetricsIntegration with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any AzureMetricsIntegration with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListAzureMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateAzureMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/azure-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the AzureMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadAzureMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateAzureMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/buckets": {
      "get": {
        "operationId": "ListBuckets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Bucket with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Bucket with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListBucketsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "post": {
        "operationId": "CreateBucket",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot create the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/buckets/{slug}": {
      "delete": {
        "operationId": "DeleteBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "description": "force_delete indicates deletion of the bucket and all resources that reference the bucket.\nThis includes monitors, dashboards, notification policies, recording rules, and alerts.",
            "in": "query",
            "name": "force_delete",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteBucketResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Bucket because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "get": {
        "operationId": "ReadBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadBucketResponse"
            }
          },
          "404": {
            "description": "Cannot read the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "put": {
        "operationId": "UpdateBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateBucketBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot update the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/classic-dashboards": {
      "get": {
        "operationId": "ListClassicDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ClassicDashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any ClassicDashboard with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any ClassicDashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ClassicDashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListClassicDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "post": {
        "operationId": "CreateClassicDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/classic-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "get": {
        "operationId": "ReadClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadClassicDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateClassicDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/collections": {
      "get": {
        "operationId": "ListCollections",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Collection with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Collection with a matching team_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Collection with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get collections that directly reference notification policies specified in\nthis array. To specify a notification policy, include its slug.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListCollectionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "post": {
        "operationId": "CreateCollection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Collection.",
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot create the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/collections/{slug}": {
      "delete": {
        "operationId": "DeleteCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Collection because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "get": {
        "operationId": "ReadCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadCollectionResponse"
            }
          },
          "404": {
            "description": "Cannot read the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "put": {
        "operationId": "UpdateCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateCollectionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Collection.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot update the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/consumption-budgets": {
      "get": {
        "operationId": "ListConsumptionBudgets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ConsumptionBudget with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ConsumptionBudget with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by partition_slug_path, where any ConsumptionBudget with a matching partition_slug_path in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "partition_slug_paths",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by resource, where any ConsumptionBudget with a matching resource in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "enum": [
                "LOG_PERSISTED_BYTES",
                "LOG_PROCESSED_BYTES",
                "METRIC_PERSISTED_SERIES"
              ],
              "type": "string"
            },
            "name": "resources",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListConsumptionBudgetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionBudget",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionBudgetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/v1/config/consumption-budgets/{slug}": {
      "delete": {
        "operationId": "DeleteConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionBudget because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadConsumptionBudgetResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateConsumptionBudgetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/v1/config/consumption-config": {
      "delete": {
        "operationId": "DeleteConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadConsumptionConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionConfig because there is a conflict with an existing ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      }
    },
    "/api/v1/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional. Flag to populate the `dashboard_json` field of the returned\ndashboards. By default, `dashboard_json` is empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/datasets": {
      "get": {
        "operationId": "ListDatasets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dataset with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dataset with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Custom filtering option: list filtered down to a specific telemetry type.",
            "enum": [
              "TRACES",
              "LOGS"
            ],
            "in": "query",
            "name": "type",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDatasetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "post": {
        "operationId": "CreateDataset",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/datasets/{slug}": {
      "delete": {
        "operationId": "DeleteDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dataset because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "get": {
        "operationId": "ReadDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDatasetResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "put": {
        "operationId": "UpdateDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDatasetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/derived-labels": {
      "get": {
        "operationId": "ListDerivedLabels",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedLabel with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedLabel with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedLabelsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "post": {
        "operationId": "CreateDerivedLabel",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-labels/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedLabel because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "get": {
        "operationId": "ReadDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedLabelResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedLabelBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-metrics": {
      "get": {
        "operationId": "ListDerivedMetrics",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedMetric with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedMetric with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedMetricsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "post": {
        "operationId": "CreateDerivedMetric",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/derived-metrics/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedMetric because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "get": {
        "operationId": "ReadDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedMetricResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedMetricBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/drop-rules": {
      "get": {
        "operationId": "ListDropRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DropRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DropRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDropRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "post": {
        "operationId": "CreateDropRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/drop-rules/{slug}": {
      "delete": {
        "operationId": "DeleteDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DropRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "get": {
        "operationId": "ReadDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDropRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "put": {
        "operationId": "UpdateDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDropRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations": {
      "get": {
        "operationId": "ListGcpMetricsIntegrations",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GcpMetricsIntegration with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GcpMetricsIntegration with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGcpMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to delete.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GcpMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to read.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGcpMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to update.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGcpMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards": {
      "get": {
        "operationId": "ListGrafanaDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GrafanaDashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any GrafanaDashboard with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any GrafanaDashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GrafanaDashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGrafanaDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "post": {
        "operationId": "CreateGrafanaDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "get": {
        "operationId": "ReadGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGrafanaDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGrafanaDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/log-allocation-config": {
      "delete": {
        "operationId": "DeleteLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogAllocationConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogAllocationConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogAllocationConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogAllocationConfig because there is a conflict with an existing LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      }
    },
    "/api/v1/config/log-control-config": {
      "delete": {
        "operationId": "DeleteLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogControlConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogControlConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogControlConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogControlConfig because there is a conflict with an existing LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      }
    },
    "/api/v1/config/log-ingest-config": {
      "delete": {
        "operationId": "DeleteLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogIngestConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogIngestConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogIngestConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogIngestConfig because there is a conflict with an existing LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      }
    },
    "/api/v1/config/log-scale-actions": {
      "get": {
        "operationId": "ListLogScaleActions",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAction with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAction with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleActionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAction",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-actions/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAction because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleActionResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleActionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts": {
      "get": {
        "operationId": "ListLogScaleAlerts",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAlert with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAlert with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleAlertsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAlert",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAlert because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleAlertResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleAlertBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/mapping-rules": {
      "get": {
        "operationId": "ListMappingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MappingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any MappingRule with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MappingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMappingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "post": {
        "operationId": "CreateMappingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/mapping-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MappingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "get": {
        "operationId": "ReadMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMappingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMappingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/monitors": {
      "get": {
        "operationId": "ListMonitors",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Monitor with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any Monitor with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Monitor with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Monitor with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter returned monitors by the teams that own the collections that they belong to.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMonitorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "CreateMonitor",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot create the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/monitors/{slug}": {
      "delete": {
        "operationId": "DeleteMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Monitor because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "get": {
        "operationId": "ReadMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMonitorResponse"
            }
          },
          "404": {
            "description": "Cannot read the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "operationId": "UpdateMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMonitorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot update the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/muting-rules": {
      "get": {
        "operationId": "ListMutingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MutingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MutingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Lists muting rules filtered by the states. If empty, all muting rules are\nincluded.",
            "in": "query",
            "items": {
              "enum": [
                "PENDING",
                "ACTIVE",
                "EXPIRED"
              ],
              "type": "string"
            },
            "name": "states",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMutingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "post": {
        "operationId": "CreateMutingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/muting-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MutingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "get": {
        "operationId": "ReadMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMutingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMutingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/notification-policies": {
      "get": {
        "operationId": "ListNotificationPolicies",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any NotificationPolicy with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any NotificationPolicy with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any NotificationPolicy with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any NotificationPolicy with a matching team_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotificationPoliciesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "post": {
        "operationId": "CreateNotificationPolicy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot create the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notification-policies/{slug}": {
      "delete": {
        "operationId": "DeleteNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NotificationPolicy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "get": {
        "operationId": "ReadNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotificationPolicyResponse"
            }
          },
          "404": {
            "description": "Cannot read the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "put": {
        "operationId": "UpdateNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotificationPolicyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot update the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notifiers": {
      "get": {
        "operationId": "ListNotifiers",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Notifier with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Notifier with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotifiersResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "post": {
        "operationId": "CreateNotifier",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot create the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/notifiers/{slug}": {
      "delete": {
        "operationId": "DeleteNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Notifier because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "get": {
        "operationId": "ReadNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotifierResponse"
            }
          },
          "404": {
            "description": "Cannot read the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "put": {
        "operationId": "UpdateNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotifierBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot update the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/otel-metrics-ingestion": {
      "delete": {
        "operationId": "DeleteOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the OtelMetricsIngestion because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the OtelMetricsIngestion because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "get": {
        "operationId": "ReadOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadOtelMetricsIngestionResponse"
            }
          },
          "404": {
            "description": "Cannot read the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "post": {
        "operationId": "CreateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot create the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the OtelMetricsIngestion because there is a conflict with an existing OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "put": {
        "operationId": "UpdateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot update the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      }
    },
    "/api/v1/config/recording-rules": {
      "get": {
        "operationId": "ListRecordingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RecordingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RecordingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The execution_groups filter cannot be used when a bucket_slug filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The bucket_slugs filter cannot be used when an execution_group filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "execution_groups",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRecordingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "post": {
        "operationId": "CreateRecordingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/recording-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RecordingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "get": {
        "operationId": "ReadRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRecordingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "put": {
        "operationId": "UpdateRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRecordingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/resource-pools": {
      "delete": {
        "operationId": "DeleteResourcePools",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ResourcePools because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ResourcePools because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "get": {
        "operationId": "ReadResourcePools",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadResourcePoolsResponse"
            }
          },
          "404": {
            "description": "Cannot read the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "post": {
        "description": "ResourcePools CRUD (subset for singleton objects)",
        "operationId": "CreateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot create the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ResourcePools because there is a conflict with an existing ResourcePools.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "put": {
        "operationId": "UpdateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot update the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      }
    },
    "/api/v1/config/rollup-rules": {
      "get": {
        "operationId": "ListRollupRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RollupRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RollupRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any RollupRule with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRollupRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "post": {
        "operationId": "CreateRollupRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/rollup-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RollupRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "get": {
        "operationId": "ReadRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRollupRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "put": {
        "operationId": "UpdateRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRollupRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/service-accounts": {
      "get": {
        "operationId": "ListServiceAccounts",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ServiceAccount with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ServiceAccount with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAccountsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "post": {
        "operationId": "CreateServiceAccount",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot create the ServiceAccount because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ServiceAccount because there is a conflict with an existing ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-accounts/{slug}": {
      "delete": {
        "operationId": "DeleteServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ServiceAccount because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "get": {
        "operationId": "ReadServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAccountResponse"
            }
          },
          "404": {
            "description": "Cannot read the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-attributes": {
      "get": {
        "operationId": "ListServiceAttributes",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAttributesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAttribute"
        ]
      }
    },
    "/api/v1/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given\nlist that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `team_slug`, where any Service with a matching `team_slug` in\nthe given list that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `name`, where any Service with a matching `name` in the given\nlist that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `notification_policy_slug`, where any Service with a matching\n`notification_policy_slug` in the given list that matches all other filters is\nreturned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/services/{service_slug}/attributes": {
      "delete": {
        "operationId": "DeleteServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "get": {
        "operationId": "ReadServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "post": {
        "operationId": "CreateServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1CreateServiceAttributeBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "put": {
        "operationId": "UpdateServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateServiceAttributeBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      }
    },
    "/api/v1/config/services/{slug}": {
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/slos": {
      "get": {
        "operationId": "ListSLOs",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SLO with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SLO with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListSLOsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "post": {
        "operationId": "CreateSLO",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateSLORequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SLO.",
            "schema": {
              "$ref": "#/definitions/configv1CreateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot create the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/slos/{slug}": {
      "delete": {
        "operationId": "DeleteSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteSLOResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SLO because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "get": {
        "operationId": "ReadSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadSLOResponse"
            }
          },
          "404": {
            "description": "Cannot read the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "put": {
        "operationId": "UpdateSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateSLOBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SLO.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot update the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/teams": {
      "get": {
        "operationId": "ListTeams",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Team with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Team with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTeamsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "post": {
        "operationId": "CreateTeam",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Team.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot create the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/teams/{slug}": {
      "delete": {
        "operationId": "DeleteTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTeamResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Team because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "get": {
        "operationId": "ReadTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTeamResponse"
            }
          },
          "404": {
            "description": "Cannot read the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "put": {
        "operationId": "UpdateTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTeamBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Team.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot update the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/trace-behavior-config": {
      "delete": {
        "operationId": "DeleteTraceBehaviorConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehaviorConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehaviorConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehaviorConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehaviorConfig because there is a conflict with an existing TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      }
    },
    "/api/v1/config/trace-behaviors": {
      "get": {
        "operationId": "ListTraceBehaviors",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceBehavior with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceBehavior with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceBehaviorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehavior",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-behaviors/{slug}": {
      "delete": {
        "operationId": "DeleteTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehavior because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceBehaviorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules": {
      "get": {
        "operationId": "ListTraceMetricsRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceMetricsRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceMetricsRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get trace metric rules by name.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "metric_names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceMetricsRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "post": {
        "description": "***\nTrace Metrics Rules\n***",
        "operationId": "CreateTraceMetricsRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules/{slug}": {
      "delete": {
        "operationId": "DeleteTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceMetricsRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "get": {
        "operationId": "ReadTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceMetricsRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "put": {
        "operationId": "UpdateTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceMetricsRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigV1"
    }
  ]
}