// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// ConditionOp condition op
//
// swagger:model ConditionOp
type ConditionOp string

func NewConditionOp(value ConditionOp) *ConditionOp {
	return &value
}

// Pointer returns a pointer to a freshly-allocated ConditionOp.
func (m ConditionOp) Pointer() *ConditionOp {
	return &m
}

const (

	// ConditionOpGEQ captures enum value "GEQ"
	ConditionOpGEQ ConditionOp = "GEQ"

	// ConditionOpGT captures enum value "GT"
	ConditionOpGT ConditionOp = "GT"

	// ConditionOpLEQ captures enum value "LEQ"
	ConditionOpLEQ ConditionOp = "LEQ"

	// ConditionOpLT captures enum value "LT"
	ConditionOpLT ConditionOp = "LT"

	// ConditionOpEQ captures enum value "EQ"
	ConditionOpEQ ConditionOp = "EQ"

	// ConditionOpNEQ captures enum value "NEQ"
	ConditionOpNEQ ConditionOp = "NEQ"

	// ConditionOpEXISTS captures enum value "EXISTS"
	ConditionOpEXISTS ConditionOp = "EXISTS"

	// ConditionOpNOTEXISTS captures enum value "NOT_EXISTS"
	ConditionOpNOTEXISTS ConditionOp = "NOT_EXISTS"
)

// for schema
var conditionOpEnum []interface{}

func init() {
	var res []ConditionOp
	if err := json.Unmarshal([]byte(`["GEQ","GT","LEQ","LT","EQ","NEQ","EXISTS","NOT_EXISTS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		conditionOpEnum = append(conditionOpEnum, v)
	}
}

func (m ConditionOp) validateConditionOpEnum(path, location string, value ConditionOp) error {
	if err := validate.EnumCase(path, location, value, conditionOpEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this condition op
func (m ConditionOp) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateConditionOpEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this condition op based on context it is used
func (m ConditionOp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
