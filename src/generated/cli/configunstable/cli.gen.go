// Code generated by chronogen; DO NOT EDIT
package configunstable

import (
	"context"

	"github.com/spf13/cobra"

	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/client"
	"github.com/chronosphereio/chronoctl-core/src/types"
)

// AddCommandsTo adds all entity subcommands to the given root command.
func AddCommandsTo(root *cobra.Command) {
	root.AddCommand(NewDashboardCmd())
	root.AddCommand(NewLinkTemplateCmd())
	root.AddCommand(NewSLOCmd())
	root.AddCommand(NewSavedTraceSearchCmd())
	root.AddCommand(NewServiceCmd())
	root.AddCommand(NewTraceTailSamplingRulesCmd())
}

func ApplyMappings() map[types.TypeMeta]func(context.Context, client.Clients, types.Object, bool) error {
	return map[types.TypeMeta]func(context.Context, client.Clients, types.Object, bool) error{
		DashboardTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*Dashboard)
			if !ok {
				return types.WrongObjectErr((&Dashboard{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateDashboard(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
		LinkTemplateTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*LinkTemplate)
			if !ok {
				return types.WrongObjectErr((&LinkTemplate{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateLinkTemplate(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
		SLOTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*SLO)
			if !ok {
				return types.WrongObjectErr((&SLO{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateSLO(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
		SavedTraceSearchTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*SavedTraceSearch)
			if !ok {
				return types.WrongObjectErr((&SavedTraceSearch{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateSavedTraceSearch(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
		ServiceTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*Service)
			if !ok {
				return types.WrongObjectErr((&Service{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateService(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
		TraceTailSamplingRulesTypeMeta: func(ctx context.Context, clients client.Clients, obj types.Object, dryRun bool) error {
			entity, ok := obj.(*TraceTailSamplingRules)
			if !ok {
				return types.WrongObjectErr((&TraceTailSamplingRules{}), obj)
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRun,
				CreateIfMissing: true,
			}
			_, err := UpdateTraceTailSamplingRules(ctx, clients.ConfigUnstable, entity, updateOpts)
			if err != nil {
				return err
			}
			return nil
		},
	}
}

// UpdateOptions represents the request level options for update.
type UpdateOptions struct {
	DryRun          bool
	CreateIfMissing bool
}
