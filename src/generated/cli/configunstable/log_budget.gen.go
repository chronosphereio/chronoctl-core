// Code generated by chronogen; DO NOT EDIT
package configunstable

import (
	"context"
	"fmt"

	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/client"
	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/clienterror"
	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/dry"
	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/file"
	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/groups"
	"github.com/chronosphereio/chronoctl-core/src/cmd/pkg/output"
	config_unstable "github.com/chronosphereio/chronoctl-core/src/generated/swagger/configunstable/client/operations"
	"github.com/chronosphereio/chronoctl-core/src/generated/swagger/configunstable/models"
	"github.com/chronosphereio/chronoctl-core/src/types"
	"github.com/spf13/cobra"
)

func init() { types.MustRegisterObject(LogBudgetTypeMeta, &LogBudget{}) }

var _ types.Object = &LogBudget{}

var LogBudgetTypeMeta = types.TypeMeta{
	APIVersion: "unstable/config",
	Kind:       "LogBudget",
}

type LogBudget struct {
	types.TypeMeta `json:",inline"`
	Spec           *models.ConfigunstableLogBudget `json:"spec"`
}

func NewLogBudget(spec *models.ConfigunstableLogBudget) *LogBudget {
	return &LogBudget{
		TypeMeta: LogBudgetTypeMeta,
		Spec:     spec,
	}
}

func (e *LogBudget) Description() string {
	return types.TypeDescription(e)
}

func (e *LogBudget) Identifier() string {
	return "LogBudget"
}

func CreateLogBudget(
	ctx context.Context,
	client config_unstable.ClientService,
	entity *LogBudget,
	dryRun bool,
) (*LogBudget, error) {
	res, err := client.CreateLogBudget(&config_unstable.CreateLogBudgetParams{
		Context: ctx,
		Body: &models.ConfigunstableCreateLogBudgetRequest{
			DryRun:    dryRun,
			LogBudget: entity.Spec,
		},
	})
	if err != nil {
		return nil, clienterror.Wrap(err)
	}
	return NewLogBudget(res.Payload.LogBudget), nil
}

func newLogBudgetCreateCmd() *cobra.Command {
	var (
		permissiveParsing bool
		dryRunFlags       = dry.NewFlags()
		clientFlags       = client.NewClientFlags()
		outputFlags       = output.NewFlags(output.WithoutOutputDirectory(), output.WithoutCreateFilePerObject())
		fileFlags         = file.NewFlags(true /* required */)
	)

	var (
		use   string
		short string
	)
	use = "create -f <file>"
	short = "Creates a single LogBudget."

	cmd := &cobra.Command{
		Use:     use,
		GroupID: groups.Commands.ID,
		Short:   short,
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, cancel := context.WithTimeout(cmd.Context(), clientFlags.Timeout())
			defer cancel()
			if err := outputFlags.Validate(); err != nil {
				return err
			}
			defer outputFlags.Close(cmd.OutOrStdout())
			stderr := output.NewStderrPrinter(cmd)

			client, err := clientFlags.ConfigUnstableClient()
			if err != nil {
				return err
			}

			var logBudget *LogBudget
			file, err := fileFlags.File()
			if err != nil {
				return err
			}
			defer file.Close() //nolint:errcheck
			logBudget, err = types.MustDecodeSingleObject[*LogBudget](file, permissiveParsing)
			if err != nil {
				return err
			}

			if dryRunFlags.DryRun {
				stderr.Println("--dry-run is set")
			}
			fullLogBudget, err := CreateLogBudget(ctx, client, logBudget, dryRunFlags.DryRun)
			if err != nil {
				return err
			}

			if dryRunFlags.DryRun {
				stderr.Println("LogBudget is valid and can be created")
				return nil
			}
			stderr.Printf("LogBudget created successfully\n")

			if err := outputFlags.WriteObject(fullLogBudget, cmd.OutOrStdout()); err != nil {
				return err
			}
			return nil
		},
	}
	dryRunFlags.AddFlags(cmd)
	clientFlags.AddFlags(cmd)
	outputFlags.AddFlags(cmd)
	fileFlags.AddFlags(cmd)
	cmd.Flags().BoolVar(&permissiveParsing, "no-strict", false, "If set, manifests with unknown fields are not rejected. Defaults to false.")

	return cmd
}

func GetLogBudget(
	ctx context.Context,
	client config_unstable.ClientService,
) (*LogBudget, error) {
	res, err := client.ReadLogBudget(&config_unstable.ReadLogBudgetParams{
		Context: ctx,
	})
	if err != nil {
		return nil, clienterror.Wrap(err)
	}
	return NewLogBudget(res.GetPayload().LogBudget), nil
}

func newLogBudgetReadCmd() *cobra.Command {
	clientFlags := client.NewClientFlags()
	outputFlags := output.NewFlags(output.WithoutOutputDirectory(), output.WithoutCreateFilePerObject())
	var (
		short string
		use   string
		args  cobra.PositionalArgs
	)
	short = "Reads a LogBudget singleton"
	use = "read"

	cmd := &cobra.Command{
		Use:     use,
		GroupID: groups.Commands.ID,
		Short:   short,
		Args:    args,
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, cancel := context.WithTimeout(cmd.Context(), clientFlags.Timeout())
			defer cancel()
			if err := outputFlags.Validate(); err != nil {
				return err
			}
			defer outputFlags.Close(cmd.OutOrStdout())

			client, err := clientFlags.ConfigUnstableClient()
			if err != nil {
				return err
			}
			entity, err := GetLogBudget(ctx, client)
			if err != nil {
				return err
			}
			if err := outputFlags.WriteObject(entity, cmd.OutOrStdout()); err != nil {
				return err
			}
			return nil
		},
	}

	clientFlags.AddFlags(cmd)
	outputFlags.AddFlags(cmd)

	return cmd
}

func UpdateLogBudget(
	ctx context.Context,
	client config_unstable.ClientService,
	entity *LogBudget,
	opts UpdateOptions,
) (*LogBudget, error) {
	res, err := client.UpdateLogBudget(&config_unstable.UpdateLogBudgetParams{
		Context: ctx,
		Body: &models.ConfigunstableUpdateLogBudgetRequest{
			CreateIfMissing: opts.CreateIfMissing,
			DryRun:          opts.DryRun,
			LogBudget:       entity.Spec,
		},
	})
	if err != nil {
		return nil, clienterror.Wrap(err)
	}

	return NewLogBudget(res.Payload.LogBudget), nil
}

func newLogBudgetUpdateCmd() *cobra.Command {
	var (
		permissiveParsing bool
		createIfMissing   bool
		dryRunFlags       = dry.NewFlags()
		clientFlags       = client.NewClientFlags()
		outputFlags       = output.NewFlags(output.WithoutOutputDirectory(), output.WithoutCreateFilePerObject())
		fileFlags         = file.NewFlags(true /* required */)
	)

	cmd := &cobra.Command{
		Use:     "update -f <filename>",
		GroupID: groups.Commands.ID,
		Short:   "Updates an existing LogBudget.",
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, cancel := context.WithTimeout(cmd.Context(), clientFlags.Timeout())
			defer cancel()
			if err := outputFlags.Validate(); err != nil {
				return err
			}
			defer outputFlags.Close(cmd.OutOrStdout())
			stderr := output.NewStderrPrinter(cmd)

			client, err := clientFlags.ConfigUnstableClient()
			if err != nil {
				return err
			}

			file, err := fileFlags.File()
			if err != nil {
				return err
			}
			defer file.Close() //nolint:errcheck

			logBudget, err := types.MustDecodeSingleObject[*LogBudget](file, permissiveParsing)
			if err != nil {
				return err
			}

			updateOpts := UpdateOptions{
				DryRun:          dryRunFlags.DryRun,
				CreateIfMissing: createIfMissing,
			}

			if dryRunFlags.DryRun {
				stderr.Println("--dry-run is set, update not persisted")
			}

			fullLogBudget, err := UpdateLogBudget(ctx, client, logBudget, updateOpts)
			if err != nil {
				return err
			}

			if dryRunFlags.DryRun {
				stderr.Println("LogBudget is valid and can be updated")
				return nil
			}
			stderr.Printf("LogBudget applied successfully\n")

			if err := outputFlags.WriteObject(fullLogBudget, cmd.OutOrStdout()); err != nil {
				return err
			}
			return nil
		},
	}
	dryRunFlags.AddFlags(cmd)
	clientFlags.AddFlags(cmd)
	outputFlags.AddFlags(cmd)
	fileFlags.AddFlags(cmd)
	cmd.Flags().BoolVar(&permissiveParsing, "no-strict", false, "If set, manifests with unknown fields are allowed. Defaults to false.")
	cmd.Flags().BoolVar(&createIfMissing, "create-if-missing", false, "If set, creates the LogBudget if it does not already exist. Defaults to false.")

	return cmd
}

func DeleteLogBudget(
	ctx context.Context,
	client config_unstable.ClientService,
) error {
	_, err := client.DeleteLogBudget(&config_unstable.DeleteLogBudgetParams{
		Context: ctx,
	})
	if err != nil {
		return clienterror.Wrap(err)
	}
	return nil
}

func newLogBudgetDeleteCmd() *cobra.Command {
	clientFlags := client.NewClientFlags()
	outputFlags := output.NewFlags(output.WithoutOutputDirectory(), output.WithoutCreateFilePerObject())

	cmd := &cobra.Command{
		Use:     "delete",
		GroupID: groups.Commands.ID,
		Short:   "Deletes the LogBudget singleton",
		Args:    cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, cancel := context.WithTimeout(cmd.Context(), clientFlags.Timeout())
			defer cancel()
			if err := outputFlags.Validate(); err != nil {
				return err
			}
			defer outputFlags.Close(cmd.OutOrStdout())

			client, err := clientFlags.ConfigUnstableClient()
			if err != nil {
				return err
			}

			res, err := client.DeleteLogBudget(&config_unstable.DeleteLogBudgetParams{
				Context: ctx,
			})
			if err != nil {
				return clienterror.Wrap(err)
			}
			_ = res
			fmt.Fprintf(cmd.OutOrStdout(), "deleted LogBudget")
			return nil
		},
	}
	clientFlags.AddFlags(cmd)
	outputFlags.AddFlags(cmd)
	return cmd
}

const LogBudgetScaffoldYAML = `api_version: unstable/config
kind: LogBudgets
spec:
    monthly_budget:
        # resources are the required resources of the global budget. Must set an
        # entry for each resource of the global budget's telemetry type (e.g. logs,
        # metrics, etc). Any global resource behaviors are applied after sub-budget
        # behaviors.
        resources:
            - # behaviors are optional budget behaviors.
              behaviors:
                - action: <ALERT_WARN|ALERT_CRITICAL|DROP>
                  instant_rate_threshold:
                    # fixed_value_per_sec is the required rate threshold.
                    fixed_value_per_sec: <int64>
                  threshold_type: <TARGET|INSTANT_RATE>
              resource: <LOG_PERSISTED_BYTES>
              target:
                # fixed_value describes the target as a fixed value. Mutually exclusive
                # with percent_of_parent_target; exactly one must be set.
                fixed_value: <int64>
                # percent_of_parent_target describes the target as a percentage of the
                # parent budget's target. Can be set only if the parent budget has a
                # target set. Cannot set on the global budget, since it has no parent.
                # Mutually exclusive with fixed_value; exactly one must be set.
                percent_of_parent_target: <number>
        # priorities are optional global budget priorities. Priorities define the
        # order in which requests should be dropped when necessary (i.e. lowest
        # priority dropped first, highest priority dropped last). If a request does
        # not match any priority dataset, then it defaults to the lowest priority.

        # Global budget priorities are also used by internal Chronosphere system
        # limiters when dropping requests.
        priorities:
            - # dataset_slug is the required slug of the priority's dataset. Priority
              # datasets are implicitly AND'd with the budget dataset. Must match the
              # global budget's telemetry type (e.g. logs, metrics etc).
              dataset_slug: <string>
              # priority is the required priority of the dataset, where priority=1 is
              # the highest priority, and priority=64 is the lowest priority.
              priority: <integer>
        # budgets are optional sub-budgets of the global budget. Incoming
        # requests match to a budget by dataset, where the first match wins (i.e.
        # ordering matters). If a request does not match any budget, it falls back
        # to the default_budget.
        budgets:
            - # slug is the required human-readable identifier of the budget.
              slug: <string>
              # dataset_slug is the required slug of the budget's dataset. Must match
              # the global budget's telemetry type (e.g. logs, metrics etc).
              dataset_slug: <string>
              # resources are the required resources of the budget. Must set an entry
              # for each resource of the global budget's telemetry type (e.g. logs,
              # metrics, etc).
              resources:
                - # behaviors are optional budget behaviors.
                  behaviors:
                    - action: <ALERT_WARN|ALERT_CRITICAL|DROP>
                      instant_rate_threshold:
                        # fixed_value_per_sec is the required rate threshold.
                        fixed_value_per_sec: <int64>
                      threshold_type: <TARGET|INSTANT_RATE>
                  resource: <LOG_PERSISTED_BYTES>
                  target:
                    # fixed_value describes the target as a fixed value. Mutually exclusive
                    # with percent_of_parent_target; exactly one must be set.
                    fixed_value: <int64>
                    # percent_of_parent_target describes the target as a percentage of the
                    # parent budget's target. Can be set only if the parent budget has a
                    # target set. Cannot set on the global budget, since it has no parent.
                    # Mutually exclusive with fixed_value; exactly one must be set.
                    percent_of_parent_target: <number>
              # priorities are optional budget priorities. Priorites define in what
              # order should requests be dropped when necessary (i.e. lowest priority
              # dropped first, highest priority dropped last). If a request does not
              # match any priority dataset, then it defaults to the lowest priority.
              priorities:
                - # dataset_slug is the required slug of the priority's dataset. Priority
                  # datasets are implicitly AND'd with the budget dataset. Must match the
                  # global budget's telemetry type (e.g. logs, metrics etc).
                  dataset_slug: <string>
                  # priority is the required priority of the dataset, where priority=1 is
                  # the highest priority, and priority=64 is the lowest priority.
                  priority: <integer>
        default_budget:
            # resources are the optional resources of the default budget.

            # Unlike regular budgets, any unset resource target defaults to whatever
            # portion of the global resource budget remains after all sub-budget
            # targets are subtracted.
            resources:
                - # behaviors are optional budget behaviors.
                  behaviors:
                    - action: <ALERT_WARN|ALERT_CRITICAL|DROP>
                      instant_rate_threshold:
                        # fixed_value_per_sec is the required rate threshold.
                        fixed_value_per_sec: <int64>
                      threshold_type: <TARGET|INSTANT_RATE>
                  resource: <LOG_PERSISTED_BYTES>
                  target:
                    # fixed_value describes the target as a fixed value. Mutually exclusive
                    # with percent_of_parent_target; exactly one must be set.
                    fixed_value: <int64>
                    # percent_of_parent_target describes the target as a percentage of the
                    # parent budget's target. Can be set only if the parent budget has a
                    # target set. Cannot set on the global budget, since it has no parent.
                    # Mutually exclusive with fixed_value; exactly one must be set.
                    percent_of_parent_target: <number>
            # priorities are optional default budget priorities. Priorities
            # define in what order should requests be dropped when necessary (i.e.
            # lowest priority dropped first, highest priority dropped last). If a
            # request does not match any priority dataset, then it defaults to the
            # lowest priority.
            priorities:
                - # dataset_slug is the required slug of the priority's dataset. Priority
                  # datasets are implicitly AND'd with the budget dataset. Must match the
                  # global budget's telemetry type (e.g. logs, metrics etc).
                  dataset_slug: <string>
                  # priority is the required priority of the dataset, where priority=1 is
                  # the highest priority, and priority=64 is the lowest priority.
                  priority: <integer>
`

func newLogBudgetScaffoldCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "scaffold",
		GroupID: groups.Commands.ID,
		Short:   "Scaffolds a complete object with placeholder values",
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Fprint(cmd.OutOrStdout(), LogBudgetScaffoldYAML)
		},
	}
	return cmd
}

func NewLogBudgetCmd() *cobra.Command {
	root := &cobra.Command{
		Use:     "log-budget",
		GroupID: groups.Config.ID,
		Short:   "All commands for LogBudget",
	}

	root.AddGroup(groups.Commands)
	root.AddCommand(
		newLogBudgetCreateCmd(),
		newLogBudgetReadCmd(),
		newLogBudgetUpdateCmd(),
		newLogBudgetDeleteCmd(),
		newLogBudgetScaffoldCmd(),
	)
	return root
}
